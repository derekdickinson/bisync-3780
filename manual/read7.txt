@CHAPTER HEAD = Alphabetical Command Summary

<$M[Comsum]>These names are used throughout the command descriptions 
for the sake of brevity.

@LIST = <MI>dest<D>	= label or line number 

@LIST = <MI>ptr<D>	= any pointer type { strings or buffers } 

@LIST = <MI>num<D>	= any scalar, other values are assumed 

@LIST = <MI>val<D>	= Scalar or pointer 

@LIST = <MI>file<D>	= a filename (no wildcards) 

@LIST = <MI>spec<D>	= a filename (wildcards allowed)

Also, <169>[]<170> brackets are used to enclose optional parameters 
and <169>...<170> ellipses are used to indicate that more similar 
options can follow.

Each command includes a description of the errors it can generate. 
There are several errors which can be generated by any command which 
takes a parameter.

@ERROR ITEM = 52 "&" not allowed on data type in "?????"

@ERROR ITEM = 53 Brackets not allowed in "?????"

@ERROR ITEM = 54 "^" on non-string "?????"

@ERROR ITEM = 55 Did not understand syntax (Press "?" for help)

@ERROR ITEM = 56 Bad final character in "?????"

@ERROR ITEM = 57 Bad index in "?????", index must be a scalar

@ERROR ITEM = 65 Unknown Variable or Symbol and parameter not allowed 
together in "?????"

@ERROR ITEM = 66 Unknown Variable [?????]

@ERROR ITEM = 73 Number in "?????" must be between 0-9

@ERROR ITEM = 109 User Abort

Commands which do not accept parameters cannot generate these errors. 
The DOS shell commands (<169>>><170>, <169>.<170>, <169>/<170>) and 
comments <169>*<170> also cannot generate these errors. All other 
commands can generate them so they will not be included in the individual 
lists of possible errors.

The branching commands (IF,IFI,ON,etc.) allow a command to be executed 
in place of a label. If this is the case then the errors generated 
by the command can occur as well as the errors possible from the branching 
command itself.

Here Goes:

@COMMAND = Command:

@COMMAND ITEM = ? or HELP

@DESCRIPT = Purpose:

@DES ITEM = Provide help for user

@DESCRIPT = Restrictions:

@DES ITEM = <$R[V*,Packname]D3-3780>.HLP must be available

@DESCRIPT = Syntax:

@DES ITEM = ?[,<$R[V*,Packname]D3-3780> command or page number]

@DESCRIPT = Argument:

@DES ITEM = If None, provides general help

@DES EXT = If a number, it provides later pages of general help

@DES EXT = If a command, it will be a specific help about the command

The <169>?<170> by itself supplies a general help on <$R[V*,Packname]D3-3780>. 
More pages are available by typing <169>?,#<170> where <169>#<170> 
is a digit (0-9). Also, a specific help on a particular command will 
be available by typing <169>?,command<170>. This command cannot return 
an error.

@COMMAND = Command:

@COMMAND ITEM = >> or .

@DESCRIPT = Purpose:

@DES ITEM = Load a DOS shell

@DESCRIPT = Restrictions:

@DES ITEM =  Sufficient memory must be available.

@DESCRIPT = Syntax:

@DES ITEM = [DOS command]

@DESCRIPT = Argument:

@DES ITEM = If None, loads DOS shell, you must enter <169>exit<170> 
to return

@DES EXT = If a DOS command, the DOS command is executed

The <169>>><170> and <169>.<170> characters are a quick way to call 
up a DOS shell when running interactive. They are not useful for script 
mode since they ask before returning back into the <$R[V*,Packname]D3-3780>. 
The <169>/<170> command below is used for that. The <169>>><170> is 
mnuemonic for DOS but the <169>.<170> is does not require the use 
of the shift key. Thus, either can be used. Incidentally, redirection 
and piping on the command line are supported, more on this later. 
The errors for this command are:

@ERROR ITEM = 50 Argument List too big

@ERROR ITEM = 96 Insufficient memory to process command

The 50 and 96 are the values which will be assigned to the EI variable. 
The messages to the right will be displayed on the screen.

@COMMAND = Command:

@COMMAND ITEM = /

@DESCRIPT = Purpose:

@DES ITEM = Load a DOS shell

@DESCRIPT = Restrictions:

@DES ITEM = Sufficient memory must be available.

@DESCRIPT = Syntax:

@DES ITEM = /[DOS command]

@DESCRIPT = Argument:

@DES ITEM = If None, loads DOS shell, you must enter <169>exit<170> 
to return

@DES EXT = If a DOS command, the DOS command is executed

Same as <169>>><170> and <169>.<170> above except it returns immediately 
without asking. This is useful in script mode or as a remote command. 
Also if the command does not produce results that you want to view 
before returning. Errors are the same as <169>>><170> and <169>.<170> 
above.

@COMMAND = Command:

@COMMAND ITEM = *

@DESCRIPT = Purpose:

@DES ITEM = Comment

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = *[Any thing you want out here up to 200 characters]

@DESCRIPT = Argument:

@DES ITEM = Nothing or a string containing anything

Just a comment. If the screen output is suppressed then the comments 
will not be seen either. See the RITE command for displaying information 
for script file spectators. No errors generated for this command.

@COMMAND = Command:

@COMMAND ITEM = AA

@DESCRIPT = Purpose:

@DES ITEM = Set the modem to answer the phone.

@DESCRIPT = Restrictions:

@DES ITEM = The modem cannot be online already

@DESCRIPT = Syntax:

@DES ITEM = aa[,+timeout] or [,hh:mm]

@DESCRIPT = Argument:

@DES ITEM = If None, waits forever

@DES EXT = If a <169>+<170> with timeout, waits for timeout times 
10 seconds

@DES EXT = If a 24 hour timeout time, waits until that time

This sets the modem to answer the phone. The command can, optionally, 
be made to timeout at a certain time (24 hour time) or after a certain 
number of 10 second intervals. The error indicator will be set appropriately 
if the timeout occurs.

Errors:

@ERROR ITEM = 7 This command cannot be performed while online

@ERROR ITEM = 29 Timeout expired

@ERROR ITEM = 91 The time designation should contain a colon

@COMMAND = Command:

@COMMAND ITEM = ALLOC

@DESCRIPT = Purpose:

@DES ITEM = Allocates memory and assigns a pointer to point to it

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = alloc <MI>ptr<D>,<MI>num<D>

@DESCRIPT = Argument 1:

@DES ITEM = Pointer which will point to the memory segment

@DESCRIPT = 2:

@DES ITEM = The number of bytes to allocate

This command is used to allocate a memory buffer. The first value 
is any pointer variable and the second value is the number of bytes 
to allocate. This is useful to create buffers in which to load parts 
of files and/or to create buffers in which received data will be stored. 
If <MI>ptr<D> is not NULL (equal to NU) then any memory which it currently 
points to will automatically be freed. See Section <$R[S*,Poifunds]5.6> 
for more information on the use of pointers.

Errors:

@ERROR ITEM = 84 Parameter [?????] should be a pointer variable

@ERROR ITEM = 86 This command requires 2 parameter(s)

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@ERROR ITEM = 93 Insufficient internal memory to process command

@COMMAND = Command:

@COMMAND ITEM = ALLST

@DESCRIPT = Purpose:

@DES ITEM = Allocates memory for a string and assigns pointer to it

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = allst <MI>ptr<D>,<MI>ptr<D>

@DESCRIPT = Argument 1:

@DES ITEM = Pointer which will point to the string

@DESCRIPT = 2:

@DES ITEM = String or pointer to be copied into allocated memory

This command is used to allocate memory for a string and copy the 
string into the allocated memory. The CPY command is similar except 
the pointer variable must already be pointing to some allocated memory. 
If <MI>ptr<D> is not NULL (equal to NU) then the memory pointed to 
by it will automatically be freed. See Section <$R[S*,Poifunds]5.6> 
for more information on the use of pointers.

Errors:

@ERROR ITEM = 84 Parameter [?????] should be a pointer variable

@ERROR ITEM = 85 Parameter [?????] should be a string constant or 
pointer

@ERROR ITEM = 86 This command requires 2 parameter(s)

@ERROR ITEM = 93 Insufficient internal memory to process command

@COMMAND = Command:

@COMMAND ITEM = APP

@DESCRIPT = Purpose:

@DES ITEM = Appends data pointed to by <MI>ptr<D> to a file named 
by <MI>file<D>

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = app <MI>ptr<D>,<MI>file<D>[,<MI>val<D>]

@DESCRIPT = Argument 1:

@DES ITEM = A pointer to a buffer (to write)

@DESCRIPT = 2:

@DES ITEM = filename to write to

@DESCRIPT = 3:

@DES ITEM = If None, copies until a 0 is found or end of destination 
buffer

@DES EXT = if a scalar, then the value is the number of bytes to write

@DES EXT = if a pointer, then the value will be the upper bound

The APPend command is a quick and dirty <169>add data to a file<170> 
command. It is especially useful if you want to log information to 
file. This command saves you the trouble of having to open the <MI>file<D>, 
write to it and then close it. The third optional parameter is either 
a length (scalar) or a pointer to the first location past the end 
of the buffer. If neither is specified then the command will write 
until the end of the buffer or until a hex 0 is found in the buffer 
(whichever comes first). The pointer technique is useful if you set 
up the series of P? variables to point into an allocated buffer for 
different purposes. For example:

@EXAMPLES = app %p3,dummy.txt,%p4

If P4 were the next designated data area this would cause the entire 
P3 data area to be written out but none of P4.

The <169>!<170> operator is useful here to write the contents of a 
binary buffer to a file. For example:

@EXAMPLES = alloc %p3,100

@EXAMPLES = load %p3,binfile.exe

@EXAMPLES = app %p3,dummy.bin,!p3

This would write 100 bytes to the end of file dummy.bin regardless 
of the contents of %P3. Also, the source pointer need not have been 
the pointer used with the ALLOC or other memory allocation command. 
When pointers are assigned values then the implied lengths are to 
the end of the data area to which they point. For example:

@EXAMPLES = alloc %p0,1000

@EXAMPLES = mov %p1,&p0[900]

@EXAMPLES = load %p1,binfile.exe

@EXAMPLES = app %p1,dummy.bin,!p1

This has the same effect as the prior example since the implied length 
of the P1 variable is 100.

The <MI>ptr<D> parameter can also be an integer. If <MI>ptr<D> is 
an integer then its ASCII equivalent value will be written to the 
<MI>file<D>. That is, the if the integer is a 99 the string <169>99<170> 
will be written to the <MI>file<D>. The <MI>val<D> parameter is irrelevant 
if <MI>ptr<D> is not a scalar type.

Errors:

@ERROR ITEM = 2 Unable to open file [?????]

@ERROR ITEM = 69 Length pointer [?????] must point into the memory 
buffer

@ERROR ITEM = 74 At least 2 parameter(s) required for this command

@ERROR ITEM = 80 Parameter [??????] must be a filename

@ERROR ITEM = 82 Length Parameter [?????] cannot be a file or label

@ERROR ITEM = 98 The filename cannot include wildcards

@COMMAND = Command:

@COMMAND ITEM = ASTAT

@DESCRIPT = Purpose:

@DES ITEM = Displays the size and time and data of all open files.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = astat

This command gives a list containing the file size, and time and date 
of last modification of all the currently open files. This command 
does not return any errors.

@COMMAND = Command:

@COMMAND ITEM = BDN

@DESCRIPT = Purpose:

@DES ITEM = Sets up buffer for receiving data having the punch destination.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = bdn <MI>buf<D>[,<MI>val<D>][;op]

@DESCRIPT = Argument <MI>buf<D>:

@DES ITEM = Pointer to the buffer in which to put data

@DESCRIPT = <MI>val<D>:

@DES ITEM = if None, length of <MI>buf<D> is used

@DES EXT = if a scalar then the value is the number of bytes to write

@DES EXT = if a pointer then the value will be the upper bound

@DESCRIPT = op:

@DES ITEM = <169>L<170> to store the last portion of the received 
data (default stores first portion)

This command allows you to set up a buffer which store received data 
having the punch destination. The regular destination (set with DN) 
will still receive the data but an extra copy is put in this buffer. 
The optional <MI>val<D> specifier indicates the length of the buffer. 
It can be blank, a number or a pointer. Section <$R[S*,Copcmds]6.4> 
describes how the length parameter is interpreted.

The op parameter is either an <169>L<170> or nothing. The <169>L<170> 
stands for last. If the size of the reception is larger than the buffer 
then, by default, the buffer will take the first values from the reception 
and stop saving them after that. If the <169>L<170> option is selected 
then new data will wrap around and overwrite the old data. In this 
way the newest data will be in the buffer. After the reception the 
buffer will automatically be unwrapped so that the last data in the 
file occurs in chronological order from beginning to end in the buffer.

Errors:

@ERROR ITEM = 69 Length pointer [?????] must point into the memory 
buffer

@ERROR ITEM = 77 Buffer pointer [?????] must have memory allocated 
to it

@ERROR ITEM = 82 Length Parameter [?????] cannot be a file or label

@ERROR ITEM = 94 Label not allowed in parameter [?????] 100 Optional 
parameter must be 'L' or nonexistent

@COMMAND = Command:

@COMMAND ITEM = BDP

@DESCRIPT = Purpose:

@DES ITEM = Sets up buffer for received data having the printer destination.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = bdp <MI>buf<D>[,<MI>val<D>][;op]

@DESCRIPT = Argument <MI>buf<D>:

@DES ITEM = Pointer to the buffer in which to put data

@DESCRIPT = <MI>val<D>:

@DES ITEM = if None, length of <MI>buf<D> is used

@DES EXT = if a scalar then the value is the number of bytes to write

@DES EXT = if a pointer then the value will be the upper bound

@DESCRIPT = op:

@DES ITEM = <169>L<170> to store the last portion of the received 
data (default stores first portion)

Same as bdn except for the printer rather than punch.

@COMMAND = Command:

@COMMAND ITEM = BUF

@DESCRIPT = Purpose:

@DES ITEM = Sets up buffer for incoming data.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = buf <MI>buf<D>[,<MI>val<D>][;op]

@DESCRIPT = Argument <MI>buf<D>:

@DES ITEM = Pointer to the buffer in which to put data

@DESCRIPT = <MI>val<D>:

@DES ITEM = if None, length of <MI>buf<D> is used

@DES EXT = if a scalar then the value is the number of bytes to write

@DES EXT = if a pointer then the value will be the upper bound

@DESCRIPT = op:

@DES ITEM = <169>L<170> to store the last portion of the received 
data (default stores first portion)

This option is similar to the bdn and bdp options except that it buffers 
both of them. It can be used at same time as the bdn and bdp commands. 
Thus, it is possible to have data copied into two different buffers 
(plus its destination) during the same reception. It may be useful 
to use both at the same time to catch both the first and last parts 
of a reception (by specifying the <169>L<170> option for one buffer). 
The errors are the same as in bdn command.

@COMMAND = Command:

@COMMAND ITEM = C

@DESCRIPT = Purpose:

@DES ITEM = Takes modem off hook in private line mode.

@DESCRIPT = Restrictions:

@DES ITEM = Must have access to MODEMS.DTA file, the modem cannot 
be online

@DESCRIPT = Syntax:

@DES ITEM = c

This option allows the modem to communicate in private line mode.

Errors:

@ERROR ITEM = 07 This command cannot be performed while online

@ERROR ITEM = 11 The modem was unable to train

@COMMAND = Command:

@COMMAND ITEM = CALL

@DESCRIPT = Purpose:

@DES ITEM = Calls another command <MI>file<D> or a subroutine in the 
current file

@DESCRIPT = Restrictions:

@DES ITEM = Script mode only

@DESCRIPT = Syntax:

@DES ITEM = call <MI>dest<D> or <MI>file<D>

@DESCRIPT = Argument:

@DES ITEM = if a <MI>file<D>, that <MI>file<D> will become the new 
script file.

@DES EXT = if a label, that label will be branched to

@DES EXT = if a scalar, the line number will be branched to

This command allows you to create a super-command either in the same 
file or in other files. If the call is to another <MI>file<D> then 
the processing will return to the line following the call once the 
script <MI>file<D> has been executed. If the call is within the same 
file then the processing will return to the line following the call 
when a RET return instruction is processed.

Errors:

@ERROR ITEM = 58 Label [?????] not found

@ERROR ITEM = 59 Line number ??,[??] exceeds script file length

@ERROR ITEM = 67 This command is only allowed in script mode

@ERROR ITEM = 68 Script file read error

@ERROR ITEM = 79 The destination parameter [?????] must be label or 
line number

@ERROR ITEM = 93 Insufficient internal memory to process command

@ERROR ITEM = 97 Could not return to file "???????".

@COMMAND = Command:

@COMMAND ITEM = CAT

@DESCRIPT = Purpose:

@DES ITEM = Concatenates two strings.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = cat destptr,sourceptr[,<MI>val<D>]

@DESCRIPT = Argument 1:

@DES ITEM = Destination string

@DESCRIPT = 2:

@DES ITEM = Source string

@DESCRIPT = 3:

@DES ITEM = If none, length of destptr

@DES EXT = if a scalar then the value is the maximum length for destptr

@DES EXT = if a pointer then the value will be the upper bound

Copies the string pointed to by sourceptr onto the end of the string 
pointed to by destptr. Section <$R[S*,Copcmds]6.4> describes the possible 
values for length parameters.

Errors:

@ERROR ITEM = 69 Length pointer [?????] must point into the memory 
buffer

@ERROR ITEM = 77 Buffer pointer [?????] must have memory allocated 
to it

@ERROR ITEM = 82 Length Parameter [?????] cannot be a file or label

@ERROR ITEM = 85 Parameter [?????] should be a string constant or 
pointer

@ERROR ITEM = 86 This command requires 2 parameter(s)

@COMMAND = Command:

@COMMAND ITEM = CLALL

@DESCRIPT = Purpose:

@DES ITEM = Closes all open files

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = clall

Closes the <MI>file<D> for every handle. No errors are possible.

@COMMAND = Command:

@COMMAND ITEM = CLOSE

@DESCRIPT = Purpose:

@DES ITEM = Closes a <MI>file<D>

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = close handle

@DESCRIPT = Argument:

@DES ITEM = The handle of the <MI>file<D> to close

This command closes the <MI>file<D> specified by handle.

Errors:

@ERROR ITEM = 20 The file specified by handle [?????] is not open

@ERROR ITEM = 86 This command requires 1 parameter(s)

@COMMAND = Command:

@COMMAND ITEM = CLRCA

@DESCRIPT = Purpose:

@DES ITEM = Clears the unreturned calls

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = clrca

This command clears all unreturned calls. It is useful when an error 
occurs in a subroutine and you want to branch to a general purpose 
error handler. There are no possible errors returned for this command.

@COMMAND = Command:

@COMMAND ITEM = CLS

@DESCRIPT = Purpose:

@DES ITEM = Clears the command window

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = cls

This command clears the command window and puts the prompt at the 
top line. No errors are possible with this command.

@COMMAND = Command:

@COMMAND ITEM = COMP

@DESCRIPT = Purpose:

@DES ITEM = Compresses a <MI>file<D> using runlength compression

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = comp sourcefile,destfile

@DESCRIPT = Argument 1:

@DES ITEM = File to compress

@DESCRIPT = 2:

@DES ITEM = Name to use for resulting <MI>file<D>

@COMMAND = Command:

@COMMAND ITEM = CPY

@DESCRIPT = Purpose:

@DES ITEM = Copies a buffer or string to another location.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = cpy destptr,sourceptr[,<MI>val<D>]

@DESCRIPT = Argument 1:

@DES ITEM = Destination pointer

@DESCRIPT = 2:

@DES ITEM = Source pointer

@DESCRIPT = 3:

@DES ITEM = If None, copies until a 0 is found or end of destination 
buffer 

@DES EXT = if a scalar then the value is the number of bytes to write 


@DES EXT = if a pointer then the value will be the upper bound

The area pointed to by destptr will receive the data pointed to by 
sourceptr. The optional <MI>val<D> parameter is the maximum length 
as covered in Section <$R[S*,Copcmds]6.4>. If no <MI>val<D> is specified 
then the copy will go on until a hex 0 is encountered or until the 
end of the destination buffer whichever comes first. The no <MI>val<D> 
technique is used to copy strings. The example length parameters in 
the description of the APP command are the same as for this command.

@OUTDENT ITEM = Note:The buffer must have memory allocated to it already. 
Use the ALLST command if you need to allocate memory for the string 
as well as copy it.

Errors:

@ERROR ITEM = 69 Length pointer [?????] must point into the memory 
buffer

@ERROR ITEM = 74 At least 2 parameter(s) required for this command

@ERROR ITEM = 77 Buffer pointer [?????] must have memory allocated 
to it

@ERROR ITEM = 82 Length Parameter [?????] cannot be a file or label

@ERROR ITEM = 85 Parameter [?????] should be a string constant or 
pointer

@COMMAND = Command:

@COMMAND ITEM = DEC

@DESCRIPT = Purpose:

@DES ITEM = Decrements either a scalar or a pointer variable.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = dec <MI>val<D>

@DESCRIPT = Argument:

@DES ITEM = Scalar or pointer to decrement (cannot be db)

This command will reduce the value of a scalar (I0-I9,BL,DB[5],etc.) 
by one. It will also decrement the value of a pointer variable. This 
will cause the pointer to point one character earlier in the buffer.

Error:

@ERROR ITEM = 83 Parameter [?????] should be a pointer or scalar variable

@COMMAND = Command:

@COMMAND ITEM = DEL (also ER)

@DESCRIPT = Purpose:

@DES ITEM = Deletes one or more files

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = del <MI>spec<D>

@DESCRIPT = Argument:

@DES ITEM = File specification which can include a path and/or wildcards

This command will delete any files indicated by the file specification. 
A path can be included and it will not generate a <169>Are you sure<170> 
message if <169>*.*<170> is used. Thus, <169>del *.*<170> can be used 
in script mode without user intervention. This is identical to the 
ER command.

Errors:

@ERROR ITEM = 5 Unable to delete file [?????]

@ERROR ITEM = 86 This command requires 1 parameter(s)

@ERROR ITEM = 89 Parameter [?????] should be a filename or file specification

@COMMAND = Command:

@COMMAND ITEM = DIR (also LD)

@DESCRIPT = Purpose:

@DES ITEM = Displays a wide format directory

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = dir <MI>spec<D>

@DESCRIPT = Argument:

@DES ITEM = File specification which can include a path and/or wildcards

This is just like the DOS dir /w command. Any valid DOS path and wildcards 
can be used.

Errors:

@ERROR ITEM = 89 Parameter [?????] should be a filename or file specification

@COMMAND = Command:

@COMMAND ITEM = DL

@DESCRIPT = Purpose:

@DES ITEM = Dials a number that is in a string or <MI>file<D>.

@DESCRIPT = Restrictions:

@DES ITEM = The modem cannot be online

@DESCRIPT = Syntax:

@DES ITEM = dl string or <MI>file<D>

@DESCRIPT = Argument:

@DES ITEM = If a string, then the number in the string is dialed

@DES EXT = If a <MI>file<D> then a number is read from the <MI>file<D> 
and is dialed

This dials a number out of a <MI>file<D> or in a string.

Errors:

@ERROR ITEM = 2 Unable to open file [?????]

@ERROR ITEM = 4 Received busy signal

@ERROR ITEM = 7 This command cannot be performed while online

@ERROR ITEM = 11 The modem was unable to train

@ERROR ITEM = 19 No tone detected

@ERROR ITEM = 61 Error in phone number

@ERROR ITEM = 86 This command requires 1 parameter(s)

@ERROR ITEM = 98 The filename cannot include wildcards 104 Parameter 
[?????] must be a string of filename

@COMMAND = Command:

@COMMAND ITEM = DN

@DESCRIPT = Purpose:

@DES ITEM = Defines the <MI>file<D> and options to be used for the 
punch.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = dn,<MI>file<D>[,<MI>ops<D>]

@DESCRIPT = Argument 1:

@DES ITEM = The filename to which punch data will be written

@DESCRIPT = 2:

@DES ITEM = If none, defaults used for naming and buffer types

@DES EXT = If a string, the characters will set the options

The define punch specifies the filename to which punch data will be 
written. There are several special filenames:

@Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), COLWIDTHS(E1,E3), HGUTTER(.0560), 
VGUTTER(.0560), BOX(Z_DOUBLE), HGRID(Z_SINGLE), VGRID(Z_SINGLE), KEEP(ON), 
L2(R1C0..R1C2)

@Z_TBL_BODY = TABLE TEXT, TABLE TEXT

Name<$!B11>, Description<$!B11>

CON, This writes data to the screen (supported)

NUL, This throws away incoming data (supported)

PRN, This writes data to the default printer (parallel port).

LPT1 and LPT2, Similar to PRN except the port is specified.

AUX, This refers to the first serial port (COM1) (not supported).

COM1 and COM2, These send data out the serial port (not supported)

@Z_TBL_END = 

The options that go with the the dn command are used to set the types 
of buffer conversions and to enable or disable auto-naming. The four 
types of buffer conversions are the same ones as described in Section 
<$R[S*,Vary]2.2>. The auto-naming option determines whether files 
will be concatenated if multiple files are received between DN definitions 
or whether new files will be created by creating by incrementing a 
numeric extension. The options consist of a series of characters, 
each of which has special meaning. There are two forms of options 
for this command the (shorter) normal ones and the more extensive 
form which can set the options in more possible ways. The normal options 
are:

@Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), COLWIDTHS(E1,E3), HGUTTER(.0560), 
VGUTTER(.0560), BOX(Z_DOUBLE), HGRID(Z_SINGLE), VGRID(Z_SINGLE), KEEP(OFF), 
L2(R1C0..R1C2)

@Z_TBL_BODY = TABLE TEXT, TABLE TEXT

Option<$!B11>, Description<$!B11>

S, To set the standard mode to the <MI>Vary<D> buffer type

T, To set the transparent mode to the <MI>Fixed<D> buffer type

B, To set the transparent mode to the <MI>Binary<D> buffer type

C, To turn auto-naming off (Concatenate)

N, To turn auto-naming on

H, To set both standard and transparent to the <MI>Hex<D> buffer type

V, To set both standard and transparent to the <MI>Vary <D>buffer 
type

F, To set both standard and transparent to the <MI>Fixed<D> buffer 
type

@Z_TBL_END = 

Examples:

@EXAMPLES = dn file.txt,s

Specifies standard with vary buffer type expected. 

@EXAMPLES = dn file.txt,tc

Specifies transparent with fixed buffer type expected and disables 
auto-naming.

@EXAMPLES = dn file.txt,nb

Specifies transparent with binary buffer type expected and enables 
auto-naming.

@OUTDENT ITEM = Note:The order of the options is not important when 
using the short form.

The long form uses the <169>S<170> and <169>T<170> followed by either 
<169>V<170>, <169>F<170>, <169>B<170> or <169>H<170> to indicate precisely 
the buffer type and the mode in which it is used.

For example:

@EXAMPLES = dn file.txt,sftb

Specifies that fixed format be assumed for standard receptions and 
that binary format be assumed for transparent receptions.

@EXAMPLES = dn file.txt,nshtf

Specifies auto-naming and that the hex buffer type be used for standard 
receptions and that the fixed format be used for transparent receptions.

In general the <169>V<170>, <169>F<170>, <169>B<170> and <169>H<170> 
options will refer to the reception type of the nearest <169>S<170> 
or <169>T<170> to its left (usually the preceding character). The 
<169>N<170> and <169>C<170> options can be placed anywhere; their 
locations are not important.

Errors:

@ERROR ITEM = 80 Parameter [?????] must be a filename

@ERROR ITEM = 94 Label not allowed in parameter [?????]

@ERROR ITEM = 98 The filename cannot include wildcards 101 The option 
[????] is not valid

@COMMAND = Command:

@COMMAND ITEM = DP

@DESCRIPT = Purpose:

@DES ITEM = Defines the <MI>file<D> and options to be used for the 
printer.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = dp,<MI>file<D>[,<MI>ops<D>]

@DESCRIPT = Argument 1:

@DES ITEM = The filename to which printer data will be written

@DESCRIPT = 2:

@DES ITEM = If none, default naming and buffer types If a string, 
the characters will set the options

Same as punch (above) except for printer.

@COMMAND = Command:

@COMMAND ITEM = DS

@DESCRIPT = Purpose:

@DES ITEM = Disconnects the line in an orderly fashion.

@DESCRIPT = Restrictions:

@DES ITEM = The modem must be online

@DESCRIPT = Syntax:

@DES ITEM = ds

This command sends a message to the remote 3780 that it is going to 
disconnect and then drops the line. The disconnect is automatically 
performed if you exit with the Q command. If you cannot send the disconnect 
message to the remote then the line can be dropped with the FQ command.

Errors:

@ERROR ITEM = 6 This command cannot be performed unless online

@ERROR ITEM = 15 The modem is not able to transmit, It will not raise 
CTS

@ERROR ITEM = 18 The modem is not able to transmit, SCC TX buffer 
error

@COMMAND = Command:

@COMMAND ITEM = DSUP

@DESCRIPT = Purpose:

@DES ITEM = Suppresses direct video output

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = dsup

Suppresses all direct video writes. This includes:

@LIST = 1. All status variables

@LIST = 2. The screen (after a redsp)

@LIST = 3. DRITE writes

@COMMAND = Command:

@COMMAND ITEM = DT

@DESCRIPT = Purpose:

@DES ITEM = Dumps the contents of a trace buffer to the disk.

@DESCRIPT = Restrictions:

@DES ITEM = Not supported yet

@DESCRIPT = Syntax:

@DES ITEM = dt,<MI>file<D>

@DESCRIPT = Argument:

@DES ITEM = File to dump trace to

This command is used in conjunction with the tr command to capture 
and write a hex dump of the line activity to the disk. It is not supported 
yet but will be soon. No errors are generated yet.

@COMMAND = Command:

@COMMAND ITEM = END

@DESCRIPT = Purpose:

@DES ITEM = Terminate processing of the current script file.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = end

This command is used to prematurely return from a script file. It 
differs from the EX command in that control will return to the calling 
script file and <$R[V*,Packname]D3-3780> will continue. EX will terminate 
<$R[V*,Packname]D3-3780>. This command is identical to <$R[V*,Packname]D3-3780> 
reaching the end of a script file. No errors are possible with this 
command.

@COMMAND = Command:

@COMMAND ITEM = ENZ

@DESCRIPT = Purpose:

@DES ITEM = Conditionally exiting the package without dropping the 
line.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = enz

If there was an error on the prior command then this will exit <$R[V*,Packname]D3-3780> 
with the DOS errorlevel set to the same value as the <$R[V*,Packname]D3-3780> 
error. If online, the line will remain active. No possible errors 
with this command.

@COMMAND = Command:

@COMMAND ITEM = ER (or DEL)

@DESCRIPT = Purpose:

@DES ITEM = Deletes one or more files

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = er <MI>spec<D>

@DESCRIPT = Argument:

@DES ITEM = File specification which can include a path and/or wildcards

Identical to the DEL command above.

@COMMAND = Command:

@COMMAND ITEM = EX

@DESCRIPT = Purpose:

@DES ITEM = Exit to DOS without dropping line. Optionally, set errorlevel.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = ex[,errorlevel]

@DESCRIPT = Argument:

@DES ITEM = If none, errorlevel is 0

@DES EXT = If a scalar, the errorlevel is its value

This command will exit <$R[V*,Packname]D3-3780> without breaking the 
connection with the other 3780. If a value is specified the DOS errorlevel 
will be set to that value. Otherwise, the errorlevel will be 0.

Errors:

@ERROR ITEM = 70 The value [?????] of parameter 1 is too big, maximum 
allowed is 255

@ERROR ITEM = 71 The value [?????] of parameter 1 is too small, minimum 
allowed is 0

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@COMMAND = Command:

@COMMAND ITEM = FREE

@DESCRIPT = Purpose:

@DES ITEM = Give back memory that is no longer needed.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = free <MI>ptr<D>

@DESCRIPT = Argument:

@DES ITEM = A pointer to memory that was allocated with ALLST or ALLOC.

@COMMAND = Command:

@COMMAND ITEM = FQ

@DESCRIPT = Purpose:

@DES ITEM = Drop the line and go to DOS without hesitation.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = fq

This command will leave drop the line without informing the other 
3780 that it is about to do so and will then exit to DOS. No errors 
are possible.

@COMMAND = Command:

@COMMAND ITEM = FRITE

@DESCRIPT = Purpose:

@DES ITEM = Format and write data to an open file.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = frite <MI>han<D>,<MI>val<D>[;<MI>ops<D>][+<MI>val<D>[;<MI>ops<D>]]...

@DESCRIPT = Argument <MI>han<D>:

@DES ITEM = The handle of the file to write to

@DESCRIPT = <MI>val<D>:

@DES ITEM = If a scalar, the value is written out

@DES EXT = If a string, the string is written out

@DESCRIPT = <MI>ops<D>:

@DES ITEM = If none, default display format

@DES EXT = If string, characters determine format

The FRITE command allows the script programmer to write strings and 
variable values out to the disk. The first option is the file handle 
and the parameters following are the same as those for the RITE command 
as described in Section <$R[S*,Formops]6.8>.

Errors:

@ERROR ITEM = 20 The file specified by handle [?????] is not open

@ERROR ITEM = 70 The value [?????] of parameter 1 is too big, maximum 
allowed is 9

@ERROR ITEM = 71 The value [?????] of parameter 1 is too small, minimum 
allowed is 0

@ERROR ITEM = 74 At least 2 parameter(s) required for this command

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@ERROR ITEM = 90 Parameter [?????] should be a pointer or scalar

@ERROR ITEM = 94 Label not allowed in parameter [?????]

@COMMAND = Command:

@COMMAND ITEM = FSTAT

@DESCRIPT = Purpose:

@DES ITEM = Displays information on an open file

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = fstat handle

@DESCRIPT = Argument:

@DES ITEM = The handle of the file to use

This option is useful to display size, time and date information on 
a file and to check if a handle is in use. If you call fstat on a 
handle that does not have a file associated with it then it will generate 
an error. The IF command can then be used to branch based on that 
error.

Example:

@EXAMPLES = ?open 0,<$R[V*,Packname]D3-3780>.exe

@EXAMPLES = File "<$R[V*,Packname]D3-3780>.EXE" opened in "R" mode.

@EXAMPLES = ?fstat 0

@EXAMPLES = Size is 75804 bytes, Time stamp is Tue May 23 13:14:02 
1989

Errors:

@ERROR ITEM = 20 The file specified by handle [?????] is not open

@ERROR ITEM = 70 The value [?????] of parameter 1 is too big, maximum 
allowed is 9 

@ERROR ITEM = 71 The value [?????] of parameter 1 is too small, minimum 
allowed is 0 

@ERROR ITEM = 86 This command requires 1 parameter(s)

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@COMMAND = Command:

@COMMAND ITEM = GBUF

@DESCRIPT = Purpose:

@DES ITEM = Get data from file and put it into a buffer.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = gbuf handle,<MI>buf<D>[,<MI>val<D>]

@DESCRIPT = Argument 1:

@DES ITEM = The handle of the file to use

@DESCRIPT = 2:

@DES ITEM = A pointer to the location where the data will be copied

@DESCRIPT = 3:

@DES ITEM = If None, reads until end of destination buffer

@DES EXT = If a scalar then the value is the number of bytes to read

@DES EXT = If a pointer then the value will be the upper bound

The GBUF command is used to read data from a file. The <MI>buf<D> 
value is the location of the buffer in which to read the data. The 
optional <MI>val<D> is the length parameter as described in Section 
<$R[S*,Copcmds]6.4>. This command does not look for a hex 0 in the 
source string to stop copying. It will read until the end of the source 
file or fill the entire destination buffer if the [,<MI>val<D>] parameter 
is not included.

The <MI>buf<D> parameter can also be an integer or in individual character 
in a buffer. If <MI>buf<D> is an integer or character then a value 
will be read from the file and assigned to the scalar. The <MI>val<D> 
parameter is irrelevant in this case since one character is read for 
character types and two for integers.

Errors:

@ERROR ITEM = 20 The file specified by handle [?????] is not open

@ERROR ITEM = 21 At end of file [?????], can't read anymore

@ERROR ITEM = 69 Length pointer [?????] must point into the memory 
buffer

@ERROR ITEM = 70 The value [?????] of parameter 1 is too big, maximum 
allowed is 9

@ERROR ITEM = 71 The value [?????] of parameter 1 is too small, minimum 
allowed is 0

@ERROR ITEM = 74 At least 2 parameter(s) required for this command

@ERROR ITEM = 76 The parameter [?????] cannot be assigned to

@ERROR ITEM = 77 Buffer pointer [?????] must have memory allocated 
to it

@ERROR ITEM = 82 Length Parameter [?????] cannot be a file or label

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@ERROR ITEM = 90 Parameter [?????] should be a pointer or scalar

@COMMAND = Command:

@COMMAND ITEM = GETXT

@DESCRIPT = Purpose:

@DES ITEM = Saves a portion of the screen in a dynamically allocated 
buffer

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = getxt <MI>ptr<D>,roupper,colupper,rolower,collower

@DESCRIPT = Argument 1:

@DES ITEM = A pointer which will point to the stored screen

@DESCRIPT = 2:

@DES ITEM = The highest row to be stored

@DESCRIPT = 3:

@DES ITEM = The leftmost column to be stored

@DESCRIPT = 4:

@DES ITEM = The lowest row to be stored

@DESCRIPT = 5:

@DES ITEM = The rightmost column to be stored

The rows and columns are numbered starting at 1,1 in the upper left 
corner. This command will dynamically allocate the memory to store 
the prior screen. The amount of memory required to store the screen 
will vary since data compression is used. The length averages about 
1000 bytes. The '!' sign can be used to determine the amount of memory 
actually used.

@COMMAND = Command:

@COMMAND ITEM = GO

@DESCRIPT = Purpose:

@DES ITEM = Resume execution somewhere else in the script file

@DESCRIPT = Restrictions:

@DES ITEM = Script only

@DESCRIPT = Syntax:

@DES ITEM = go <MI>dest<D>

@DESCRIPT = Argument:

@DES ITEM = The label or line number to branch to

This is a simple branching instruction. It will take either a label 
or a line number. It also will take the letter <169>Q<170> to exit. 
This is not very useful in this instruction since a <169>Q<170> by 
itself would have the same effect.

Errors:

@ERROR ITEM = 58 Label [?????] not found

@ERROR ITEM = 59 Line number ??,[??] exceeds script file length

@ERROR ITEM = 67 This command is only allowed in script mode

@ERROR ITEM = 68 Script file read error

@ERROR ITEM = 78 The destination parameter [?????] cannot be a filename

@COMMAND = Command:

@COMMAND ITEM = HELP[,command]

@DESCRIPT = Purpose:

@DES ITEM = Same as <169>?<170>

@DESCRIPT = Restrictions:

@DES ITEM = None

@COMMAND = Command:

@COMMAND ITEM = IF

@DESCRIPT = Purpose:

@DES ITEM = Conditionally, resume execution somewhere else

@DESCRIPT = Restrictions:

@DES ITEM = Script only

@DESCRIPT = Syntax:

@DES ITEM = if errdest,noterrdest

@DESCRIPT = Argument 1:

@DES ITEM = If none, drop through on error

@DES EXT = If label or line number, branch on error

@DESCRIPT = 2:

@DES ITEM = If none, drop through on no error

@DES EXT = If label or line number, branch on no error

This can be read as if (error) then go to <MI>dest<D> else go to noterrdest. 
The first branch will be executed if the prior instruction resulted 
in an error. If the second branch exists a non-error will cause it 
to be traversed. If the second branch does not exist then the next 
line in the script file will be executed. In all the branching instructions, 
a blank branch indicates go to the next line for execution. This instruction 
is the only instruction which is affected by the IL command. The IL 
command is used to limit the number of times a negative branch is 
executed. A complete explanation will be given with that command.

@OUTDENT ITEM = Note:The prior instruction is meant literally here. 
An intervening comment will reset the error value. If you want to 
have intervening commands then save the EI value in an I0-I9 variable 
and branch off it later.

Same errors as GO command above plus:

@ERROR ITEM = 13 Loopcount expired

@COMMAND = Command:

@COMMAND ITEM = IFE

@DESCRIPT = Purpose:

@DES ITEM = Check for existence of file

@DESCRIPT = Restrictions:

@DES ITEM = Script only

@DESCRIPT = Syntax:

@DES ITEM = ife <MI>spec<D>,existdest,notexistdest

@DESCRIPT = Argument 1:

@DES ITEM = Filename which can contain a path and wildcards

@DESCRIPT = 2:

@DES ITEM = If none, drop through if file exists 

@DES EXT = If label or line number, branch if file exists

@DESCRIPT = 3:

@DES ITEM = If none, drop through if file doesn't exist 

@DES EXT = If label or line number, branch if file doesn't exist

This would read <169>if <MI>spec<D> exists then go to existdest else 
go to notexistdest<170>. The <MI>spec<D> can contain wildcards and 
a pathname.

Same errors as GO command above plus:

@ERROR ITEM = 74 At least 1 parameter(s) required for this command

@ERROR ITEM = 89 Parameter [?????] should be a filename or file specification

@COMMAND = Command:

@COMMAND ITEM = IFEF

@DESCRIPT = Purpose:

@DES ITEM = Check for end of file condition

@DESCRIPT = Restrictions:

@DES ITEM = Script only

@DESCRIPT = Syntax:

@DES ITEM = ifef handle,eofdest,noteofdest

@DESCRIPT = Argument 1:

@DES ITEM = The handle of the file to check for end of file

@DESCRIPT = 2:

@DES ITEM = If none, drop through if end of file 

@DES EXT = If label or line number, branch if end of file

@DESCRIPT = 3:

@DES ITEM = If none, drop through if not end of file

@DES EXT = If label or line number, branch if not end of file

This would read <169>if at the end of file handle then go to <MI>eofdest<D> 
else go to noteofdest<170>. When file input/output is performed on 
files using handles then a file pointer is maintained by the system. 
This file pointer tells the system where to read from or write to. 
The <169>end of file<170> condition is when that file pointer is at 
the end of the file. Thus, when reading a file the <169>end of file<170> 
condition means that there is no more file to be read. If the file 
has not been opened then eofdest will be branched to.

Same errors as GO command above plus:

@ERROR ITEM = 70 The value [?????] of parameter 1 is too big, maximum 
allowed is 9

@ERROR ITEM = 71 The value [?????] of parameter 1 is too small, minimum 
allowed is 0

@ERROR ITEM = 74 At least 2 parameter(s) required for this command

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@COMMAND = Command:

@COMMAND ITEM = IFI

@DESCRIPT = Purpose:

@DES ITEM = Check for two strings or scalars being identical

@DESCRIPT = Restrictions:

@DES ITEM = Script only

@DESCRIPT = Syntax:

@DES ITEM = ifi lval=rval,equdest,diffdest

@DESCRIPT = Arguments 1&2:

@DES ITEM = The values to be compared

@DESCRIPT = 3:

@DES ITEM = If none, drop through if identical

@DES EXT = If label or line number, branch if identical

@DESCRIPT = 4:

@DES ITEM = If none, drop through if not identical

@DES EXT = If label or line number, branch if not identical

This would read <169>if lval is identical to rval then go to equdest 
else go to diffdest<170>. If lval and rval are pointers then a string 
compare is performed. If lval and rval are scalars then the values 
are compared.

Same errors as GO command above plus:

@ERROR ITEM = 74 At least 3 parameter(s) required for this command

@ERROR ITEM = 95 Pointer and scalar operands cannot both be present 
in this command

@COMMAND = Command:

@COMMAND ITEM = IFO

@DESCRIPT = Purpose:

@DES ITEM = Check if online

@DESCRIPT = Restrictions:

@DES ITEM = Script only

@DESCRIPT = Syntax:

@DES ITEM = ifo onlinedest,offlinedest

@DESCRIPT = Argument 1:

@DES ITEM = If none, drop through if online

@DES EXT = If label or line number, branch if online

@DESCRIPT = 2:

@DES ITEM = If none, drop through if offline

@DES EXT = If label or line number, branch if offline

This is simple check to determine if the modem is online. This is 
useful after W commands to determine whether or not the line has been 
dropped. It may also be useful after an auto-answer. Same errors as 
GO command above.

@COMMAND = Command:

@COMMAND ITEM = IFP

@DESCRIPT = Purpose:

@DES ITEM = Check the type of the last reception

@DESCRIPT = Restrictions:

@DES ITEM = Script only

@DESCRIPT = Syntax:

@DES ITEM = ifp errdest,prindest,punchdest

@DESCRIPT = Argument 1:

@DES ITEM = If none, drop through if error

@DES EXT = If label or line number, branch if error

@DESCRIPT = 2:

@DES ITEM = If none, drop through if last receive was to printer

@DES EXT = If label or line number, branch if last receive was to 
printer

@DESCRIPT = 3:

@DES ITEM = If none, drop through if last receive was to punch

@DES EXT = If label or line number, branch if last receive was to 
punch

This would read <169>If an error during reception go to errdest else 
if last reception was to the printer go to prindest else go to punchdest<170>. 
The error branch is only in reference to the command immediately preceding 
the IFP command but the other two branches will go back to the last 
W command that was executed. The RT variable can be useful for similar 
for similar branching operations. Same errors as GO command.

@COMMAND = Command:

@COMMAND ITEM = IFS

@DESCRIPT = Purpose:

@DES ITEM = Compare two strings up until the end of the leftmost string

@DESCRIPT = Restrictions:

@DES ITEM = Script only

@DESCRIPT = Syntax:

@DES ITEM = ifs lstr=rstr,equadest,diffdest

@DESCRIPT = Argument 1&2:

@DES ITEM = The strings to be compared, comparison is to end of left 
string

@DESCRIPT = 3:

@DES ITEM = If none, drop through if a match

@DES EXT = If label or line number, branch if a match

@DESCRIPT = 4:

@DES ITEM = If none, drop through if not a match

@DES EXT = If label or line number, branch if not a match

This command is useful for checking the start of a string for a match. 
If a long string is stored in a buffer then the value on the left 
can be a short version which is large enough to distinguish it from 
the other possibilities. This compare is case insensitive. If the 
righthand string is shorter than the lefthand string then they obviously 
do not match.

Same errors as GO command above plus:

@ERROR ITEM = 74 At least 3 parameter(s) required for this command

@ERROR ITEM = 85 Parameter [?????] should be a string constant or 
pointer

@ERROR ITEM = 95 Pointer and scalar operands cannot both be present 
in this command

@COMMAND = Command:

@COMMAND ITEM = IFT

@DESCRIPT = Purpose:

@DES ITEM = Compare time stamps of files

@DESCRIPT = Restrictions:

@DES ITEM = Script only

@DESCRIPT = Syntax:

@DES ITEM = ift lfile=rfile,equadest,lfilenewerdest,rfilenewerdest

@DESCRIPT = Argument 1&2:

@DES ITEM = The files to be compared

@DESCRIPT = 3:

@DES ITEM = If none, drop through if a match

@DES EXT = If label or line number, branch if a match

@DESCRIPT = 4:

@DES ITEM = If none, drop through if lfile is newer than rfile

@DES EXT = If label or line number, branch if lfile is newer than 
rfile

@DESCRIPT = 5:

@DES ITEM = If none, drop through if rfile is newer than lfile

@DES EXT = If label or line number, branch if rfile is newer than 
lfile

This command is for comparing the timestamps of files. If one (or 
both) of the files does not exist then it will drop through.

Same errors as GO command above plus:

@ERROR ITEM = 2 Unable to open file [?????]

@ERROR ITEM = 74 At least 3 parameter(s) required for this command

@ERROR ITEM = 80 Parameter [??????] must be a filename

@ERROR ITEM = 98 The filename cannot include wildcards

@COMMAND = Command:

@COMMAND ITEM = IL

@DESCRIPT = Purpose:

@DES ITEM = Set a negative branch limit for the IF command

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = il loopcount

@DESCRIPT = Argument:

@DES ITEM = The maximum number of times to execute the negative branch 
of an IF command

This command was mainly offered to reduce the pain that users converting 
from BSC will experience. The IF command is the only one which checks 
this value. If you set a value with IL then its value will be decremented 
each time the negative branch of an IF is executed. On the count which 
reaches 0 the IF will drop through rather than branch.

Errors:

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@COMMAND = Command:

@COMMAND ITEM = INC

@DESCRIPT = Purpose:

@DES ITEM = Increment a scalar or pointer

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = inc <MI>val<D>

@DESCRIPT = Argument:

@DES ITEM = The scalar or pointer to be incremented

This command simply increments a scalar or pointer. Incrementing a 
pointer will simply make it point to the next (to the right) character 
in the buffer.

Error:

@ERROR ITEM = 83 Parameter [?????] should be a pointer or scalar variable

@COMMAND = Command:

@COMMAND ITEM = INTRP

@DESCRIPT = Purpose:

@DES ITEM = Interpret a string as if it were a command

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = intrp str

@DESCRIPT = Argument:

@DES ITEM = The string to be interpreted.

This command takes the value in a string and processes it as the command. 
This can be used in a subroutine to get the effect of passing a pointer 
to a command. The calling function can load a command into a predefined 
buffer and the subroutine can use INTRP to execute the command.

Another use of this command is to interpret commands that are created 
in a buffer. This be can useful for the two DOS shell commands. The 
DOS shell commands take there Arguments literally (%I0, %P0, etc. 
are not converted to their equivalent values). If you want to use 
internal variables on the command line of one of these commands you 
can create a command with the SRITE command and then process it with 
INTRP.

Example:

@EXAMPLES = srite %db,"/copy file.jnk file2."+%i0;03d

@EXAMPLES = intrp %db

This would copy the file <169>FILE.JNK<170> to a file with <169>FILE2<170> 
primary and the number in %I0 for the extension.

Errors:

@ERROR ITEM = 85 Parameter [?????] should be a string constant or 
pointer + The errors that the command can generate

@COMMAND = Command:

@COMMAND ITEM = KEY

@DESCRIPT = Purpose:

@DES ITEM = Display a string and then get a key from user

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = key <MI>num<D>[;op],<MI>val<D>[;<MI>ops<D>][+<MI>val<D>[;<MI>ops<D>]]...

@DESCRIPT = Argument <MI>num<D>:

@DES ITEM = An integer or character variable which will be assigned 
a key

@DESCRIPT = op:

@DES ITEM = If op is a <169>c<170>, <MI>num<D> is assigned a character 
else an integer

@DESCRIPT = <MI>val<D>:

@DES ITEM = If a scalar, the value is written out

@DES EXT = If a string, the string is written out

@DESCRIPT = <MI>ops<D>:

@DES ITEM = If none, default display format

@DES EXT = If string, characters determine format

This command is used to construct interactive script files. The <MI>num<D> 
Argument receives the result of a stroke from the keyboard. A keystroke 
result consists of 2 things; the character the key generated and the 
scan code of the key. If the <MI>num<D> is an integer (I0-I9) then 
the high byte will be the scan code and the low byte will be the character. 
The scan code is required to check for special keys (function keys, 
arrow keys, etc.). The high byte being non-zero will cause comparisons 
to character constants ('A', 'B','C',etc.) to fail. Set the value 
of <169>op<170> to <169>c<170> if you are not trying to decode special 
keys. The other parameters are just like those to the rite command. 
They will display on the screen prior to the retrieving of a key.

Errors:

@ERROR ITEM = 88 The parameter [?????] cannot be assigned a scalar

@ERROR ITEM = 90 Parameter [?????] should be a pointer or scalar

@ERROR ITEM = 94 Label not allowed in parameter [?????]

@ERROR ITEM = 94 100 Optional parameter must be 'C' or nonexistent

@COMMAND = Command:

@COMMAND ITEM = KL

@DESCRIPT = Purpose:

@DES ITEM = Stop current activity

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = kl

The KL command is used to terminate a send, receive or auto-answer 
before it is complete.

Error:

@ERROR ITEM = 8 No process in progress to kill

@COMMAND = Command:

@COMMAND ITEM = LD (also DIR)

@DESCRIPT = Purpose:

@DES ITEM = Does a wide format directory

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = ld <MI>spec<D>

@DESCRIPT = Argument:

@DES ITEM = File specification which can include a path and/or wildcards

Same as DIR above.

@COMMAND = Command:

@COMMAND ITEM = LF

@DESCRIPT = Purpose:

@DES ITEM = Causes record of screen I/O to be echoed to disk

@DESCRIPT = Restrictions:

@DES ITEM = Script only

@DESCRIPT = Syntax:

@DES ITEM = lf <MI>file<D>

@DESCRIPT = Argument:

@DES ITEM = File name to be used for record or NUL to disable listing 
file

The list file command causes the commands and other values which are 
displayed in the command window to be written to disk also. This does 
not stop the information from displaying on the screen also (use SUP 
for that). If the file already exists the LF command will cause the 
additional data to be appended to it.

Errors:

@ERROR ITEM = 2 Unable to open file [?????]

@ERROR ITEM = 80 Parameter [??????] must be a filename

@ERROR ITEM = 98 The filename cannot include wildcards

@COMMAND = Command:

@COMMAND ITEM = LOAD

@DESCRIPT = Purpose:

@DES ITEM = loads buffer pointed to by <MI>ptr<D> from file named 
by file

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = load <MI>ptr<D>,<MI>file<D>[,<MI>val<D>]

@DESCRIPT = Argument 1:

@DES ITEM = A pointer to a buffer (to write into)

@DESCRIPT = 2:

@DES ITEM = filename to read from

@DESCRIPT = 3:

@DES ITEM = if None, the length of the <MI>ptr<D>

@DES EXT = if a scalar then the value is the number of bytes to write 


@DES EXT = if a pointer then the value will be the upper bound

This is a quick and dirty load buffer command. It saves the hassle 
of having to opening and closing a file in order to read it. The length 
determination is similar to the other commands as discussed in Section 
<$R[S*,Copcmds]6.4>.

The <MI>ptr<D> parameter can also be an integer. If <MI>ptr<D> is 
an integer then ASCII equivalent value will be read from the file 
and assigned it. That is, the if the file contains the string <169>99<170> 
the value 99 will be assigned the integer. 

The <MI>ptr<D> parameter can also be an individual character. If this 
is the case then the first character in the file is read into it.

The <MI>val<D> parameter is irrelevant if <MI>ptr<D> is not a scalar 
type.

Errors:

@ERROR ITEM = 2 Unable to open file [?????]

@ERROR ITEM = 69 Length pointer [?????] must point into the memory 
buffer

@ERROR ITEM = 76 The parameter [?????] cannot be assigned to

@ERROR ITEM = 77 Buffer pointer [?????] must have memory allocated 
to it

@ERROR ITEM = 80 Parameter [??????] must be a filename

@ERROR ITEM = 82 Length Parameter [?????] cannot be a file or label

@ERROR ITEM = 90 Parameter [?????] should be a pointer or scalar

@ERROR ITEM = 98 The filename cannot include wildcards

@COMMAND = Command:

@COMMAND ITEM = LSCRN

@DESCRIPT = Purpose:

@DES ITEM = Loads direct memory screen from disk

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = lscrn file

@DESCRIPT = Argument:

@DES ITEM = File which contains a direct write screen

@COMMAND = Command:

@COMMAND ITEM = LSTVS

@DESCRIPT = Purpose:

@DES ITEM = To load the status variable format strings

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = lstvs <MI>val<D>

@DESCRIPT = Argument:

@DES ITEM = If a filename then the file contains the format strings 
If a label then the label is the location in the file of the format 
strings.

@COMMAND = Command:

@COMMAND ITEM = LWR

@DESCRIPT = Purpose:

@DES ITEM = Makes a string or scalar lowercase

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = lwr <MI>val<D>

@DESCRIPT = Argument:

@DES ITEM = If a string the whole string will be made lowercase If 
an integer or character just the character will be made lowercase

This command is just like is sounds. Characters that are non-alphabetic 
or already are lower case are not affected.

Error:

@ERROR ITEM = 76 The parameter [?????] cannot be assigned to

@COMMAND = Command:

@COMMAND ITEM = M

@DESCRIPT = Purpose:

@DES ITEM = Allows a manual connect to be performed

@DESCRIPT = Restrictions:

@DES ITEM = The modem cannot be online

@DESCRIPT = Syntax:

@DES ITEM = m

This command is used when you want to manually connect with the remote 
modem and then switch the local modem online. It is mainly useful 
for diagnostic purposes when having trouble auto-dialing. Manually 
connecting is a three part process:

@LIST = 1. Enter the M command

@LIST = 2. Dial the required number and listen for answer back tone

@LIST = 3. Before the tone has stopped press the <169>Enter<170> key

Errors:

@ERROR ITEM = 7 This command cannot be performed while online

@ERROR ITEM = 11 The modem was unable to train

@COMMAND = Command:

@COMMAND ITEM = MO

@DESCRIPT = Purpose:

@DES ITEM = Gets and displays the modem's options

@DESCRIPT = Restrictions:

@DES ITEM = The modem cannot be online

@DESCRIPT = Syntax:

@DES ITEM = mo

This command is also primarily diagnostic. It performs a query of 
the modem asking it to return the values of the options. Since these 
options are in hex they are not very useful. If the modems data file 
is available this command will be made to display the names for the 
values. I have not implemented this feature yet

Errors:

@ERROR ITEM = 7 This command cannot be performed while online

@ERROR ITEM = 15 The modem is not able to transmit, It will not raise 
CTS

@ERROR ITEM = 18 The modem is not able to transmit, SCC TX buffer 
error

@ERROR ITEM = 75 Error interfacing modem [?????]

@COMMAND = Command:

@COMMAND ITEM = MOME

@DESCRIPT = Purpose:

@DES ITEM = Sends and optionally receives a message from the modem

@DESCRIPT = Restrictions:

@DES ITEM = The modem cannot be online

@DESCRIPT = Syntax:

@DES ITEM = mome str[;op]

@DESCRIPT = Argument 1:

@DES ITEM = The string is a hex string for the modem to accept

@DESCRIPT = 2:

@DES ITEM = if op=N then no response is expected from the modem

@DES EXT = if op=S then multiple messages are expected

@DES EXT = if none then a single response is looked for

This command is another diagnostic command. It allows the properly 
informed user to run modem self test and do several other checks. 
More commands will be added later which use modem dependent information 
in the MODEMS.DTA.

Errors:

@ERROR ITEM = 7 This command cannot be performed while online

@ERROR ITEM = 15 The modem is not able to transmit, It will not raise 
CTS

@ERROR ITEM = 18 The modem is not able to transmit, SCC TX buffer 
error

@ERROR ITEM = 75 Error interfacing modem [?????]

@ERROR ITEM = 85 Parameter [?????] should be a string constant or 
pointer

@ERROR ITEM = 94 Label not allowed in parameter [?????]

@ERROR ITEM = 100 Optional parameter must be 'N','S' or nonexistent

@COMMAND = Command:

@COMMAND ITEM = MOV

@DESCRIPT = Purpose:

@DES ITEM = Assigns a value to a scalar or pointer

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = mov destval,sourceval

@DESCRIPT = Argument 1:

@DES ITEM = The scalar or pointer to receive a new value

@DESCRIPT = 2:

@DES ITEM = The scalar or pointer value to be assigned

This is a simple assignment command. It can be used to assign new 
values to array entries, integers or pointers.

Errors:

@ERROR ITEM = 83 Parameter [?????] should be a pointer or scalar variable

@ERROR ITEM = 86 This command requires 2 parameter(s)

@ERROR ITEM = 90 Parameter [?????] should be a pointer or scalar

@ERROR ITEM = 95 Pointer and scalar operands cannot both be present 
in this command

@COMMAND = Command:

@COMMAND ITEM = MSETH

@DESCRIPT = Purpose:

@DES ITEM = Assigns values for base address and interrupt level of 
modem

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = mseth base,intrupt

@DESCRIPT = Argument 1:

@DES ITEM = The base address of the modem (default is 300 hex)

@DESCRIPT = 2:

@DES ITEM = The intrupt value of the modem (default is 3)

@COMMAND = Command:

@COMMAND ITEM = MV

@DESCRIPT = Purpose:

@DES ITEM = Used to display the modem version

@DESCRIPT = Restrictions:

@DES ITEM = The modem cannot be online

@DESCRIPT = Syntax:

@DES ITEM = mv 

This command will send a version request to the modem and will display 
the four hex bytes which are returned. If the MODEMS.DTA file is available 
then it will also display the name of the modem. This command is primarily 
for checking modem ROM revisions when problems occur.

Errors:

@ERROR ITEM = 7 This command cannot be performed while online

@ERROR ITEM = 15 The modem is not able to transmit, It will not raise 
CTS

@ERROR ITEM = 18 The modem is not able to transmit, SCC TX buffer 
error

@ERROR ITEM = 75 Error interfacing modem [?????]

@COMMAND = Command:

@COMMAND ITEM = ON

@DESCRIPT = Purpose:

@DES ITEM = Multi way conditional branch statement

@DESCRIPT = Restrictions:

@DES ITEM = Script mode only

@DESCRIPT = Syntax:

@DES ITEM = on <MI>num<D>,lownum[;highnum][=dest],lownum[;highnum][=<MI>dest<D>],...

@DESCRIPT = Argument <MI>num<D>:

@DES ITEM = The value whose value is being compared against

@DESCRIPT = lownum:

@DES ITEM = The low number in the range check

@DESCRIPT = highnum:

@DES ITEM = The high number in the range check

@DES EXT = if blank then <MI>num<D> must equal lownum to execute the 
branch 

@DESCRIPT = <MI>dest<D>:

@DES ITEM = The label or line number to branch to

This statement conditionally causes execution to begin at one of a 
number of locations. The value <MI>num<D> is compared to each of the 
respective lownum;highnum pairs to determine if it is between or equal 
to either. If it is then the corresponding branch <MI>dest<D> is jumped 
to. If highnum is blank then an exact match with lownum is required. 
If <MI>dest<D> is blank and the value is in range then the on will 
drop through. If <MI>num<D> doesn't match any of the ranges then the 
on will drop through. This expression is scanned from left to right 
and the lownum;highnum sets can overlap or include one another. Generally 
the lower ranges would occur earlier and the higher later. However, 
the scanning order can be used to your advantage. If a large range 
is to be checked with a few exceptions, the exceptions can be eliminated 
by ranges which are checked earlier.

Example:

@EXAMPLES = on %ei,0=:onlinedest,4=:busydest,19=:notonedest,1;h7fff=errdest

The above example is a simple check which will branch to <169>onlinedest<170> 
if EI is 0, busydest if EI is 4, notonedest if EI is 19 and errdest 
otherwise.

The following example demonstrates how a few values can be excluded 
from a check of a larger range.

@EXAMPLES = on %i0,5,7,9,11,1;100=:errordest,101;h7fff=:baderrdest

If the value of %I0 is exactly 5, 7, 9 or 11 it will drop through 
because these arguments all have blank destination fields. The branching 
will also drop through if it is 0 or below. If %I0 is none of those 
but between (or equal to) 1 and 100 it will branch to errordest. If 
the value is above 100 then the script will branch to baderrdest.

Note:The highest possible value for an integer is h7fff. Also:The 
values lownum and highnum need not be constants. The can be any scalar 
type.

Errors:

@ERROR ITEM = 67 This command is only allowed in script mode

@ERROR ITEM = 74 At least 2 parameter(s) required for this command

@ERROR ITEM = 78 The destination parameter [?????] cannot be a filename

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@COMMAND = Command:

@COMMAND ITEM = OPEN

@DESCRIPT = Purpose:

@DES ITEM = open a file

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = open <MI>handle<D>,<MI>file<D>[;<MI>ops<D>]

@DESCRIPT = Argument 1:

@DES ITEM = The handle of the file to use

@DESCRIPT = 2:

@DES ITEM = The name of a file (can include path)

@DESCRIPT = 3:

@DES ITEM = An option string which determine how the file will be 
opened.

The open command is used to open a file so that the other handle based 
file commands can be used. The handle is merely a number 0-9. The 
filename can include a path and/or drive designation. The options 
consist of a string (quotes are optional) which contains option characters. 
I'll explain each character individually:

@OUTDENT ITEM = <169>R<170> Open file for reading. The file must exist 
or an error will be generated. Values cannot be written to this file 
unless the <169>P<170> option (below) is also selected.

@OUTDENT ITEM = <169>W<170> Open file for writing. If the file exists 
then its contents will be destroyed. If the <169>P<170> option is 
not selected then this file cannot be read from.

@OUTDENT ITEM = <169>A<170> Open file for appending. If the file exists 
then the data will be appended to it. If it doesn't exist then it 
will be created.

@OUTDENT ITEM = <169>P<170> <169>P<170>lus. Used in conjunction with 
<169>R<170> it allows the file to be written to also. If used in conjunction 
with <169>W<170> allows the file to be read from also. Allows both 
reading and writing when used with the <169>A<170> option but will 
still not allow the overwriting of original data (writes must be to 
the end of the file).

@OUTDENT ITEM = <169>B<170> <169>B<170>inary option. This is used 
if the file does not contain text. Normally, a carriage return-line 
feed pair is converted to a line feed when read in and vice versa 
when written out. This process is suppressed when the <169>B<170> 
option is used.

@OUTDENT ITEM = Note:Only one of the <169>R<170>, <169>W<170> and 
<169>A<170> options should be included. combinations of more than 
one are not supported (the last one in the string will be used).

A handle must be opened before any of the operations using handles 
will work properly. Use the FSTAT command and check for an error if 
there is a question about whether the handle has been opened.

Errors:

@ERROR ITEM = 3 Unable to open file "?????" in "?????" mode

@ERROR ITEM = 70 The value [?????] of parameter 1 is too big, maximum 
allowed is 9

@ERROR ITEM = 71 The value [?????] of parameter 1 is too small, minimum 
allowed is 0

@ERROR ITEM = 74 At least 2 parameter(s) required for this command

@ERROR ITEM = 80 Parameter [?????] must be a filename

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@ERROR ITEM = 94 Label not allowed in parameter [?????]

@ERROR ITEM = 98 The filename cannot include wildcards

@COMMAND = Command:

@COMMAND ITEM = OPR

@DESCRIPT = Purpose:

@DES ITEM = Performs a numeric operation and assigns the result

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = opr destval,sourcenum,opchar

@DESCRIPT = Argument 1:

@DES ITEM = The scalar or pointer to receive the resulting value

@DESCRIPT = 2:

@DES ITEM = The second operand, always a scalar

@DESCRIPT = 3:

@DES ITEM = A character representing the operation to be performed

This command is used for performing numeric operations on integers, 
characters and pointers. Some of the operations are not valid with 
pointers. The left Argument is assigned the value resulting from the 
operation being performed on both the Arguments.

For example:

@EXAMPLES = mov %i0,20 opr %i0,5,'-'

This would result in %I0 being 20-5 or 15.

Here is an explanation of each of the valid operations and the characters 
used:

@Z_TBL_BEG = COLUMNS(3), DIMENSION(IN), COLWIDTHS(E1,E3,E2), HGUTTER(.0560), 
VGUTTER(.0560), BOX(Z_DOUBLE), HGRID(Z_SINGLE), VGRID(Z_SINGLE), KEEP(ON), 
L2(R1C0..R1C3)

@Z_TBL_BODY = TABLE TEXT, TABLE TEXT, TABLE TEXT

Symbol<$!B11>, Operation<$!B11>, Types<$!B11>

++, Addition, Scalars of Pointers

-, Subtraction, Scalars or Pointers

*, Multiplication, Scalars

/, Division (Integer portion), Scalars

|, Bitwise <169>or<170>, Scalars

&, Bitwise <169>and<170>, Scalars

^, Bitwise <169>Exclusive or<170>, Scalars

%, Modulus (remainder in division), Scalars

>>, Bitwise Shift right (Sourcenum is the number of bits to shift), 
Scalars

<<, Bitwise Shift left(Sourcenum is the<R>
number of bits to shift), Scalars

@Z_TBL_END = 

Errors:

@ERROR ITEM = 62 Operator '?' not recognized

@ERROR ITEM = 63 Operator '?' not valid with pointers or not recognized

@ERROR ITEM = 83 Parameter [?????] should be a pointer or scalar variable

@ERROR ITEM = 86 This command requires 3 parameter(s)

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@COMMAND = Command:

@COMMAND ITEM = P

@DESCRIPT = Purpose:

@DES ITEM = To delay for a certain interval or until a certain time.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = p[,+timeout] or [,hh:mm]

@DESCRIPT = Argument:

@DES ITEM = If None, generates an error

@DES EXT = If a <169>+<170> with timeout number, waits for timeout/10 
seconds 

@DES EXT = if a 24 hour timeout time, waits until that time

This is just a delay command. The command must be made to timeout 
at a certain time (24 hour time) or after a certain number of 1/10 
second intervals.

Errors:

@ERROR ITEM = 29 Timeout expired

@ERROR ITEM = 70 The value [?????] of parameter 1 is too big, maximum 
allowed is 23

@ERROR ITEM = 70 The value [?????] of parameter 2 is too big, maximum 
allowed is 59

@ERROR ITEM = 71 The value [?????] of parameter 1 is too small, minimum 
allowed is 0

@ERROR ITEM = 71 The value [?????] of parameter 2 is too small, minimum 
allowed is 0

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@ERROR ITEM = 91 The time designation should contain a colon

@COMMAND = Command:

@COMMAND ITEM = PBUF

@DESCRIPT = Purpose:

@DES ITEM = Put data from a buffer into a file

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = pbuf handle,<MI>buf<D>[,<MI>val<D>]

@DESCRIPT = Argument 1:

@DES ITEM = The handle of the file to use

@DESCRIPT = 2:

@DES ITEM = A pointer to the data that will be written to the file

@DESCRIPT = 3:

@DES ITEM = if None, writes until end of source buffer

@DES EXT = if a scalar then the value is the number of bytes to read 


@DES EXT = if a pointer then the value will be the upper bound

The PBUF command is used to write data to a file. The <MI>buf<D> value 
is the location of the buffer to be written from.

The optional <MI>val<D> is the length as described in Section <$R[S*,Copcmds]6.4>. 
A hex 0 in the buffer will not affect the number of bytes written 
by this command.

The <MI>buf<D> parameter can also be an integer. If <MI>buf<D> is 
an integer then a two byte value will be written to the file. The 
<MI>val<D> parameter is irrelevant in this case.

Errors:

@ERROR ITEM = 20 The file specified by handle [?????] is not open

@ERROR ITEM = 69 Length pointer [?????] must point into the memory 
buffer

@ERROR ITEM = 70 The value [?????] of parameter 1 is too big, maximum 
allowed is 9

@ERROR ITEM = 71 The value [?????] of parameter 1 is too small, minimum 
allowed is 0

@ERROR ITEM = 74 At least 2 parameter(s) required for this command

@ERROR ITEM = 82 Length Parameter [?????] cannot be a file or label

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@ERROR ITEM = 90 Parameter [?????] should be a pointer or scalar

@COMMAND = Command:

@COMMAND ITEM = PUTXT

@DESCRIPT = Purpose:

@DES ITEM = Put data from a GETXT buffer back onto the screen

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = putxt <MI>ptr<D>

This command restores a window on the screen as saved with a prior 
getxt command. The value passed to it is the pointer which was used 
with the getxt command. The memory associated with the pointer is 
also freed and the pointer is set to NULL.

@COMMAND = Command:

@COMMAND ITEM = Q

@DESCRIPT = Purpose:

@DES ITEM = Drop the line and exit to DOS. Optionally, set errorlevel.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = q[,errorlevel]

@DESCRIPT = Argument:

@DES ITEM = If none, errorlevel is 0

@DES EXT = If a scalar, the errorlevel is its value

This command will break the connection with the other 3780 and then 
exit <$R[V*,Packname]D3-3780>. If a value is specified the DOS errorlevel 
will be set to that value. Otherwise, the errorlevel will be 0.

Errors:

@ERROR ITEM = 15 The modem is not able to transmit, It will not raise 
CTS

@ERROR ITEM = 18 The modem is not able to transmit, SCC TX buffer 
error

@ERROR ITEM = 70 The value [?????] of parameter 1 is too big, maximum 
allowed is 255

@ERROR ITEM = 71 The value [?????] of parameter 1 is too small, minimum 
allowed is 0

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@COMMAND = Command:

@COMMAND ITEM = QNZ

@DESCRIPT = Purpose:

@DES ITEM = Conditionally, drop the line and exit the package.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = qnz

If there was an error on the prior command then this will exit <$R[V*,Packname]D3-3780> 
with the DOS errorlevel set to the same value as the <$R[V*,Packname]D3-3780> 
error. If online, the line will be dropped.

Errors:

@ERROR ITEM = 15 The modem is not able to transmit, It will not raise 
CTS

@ERROR ITEM = 18 The modem is not able to transmit, SCC TX buffer 
error

@COMMAND = Command:

@COMMAND ITEM = RDLN

@DESCRIPT = Purpose:

@DES ITEM = Get a line of text from a file and put it into a buffer.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = rdln <MI>handle<D>,<MI>ptr<D>[,<MI>val<D>]

@DESCRIPT = Argument 1:

@DES ITEM = The handle of the file to use

@DESCRIPT = 2:

@DES ITEM = A pointer to the location where the line will be copied

@DESCRIPT = 3:

@DES ITEM = Specifies maximum number of characters to copy 

@DES EXT = if None, the buffer size is used 

@DES EXT = if a scalar, then the value is the number of bytes to read

@DES EXT = if a pointer, then the value will be the upper bound

The RDLN command is used to read a line of data from a file. The <MI>ptr<D> 
value is the location of the buffer in which to read the data. This 
command will, normally, read until a carriage return-line feed pair 
is encountered (this indicates the end of a line in an ASCII text 
file). A subsequent read will read the next line. In this way a file 
can be read a line at a time.

The optional <MI>val<D> is the maximum number of bytes to read. It 
is the same as described in Section <$R[S*,Copcmds]6.4>.

Errors:

@ERROR ITEM = 20 The file specified by handle [?????] is not open

@ERROR ITEM = 21 At end of file [?????], can't read anymore

@ERROR ITEM = 69 Length pointer [?????] must point into the memory 
buffer

@ERROR ITEM = 70 The value [?????] of parameter 1 is too big, maximum 
allowed is 9

@ERROR ITEM = 71 The value [?????] of parameter 1 is too small, minimum 
allowed is 0

@ERROR ITEM = 74 At least 2 parameter(s) required for this command

@ERROR ITEM = 77 Buffer pointer [?????] must have memory allocated 
to it

@ERROR ITEM = 82 Length Parameter [?????] cannot be a file or label

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@COMMAND = Command:

@COMMAND ITEM = READ

@DESCRIPT = Purpose:

@DES ITEM = Read specially formatted data from a file

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = read <MI>han<D>,<MI>val<D>[;<MI>ops<D>][+<MI>val<D>[;<MI>ops<D>]]...

@DESCRIPT = Argument <MI>han<D>:

@DES ITEM = The handle of the file to read from

@DESCRIPT = <MI>val<D>:

@DES ITEM = If a scalar, the value is read in 

@DES EXT = If a string, the string is read in 

@DESCRIPT = <MI>ops<D>:

@DES ITEM = If none, default read format 

@DES EXT = If string, characters determine format

The read command allows the script programmer to read strings and 
variable values from the disk. The first parameter is the file handle. 
The parameters following are the same as those for the RITE command 
as described in Section <$R[S*,Formops]6.8>. These options are treated 
differently however, for READ rather than RITE. This command will 
only read a single word (until the next blank or end of line) when 
it reads in a string so it may take several string reads to read a 
string that was written out with one write. The numeric values are 
expected to be in their ASCII string equivalent form, (like they would 
be written out with EDLIN or some other word processor) so the files 
could be modified directly by the user if necessary. This command 
can be used to read simple configuration files.

Errors:

@ERROR ITEM = 20 The file specified by handle [?????] is not open

@ERROR ITEM = 21 At end of file [?????], can't read anymore

@ERROR ITEM = 70 The value [?????] of parameter 1 is too big, maximum 
allowed is 9

@ERROR ITEM = 71 The value [?????] of parameter 1 is too small, minimum 
allowed is 0

@ERROR ITEM = 74 At least 2 parameter(s) required for this command

@ERROR ITEM = 76 The parameter [?????] cannot be assigned to

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@ERROR ITEM = 90 Parameter [?????] should be a pointer or scalar

@ERROR ITEM = 94 Label not allowed in parameter [?????]

@COMMAND = Command:

@COMMAND ITEM = REALL

@DESCRIPT = Purpose:

@DES ITEM = Adjust size of previously allocated memory

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = reall <MI>ptr<D>

@DESCRIPT = Argument:

@DES ITEM = The pointer used in a prior ALLOC or ALLST

@COMMAND = Command:

@COMMAND ITEM = REDSP

@DESCRIPT = Purpose:

@DES ITEM = Redisplay the default direct video screen (in variable 
SC)

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = redsp

@COMMAND = Command:

@COMMAND ITEM = REM

@DESCRIPT = Purpose:

@DES ITEM = Give a command to the another copy of <$R[V*,Packname]D3-3780>

@DESCRIPT = Restrictions:

@DES ITEM = Must be communicating with another version of <$R[V*,Packname]D3-3780>.

@DESCRIPT = Syntax:

@DES ITEM = rem commandstr[+commandstr]...

Arguments:A string containing any <$R[V*,Packname]D3-3780> command. 
This command is only useful when talking to another copy of <$R[V*,Packname]D3-3780>. 
Each parameter is a string containing a <$R[V*,Packname]D3-3780> command. 
An indefinite number of these commands can be strung together using 
<169>+<170> signs. This can be especially useful with the <169>/<170> 
command. 

For Example:

@EXAMPLES = rem "/dir >> dummy.txt"+"s dummy.txt"

This would cause the remote to take a local directory and put the 
output in the file dummy.txt and then send the resulting file back 
to the 3780 that sent the command. This command can be used to change 
the remote directory and execute remote batch files among many other 
things.

Another Example:

@EXAMPLES = rem "dp dummy.bat;s"

@EXAMPLES = s dummy.bat;s

@EXAMPLES = rem "/dummy"

These commands would send a batch file to the remote and then cause 
that file to be executed. The remote control possibilities here are 
pretty extensive (imagine modifying the remote's autoexec.bat).

Errors:

@ERROR ITEM = 1 The remote computer dropped the line 

@ERROR ITEM = 6 This command cannot be performed unless online 

@ERROR ITEM = 9 This command cannot be performed until current send 
is done

@ERROR ITEM = 15 The modem is not able to transmit, It will not raise 
CTS

@ERROR ITEM = 18 The modem is not able to transmit, SCC TX buffer 
error

@ERROR ITEM = 24 Bad acknowledgment limit exceeded. Send aborted

@ERROR ITEM = 25 Incomplete file sent - Enquiry limit was exceeded

@ERROR ITEM = 26 No acknowledgment limit exceeded. Send aborted

@ERROR ITEM = 27 Remote computer aborted send

@ERROR ITEM = 64 Unexpected state [???]

@ERROR ITEM = 74 At least 2 parameter(s) required for this command

@ERROR ITEM = 85 Parameter [?????] should be a string constant or 
pointer

@ERROR ITEM = 93 Insufficient internal memory to process command

@COMMAND = Command:

@COMMAND ITEM = REN

@DESCRIPT = Purpose:

@DES ITEM = Rename a file or files

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = ren oldspec newspec

@DESCRIPT = Argument 1:

@DES ITEM = Old value including path and wildcards

@DESCRIPT = 2:

@DES ITEM = New value including path and wildcards 

This is very similar to DOS' REN command except that the paths can 
be used to move a file from one directory to another. The DOS rename 
will not allow this.

Errors:

@ERROR ITEM = 16 No files found (using [?????])

@ERROR ITEM = 17 File [?????] not found

@ERROR ITEM = 51 "?????" already exists or invalid path

@ERROR ITEM = 60 Wildcards on left must be in same positions as those 
on right

@ERROR ITEM = 74 At least 2 parameter(s) required for this command

@ERROR ITEM = 89 Parameter [?????] should be a filename or file specification

@ERROR ITEM = 99 Attempt to move a file to another device

@COMMAND = Command:

@COMMAND ITEM = RET

@DESCRIPT = Purpose:

@DES ITEM = Returns to line after previous CALL command in the file

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = ret

This is the function which returns control after a subroutine has 
been called. Control will return to the line following the most recent 
internal CALL command. Intervening CALL commands to (or within) other 
script files do not effect the behavior of the internal calls.

Errors:

@ERROR ITEM = 67 This command is only allowed in script mode

@ERROR ITEM = 03 Return without a call

@COMMAND = Command:

@COMMAND ITEM = RITE

@DESCRIPT = Purpose:

@DES ITEM = Format and write data to screen

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = rite <MI>val<D>[;<MI>ops<D>][+<MI>val<D>[;<MI>ops<D>]]...

@DESCRIPT = Argument <MI>val<D>:

@DES ITEM = If a scalar, the value is written out 

@DES EXT = If a string, the string is written out 

@DESCRIPT = <MI>ops<D>:

@DES ITEM = If none, default display format 

@DES EXT = If string, characters determine format

The rite command allows the script programmer to write strings and 
variable values to the screen even when display echoing has been suppressed. 
The parameters are described in Section <$R[S*,Formops]6.8>.

Errors:

@ERROR ITEM = 74 At least 1 parameter(s) required for this command

@ERROR ITEM = 90 Parameter [?????] should be a pointer or scalar

@ERROR ITEM = 94 Label not allowed in parameter [?????]

@COMMAND = Command:

@COMMAND = Command:

@COMMAND ITEM = S

@DESCRIPT = Purpose:

@DES ITEM = Send files and buffers to the other 3780

@DESCRIPT = Restrictions:

@DES ITEM = Must be online

@DESCRIPT = Syntax:

@DES ITEM = s dat[;<MI>ops<D>][+dat[;<MI>ops<D>]]... <MI>ops<D>

@DESCRIPT = Argument dat:

@DES ITEM = If a string, the string is transmitted 

@DES EXT = If a file, the file is transmitted 

@DESCRIPT = <MI>ops<D>:

@DES ITEM = If none, default values are used 

@DES EXT = If string, characters determine values

This is the general purpose send command. It is used to send a combination 
of strings and files. The files can include wildcards. The <MI>ops<D> 
strings is used to specify details on how to send a file. The options 
specify the buffer type (Section <$R[S*,Vary]2.2>) expected, the destination 
(printer or punch) and whether the remote will receive the files as 
separate files or all in one.

Like the format option strings, the send option string does not require 
quotes and is a list of characters each of which has a meaning. There 
are two forms of options for this command the (shorter) normal ones 
and the more extensive form which can set the more unusual options. 
The normal options are:

@Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), COLWIDTHS(E1,E6), HGUTTER(.0560), 
VGUTTER(.0560), BOX(Z_DOUBLE), HGRID(Z_SINGLE), VGRID(Z_SINGLE), KEEP(ON), 
L2(R1C0..R1C2)

@Z_TBL_BODY = TABLE TEXT, TABLE TEXT

Option<$!B11>, Description<$!B11>

S, To send Standard mode with Vary buffer type

T, To send transparent mode with Fixed buffer type

B, To send transparent mode with Binary buffer type

C, To Concatenate files as they are transmitted (use ETB).  If used 
on a specific file it will cause the following file to be appended 
to the file.

X, To leave files separate as they are transmitted (use ETX).

P, To send to the remote printer

N, To send to the remote punch

H, To send standard mode with the Hex buffer type

V, To send standard mode with the Vary buffer type (same as S)

F, To send transparent with the fixed buffer type (same as T)

@Z_TBL_END = 

Examples:

@EXAMPLES = s file.txt s

Specifies standard with vary buffer type

@EXAMPLES = s file.txt+file2.txt tc

Specifies transparent with fixed buffer type and sends both files 
as one file. 

@EXAMPLES = s file.txt nb

Specifies transparent with binary buffer type and sends to the remote 
punch

Note:The order of the options is not important when using the short 
form.

The long form uses the <169>S<170> and <169>T<170> followed by either 
<169>V<170>, <169>F<170>, <169>B<170> or <169>H<170> to indicate precisely 
the buffer type and the mode in which it is used.

For example:

@EXAMPLES = s file.txt sf

Specifies that fixed format be used with standard mode

@EXAMPLES = s "48 65 6C 6C 6F" nth

Specifies that the send go to the punch and the transparent mode be 
used with hex buffer type

In general, specify the sending mode with an <169>S<170> or <169>T<170> 
and then use a <169>V<170>, <169>F<170>,<169>B<170> or <169>H<170> 
to specify the buffer type. The <169>P<170>,<169>N<170>,<169>C<170> 
and <169>X<170> options can be placed anywhere in the string.

When sending several files with one S command, the syntax of this 
command allows one default option string for all the files and specific 
option strings to modify the options for specific files in the list. 
The default option list is at the end and is separated from the list 
by a blank or a comma. The specific option lists should follow the 
file they modify and be separated by a semicolon.

For Example:

@EXAMPLES = s file0.txt;bc+file2.txt;s+file3.txt;t

This command concatenates the first two files and sends the third 
separate. Transparent mode and binary buffer type is used for file0, 
Standard mode and vary buffer type is used for file2 and transparent 
mode with fixed buffer type is used for file3.

@EXAMPLES = s file0.txt+file1.txt;p+file3.txt ns

This will send file0 and file3 to the remote punch and file1 to the 
remote printer. These will all all be sent in standard mode with the 
vary buffer type. They will also be sent as separate files.

Note:Concatenating a punch file to a printer file or visa versa will 
not work properly. Both the files will go to the destination of the 
first and one garbage character may be inserted at the start of the 
second file (a hex 12).

If the options list is left blank then the power up defaults or the 
buffer type and destination options from the last send will be used. 
The concatenation option always resets itself to disabled between 
send commands. The power up defaults are to send standard mode with 
the vary buffer type to the printer.

Errors:

@ERROR ITEM = 1 The remote computer dropped the line 

@ERROR ITEM = 2 Unable to open file [?????] 

@ERROR ITEM = 6 This command cannot be performed unless online 

@ERROR ITEM = 9 This command cannot be performed until current send 
is done

@ERROR ITEM = 15 The modem is not able to transmit, It will not raise 
CTS

@ERROR ITEM = 18 The modem is not able to transmit, SCC TX buffer 
error

@ERROR ITEM = 24 Bad acknowledgment limit exceeded. Send aborted

@ERROR ITEM = 25 Incomplete file sent - Enquiry limit was exceeded

@ERROR ITEM = 26 No acknowledgment limit exceeded. Send aborted

@ERROR ITEM = 27 Remote computer aborted send

@ERROR ITEM = 64 Unexpected state [???]

@ERROR ITEM = 72 Filename (and path) is too big in [?????]

@ERROR ITEM = 93 Insufficient internal memory to process command

@ERROR ITEM = 94 Label not allowed in parameter [?????]

@ERROR ITEM = 104 Parameter [?????] must be a string of filename

@COMMAND = Command:

@COMMAND ITEM = SAVE

@DESCRIPT = Purpose:

@DES ITEM = saves buffer pointed to by <MI>ptr<D> to <MI>file<D> named 
by <MI>file<D>

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = save <MI>ptr<D>,<MI>file<D>[,<MI>val<D>]

@DESCRIPT = Argument 1:

@DES ITEM = A pointer to a buffer (to write)

@DESCRIPT = 2:

@DES ITEM = filename to write out to

@DESCRIPT = 3:

@DES ITEM = If None, copies until a 0 is found or end of destination 
buffer 

@DES EXT = if a scalar, then the value is the number of bytes to write

@DES EXT = if a pointer, then the value will be the upper bound

The save command is a <F2M>Quick and Dirty<F255D> command to create a file 
and fill it with the proper data. This command saves you the trouble 
of having to open the file, write to it and then close it.

The length parameter is as described in Section <$R[S*,Copcmds]6.4>. 
The examples of the length parameter for the APP command also apply 
to the save.

The <MI>ptr<D> parameter can also be an integer. If <MI>ptr<D> is 
an integer then its ASCII equivalent value will be written to the 
file. That is, the if the integer is a 99 the string <169>99<170> 
will be written to the file. The <MI>val<D> parameter is irrelevant 
if <MI>ptr<D> is a scalar type.

Errors:

@ERROR ITEM = 69 Length pointer [?????] must point into the memory 
buffer

@ERROR ITEM = 74 At least 2 parameter(s) required for this command

@ERROR ITEM = 80 Parameter [?????] must be a filename

@ERROR ITEM = 82 Length Parameter [?????] cannot be a file or label

@ERROR ITEM = 90 Parameter [?????] should be a pointer or scalar

@ERROR ITEM = 98 The filename cannot include wildcards

@COMMAND = Command:

@COMMAND ITEM = SEEK

@DESCRIPT = Purpose:

@DES ITEM = Change the location of the file pointer

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = seek handle,wherenum[,refnum]

@DESCRIPT = Argument 1:

@DES ITEM = The handle of the file 

@DESCRIPT = 2:

@DES ITEM = The location to seek to

@DESCRIPT = 3:

@DES ITEM = If none, wherenum is relative to the beginning of the 
file 

@DES EXT = If refnum=1, wherenum is relative to the current location 


@DES EXT = If refnum=2, wherenum is relative to the end of the file

When file input/output is performed on files using handles then a 
file pointer is maintained by the system. This file pointer tells 
the system where to read from or write to the file. This command moves 
the file pointer to a different location. The third parameter determines 
whether the second parameter is relative to the start of the file, 
the current location or the end of the file. The value can be negative 
and must be if the location is referenced from the end of the file.

Errors:

@ERROR ITEM = 20 The file specified by handle [?????] is not open

@ERROR ITEM = 70 The value [?????] of parameter 1 is too big, maximum 
allowed is 9

@ERROR ITEM = 70 The value [?????] of parameter 3 is too big, maximum 
allowed is 2

@ERROR ITEM = 71 The value [?????] of parameter 1 is too small, minimum 
allowed is 0

@ERROR ITEM = 71 The value [?????] of parameter 3 is too small, minimum 
allowed is 0

@ERROR ITEM = 74 At least 2 parameter(s) required for this command

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@COMMAND = Command:

@COMMAND ITEM = SETBF

@DESCRIPT = Purpose:

@DES ITEM = Set the locations in a buffer to a single character

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = setbf <MI>buf<D>[;<MI>num<D>][,<MI>val<D>]

@DESCRIPT = Argument 1:

@DES ITEM = The buffer in which to set the values 

@DESCRIPT = <MI>num<D>:

@DES ITEM = if none, the buffer locations will be set to zero 

@DES EXT = if a scalar the buffer locations will be set to its value 


@DESCRIPT = <MI>val<D>:

@DES ITEM = Specifies number of locations to set 

@DES EXT = if None, length of <MI>buf<D> is used 

@DES EXT = if a scalar then the value is the number of bytes to set 


@DES EXT = if a pointer then the value will be the upper bound

This command is normally used to clear a buffer out. It can also be 
used to set the values in a buffer to some known value.

Errors:

@ERROR ITEM = 69 Length pointer [?????] must point into the memory 
buffer

@ERROR ITEM = 70 The value [?????] of parameter 2 is too big, maximum 
allowed is 255

@ERROR ITEM = 71 The value [?????] of parameter 2 is too small, minimum 
allowed is 0

@ERROR ITEM = 74 At least 1 parameter(s) required for this command

@ERROR ITEM = 77 Buffer pointer [?????] must have memory allocated 
to it

@ERROR ITEM = 82 Length Parameter [?????] cannot be a file or label

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@COMMAND = Command:

@COMMAND ITEM = SETPR

@DESCRIPT = Purpose:

@DES ITEM = Sets the string to be used at the prompt in the window

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = setpr <MI>ptr<D>

@DESCRIPT = Argument:

@DES ITEM = A string or pointer Argument. I will allow a full Argument 
list at some time (time date etc.)

@COMMAND = Command:

@COMMAND ITEM = SFORM

@DESCRIPT = Purpose:

@DES ITEM = Sets the format string for a display variable

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = sform <MI>num<D> <MI>ptr<D>

@DESCRIPT = Argument 1:

@DES ITEM = A number indicating which display variable

@DESCRIPT = 2:

@DES ITEM = The new format string

@COMMAND = Command:

@COMMAND ITEM = SIZE

@DESCRIPT = Purpose:

@DES ITEM = Determine the size of a given file

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = size numlow[;numhigh],<MI>file<D>

@DESCRIPT = Arg numlow:

@DES ITEM = Low integer of file size

@DESCRIPT = numhigh:

@DES ITEM = High integer of file size (0 if filesize is less than 
65535)

@DESCRIPT = file:

@DES ITEM = The name of the file

This command is used to check the size of a file. The optional numhigh 
parameter is used if dealing with a very large file. An error will 
be produced if numhigh is not included and the file is too large to 
put in an integer.

Errors:

@ERROR ITEM = 2 Unable to open file [?????]

@ERROR ITEM = 28 File is too large for an integer to store its length

@ERROR ITEM = 74 At least 2 parameter(s) required for this command

@ERROR ITEM = 80 Parameter [?????] must be a filename

@ERROR ITEM = 81 The value in parameter 1,[?????] cannot be assigned 
an integer

@ERROR ITEM = 81 The value in parameter 2,[?????] cannot be assigned 
an integer

@ERROR ITEM = 98 The filename cannot include wildcards

@COMMAND = Command:

@COMMAND ITEM = SLEN

@DESCRIPT = Purpose:

@DES ITEM = Determine the length of a string

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = slen <MI>num<D>,str

@DESCRIPT = Argument 1:

@DES ITEM = The variable to be assigned the length value

@DESCRIPT = 2:

@DES ITEM = The string whose length is being checked

This command is used to check the length of a string.

Errors:

@ERROR ITEM = 85 Parameter [?????] should be a string constant or 
pointer

@ERROR ITEM = 86 This command requires 2 parameter(s)

@ERROR ITEM = 88 The parameter [?????] cannot be assigned a scalar

@COMMAND = Command:

@COMMAND ITEM = SMASK

@DESCRIPT = Purpose:

@DES ITEM = Sets the mask for a display variable

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = smask <MI>num<D>, mask

@DESCRIPT = Argument 1:

@DES ITEM = A number indicating which display variable

@DESCRIPT = 2:

@DES ITEM = A bit mapped number which indicates when the variable 
should be updated

@COMMAND = Command:

@COMMAND ITEM = SMAX

@DESCRIPT = Purpose:

@DES ITEM = Sets the maximum length for a display variable

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = smax <MI>num<D> len

@DESCRIPT = Argument 1:

@DES ITEM = A number indicating which display variable

@DESCRIPT = 2:

@DES ITEM = The maximum number of chars to display

@COMMAND = Command:

@COMMAND ITEM = SO

@DESCRIPT = Purpose:

@DES ITEM = Sends modem's options to modem

@DESCRIPT = Restrictions:

@DES ITEM = The modem cannot be online

@DESCRIPT = Syntax:

@DES ITEM = so file

@DES ITEM = so <MI>ptr<D>

@DESCRIPT = Argument:

@DES ITEM = If a file, its contents are converted to hex and sent

@DES EXT = If a string, then the string's contents are converted and 
sent

This command is used to send modem option settings from a file. The 
file or string should contain ASCII text which represents hex option 
bytes (AA to mean hex AA). This can be used to send previously determined 
options which are generated with a word processor. A more elegant 
way of setting up the options interactively will be added soon (It 
will probably include a way to write files out which this command 
can send to the modem).

Errors:

@ERROR ITEM = 2 Unable to open file [?????] 

@ERROR ITEM = 7 This command cannot be performed while online

@ERROR ITEM = 15 The modem is not able to transmit, It will not raise 
CTS

@ERROR ITEM = 18 The modem is not able to transmit, SCC TX buffer 
error

@ERROR ITEM = 98 The filename cannot include wildcards 104 Parameter 
[?????] must be a string of filename

@COMMAND = Command:

@COMMAND ITEM = SPTR

@DESCRIPT = Purpose:

@DES ITEM = Subtracts two pointers and assigns the difference to an 
integer

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = sptr <MI>num<D>,ptrleft,ptrright

@DESCRIPT = Argument 1:

@DES ITEM = The number to receive the difference

@DESCRIPT = 2:

@DES ITEM = The left operand in the subtraction

@DESCRIPT = 3:

@DES ITEM = The right operand in the subtraction (to be subtracted)

This command can be represented as <169><MI>num<D>=ptrleft-ptrright<170>. 
It is useful for determining the number of locations between any two 
pointers. The result will be negative if ptrleft is larger than ptrright.

Errors:

@ERROR ITEM = 85 Parameter [?????] should be a string constant or 
pointer

@ERROR ITEM = 88 The parameter [?????] cannot be assigned a scalar

@COMMAND = Command:

@COMMAND ITEM = SPTYP

@DESCRIPT = Purpose:

@DES ITEM = Sets conditionals for working with special hardware

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = sptyp <MI>num<D>

@DESCRIPT = Argument:

@DES ITEM = A character which tells the PC to use a multiprotocol 
card or the DTE port of the modem.

@COMMAND = Command:

@COMMAND ITEM = SRITE

@DESCRIPT = Purpose:

@DES ITEM = Format and write data to a string

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = srite str,<MI>val<D>[;<MI>ops<D>][+<MI>val<D>[;<MI>ops<D>]]...

@DESCRIPT = Argument str:

@DES ITEM = The string to write the formatted data to.

@DESCRIPT = <MI>val<D>:

@DES ITEM = If a scalar, the value is written out

@DES EXT = If a string, the string is written out

@DESCRIPT = <MI>ops<D>:

@DES ITEM = If none, default format

@DES EXT = If string, characters determine format

The srite command allows the script programmer to write strings and 
variable values out to another string. The first parameter is the 
string (buffer) and the parameters following are the same as those 
for the RITE command as described in Section <$R[S*,Formops]6.8>. 
This command is useful to construct strings for filenames and to compare 
with incoming values.

Errors:

@ERROR ITEM = 74 At least 1 parameter(s) required for this command

@ERROR ITEM = 77 Buffer pointer [?????] must have memory allocated 
to it

@ERROR ITEM = 90 Parameter [?????] should be a pointer or scalar

@ERROR ITEM = 94 Label not allowed in parameter [?????]

@COMMAND = Command:

@COMMAND ITEM = STC

@DESCRIPT = Purpose:

@DES ITEM = Scan a string for the first occurrence of a character.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = stc destptr,sourcestr,char

@DESCRIPT = Argument 1:

@DES ITEM = The pointer variable which is assigned the result

@DESCRIPT = 2:

@DES ITEM = The string which is being searched

@DESCRIPT = 3:

@DES ITEM = The character which is to be matched

This command is used to determine the first location in a string that 
contains a certain character. If the string doesn't have the character 
in it anywhere then the destptr will be set to point to the <169>0<170> 
that terminates the string.

Errors:

@ERROR ITEM = 70 The value [?????] of parameter 3 is too big, maximum 
allowed is 255

@ERROR ITEM = 71 The value [?????] of parameter 3 is too small, minimum 
allowed is 0

@ERROR ITEM = 84 Parameter [?????] should be a pointer variable

@ERROR ITEM = 85 Parameter [?????] should be a string constant or 
pointer

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@COMMAND = Command:

@COMMAND ITEM = STOFF

@DESCRIPT = Purpose:

@DES ITEM = Turns off the status information display

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = stoff

@COMMAND = Command:

@COMMAND ITEM = STON

@DESCRIPT = Purpose:

@DES ITEM = Turns on all status variable display

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = ston

@COMMAND = Command:

@COMMAND ITEM = STST

@DESCRIPT = Purpose:

@DES ITEM = Scan a string for the first occurrence of a substring.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = stst destptr,sourcestr,substr

@DESCRIPT = Argument 1:

@DES ITEM = The pointer variable which is assigned the result

@DESCRIPT = 2:

@DES ITEM = The string which is being searched

@DESCRIPT = 3:

@DES ITEM = The substring which is to be matched

This command is used to determine the first location of the beginning 
of a substring in a string. If the string substring doesn't occur 
anywhere in the sourcestr the destptr will be set to point to the 
<169>0<170> that terminates the string.

Errors:

@ERROR ITEM = 84 Parameter [?????] should be a pointer variable

@ERROR ITEM = 85 Parameter [?????] should be a string constant or 
pointer

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@COMMAND = Command:

@COMMAND ITEM = SUP

@DESCRIPT = Purpose:

@DES ITEM = Suppress command window screen writes

@DESCRIPT = Restrictions:

@DES ITEM = Script Only

@DESCRIPT = Syntax:

@DES ITEM = sup

This command is used to suppress all video output except RITE and 
KEY statements. It gives the script programmer extensive control over 
what appears in the command window.

Error:

@ERROR ITEM = 67 This command is only allowed in script mode

@COMMAND = Command:

@COMMAND ITEM = TABLS

@DESCRIPT = Purpose:

@DES ITEM = Loads new conversion table from ASCII file

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = tabls filename NOT SUPPORTED YET (note:The tables can 
be modified using variables)

@COMMAND = Command:

@COMMAND ITEM = TD

@DESCRIPT = Purpose:

@DES ITEM = Displays the current time and date

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = td

This command displays the current time and date. It is mainly useful 
for logging that information in a script file when a list file is 
being used. No errors are possible with this command.

@COMMAND = Command:

@COMMAND ITEM = TELL

@DESCRIPT = Purpose:

@DES ITEM = Get the location of the file pointer

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = tell handle,varnum

@DESCRIPT = Argument 1:

@DES ITEM = The handle of the file

@DESCRIPT = 2:

@DES ITEM = The variable to assign the file pointer value to.

When file input/output is performed on files using handles then a 
file pointer is maintained by the system. This file pointer tells 
the system where to read from or write to the file. This command tells 
how far the file pointer is from the beginning of the file.

Errors:

@ERROR ITEM = 20 The file specified by handle [?????] is not open

@ERROR ITEM = 70 The value [?????] of parameter 1 is too big, maximum 
allowed is 9 

@ERROR ITEM = 71 The value [?????] of parameter 1 is too small, minimum 
allowed is 0 

@ERROR ITEM = 86 This command requires 2 parameter(s)

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@ERROR ITEM = 88 The parameter [?????] cannot be assigned a scalar

@COMMAND = Command:

@COMMAND ITEM = TR

@DESCRIPT = Purpose:

@DES ITEM = Store a record of exactly what goes on the line, a trace.

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = tr

This command is used for line diagnostics. It keeps a record of exactly 
what is communicated on the line. The tr command works as a toggle. 
If the trace is enabled then the command will disable it. If the trace 
is disabled then the command will enable it. The command is not supported 
yet and does not have any errors yet either.

@COMMAND = Command:

@COMMAND ITEM = UNCMP

@DESCRIPT = Purpose:

@DES ITEM = Reverses runlength compression of a file (opposite of 
comp) 

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = uncmp sourcefile,destfile

@DESCRIPT = Argument 1:

@DES ITEM = File to uncompress

@DESCRIPT = 2:

@DES ITEM = Name to use for resulting file 

@COMMAND = Command:

@COMMAND ITEM = UNDSP

@DESCRIPT = Purpose:

@DES ITEM = Restore the direct video display after a DSUP command

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = undsp

@COMMAND = Command:

@COMMAND ITEM = UNSUP

@DESCRIPT = Purpose:

@DES ITEM = Restore the video display after a SUP command

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = unsup

This command is used to reverse the effect of the SUP command. Thus, 
it restores the video back to normal.

Error:

@ERROR ITEM = 67 This command is only allowed in script mode

@COMMAND = Command:

@COMMAND ITEM = UPR

@DESCRIPT = Purpose:

@DES ITEM = Makes a string of scalar upper-case

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = upr <MI>val<D>

@DESCRIPT = Argument:

@DES ITEM = If a string, the whole string will be made upper-case

@DES EXT = If an integer or character, just the character will be 
made upper-case

This command is just like is sounds. Characters that are non-alphabetic 
or already upper case are not affected.

Error:

@ERROR ITEM = 76 The parameter [?????] cannot be assigned to

@COMMAND = Command:

@COMMAND ITEM = VTYPE

@DESCRIPT = Purpose:

@DES ITEM = Set display type using direct writes or operating through 
BIOS

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = vtype[ ch]

@DESCRIPT = Argument:

@DES ITEM = if 'B' then BIOS will be used otherwise direct ram writes 
will be used.

@COMMAND = Command:

@COMMAND ITEM = W

@DESCRIPT = Purpose:

@DES ITEM = Wait to receive a file or files from the remote

@DESCRIPT = Restrictions:

@DES ITEM = Must be online

@DESCRIPT = Syntax:

@DES ITEM = w,timeout

@DESCRIPT = Argument:

@DES ITEM = The maximum number of seconds to wait before a transmission 
is initiated.

This command is used to receive a transmission from the remote. More 
than one file can be sent in a transmission since the end of the transmission 
is signaled by an EOT character from the remote, files are separated 
by ETX characters. If auto-naming is enabled the N# and P# variables 
can be used to determine whether multiple files were received.

Errors:

@ERROR ITEM = 1 The remote computer dropped the line

@ERROR ITEM = 10 Disk error, See if disk is full

@ERROR ITEM = 12 Idle timeout during receive

@ERROR ITEM = 14 No activity timeout exceeded

@ERROR ITEM = 22 No acknowledgment limit exceeded. Receive aborted

@ERROR ITEM = 23 Remote aborted receive

@ERROR ITEM = 64 Unexpected state [???]

@ERROR ITEM = 67 This command is only allowed in script mode

@ERROR ITEM = 87 Parameter [?????] should be a scalar

@COMMAND = Command:

@COMMAND ITEM = XB

@DESCRIPT = Purpose:

@DES ITEM = Execute (chain to) another script file

@DESCRIPT = Restrictions:

@DES ITEM = None

@DESCRIPT = Syntax:

@DES ITEM = xb <MI>file<D>

@DESCRIPT = Argument:

@DES ITEM = The file to execute

This command is used to chain to another script file on disk. It is 
somewhat limited in script mode in that it will not return to the 
calling script file. In interactive mode this command is useful for 
automating sequences that are used frequently. When in script mode, 
the line following the XB should never execute.

Errors:

@ERROR ITEM = 2 Unable to open file [?????]

@ERROR ITEM = 80 Parameter [?????] must be a filename

@ERROR ITEM = 98 The filename cannot include wildcards

