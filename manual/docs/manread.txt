 1.0 General Information

 2.0 Background Information and terms
 2.1 The "Std" and "Tran" abbreviations as used in D3-3780
 2.2 The names "Vary", "Fixed", "Binary" and "Hex" as used in D3-3780

 3.0 The Default Command Screen

 4.0 Interactive Command Line Interface
 4.1 Interactive Editing keys
 4.2 Delimiters

 5.0 Batch Mode
 5.1 Built in Variables
 5.2 Constants
 5.3 Special Symbols
 5.4 Labels
 5.5 "Scalar" and "Pointer" as used in this document
 5.6 Pointer Variable Fundamentals
 5.7 Common Pointer Errors
 5.8 Suppressing Video Output using '@' and '!'
 5.9 Booting D3-3780 in batch mode

 6.0 Command Summary by Classes
 6.1 Branching Control Commands
 6.2 File Commands and Handles
 6.3 DOS Shell commands
 6.4 Data Movement Commands
 6.5 Memory Allocation Commands
 6.6 Other Pointer Assignment Commands
 6.7 Format options for writing strings out

 7.0 Alphabetical Command Summary

 8.0 Screen Customization Fundamentals
 8.1 Video Attributes
 8.2 Video Modes
 8.3 Attribute Variables
 8.4 Video Escape Sequences
 8.5 Status Variables
 8.6 The Status Variable Format String
 8.7 The Status Mask value
 8.8 The Status Variable Maximum Length value
 8.9 The C format specification

 9.0 The D3-3780.CFG file and its options
 9.1 Setting the Package and Configuration file names
 9.2 Common Configuration File Setups
 9.3 An Example Configuration FileD3-3780 Preliminary Read me File

Note: This document is a hodge-podge of notes.  Some of these will be in
      the user manual and some will be in technical documents or appendices.
      Therefore, the level of assumed knowledge will vary greatly from
      section to section.

1.0 General Information

This is a readme for the alpha site D3-3780 software from D3 Softdesign.  
It is intended to augment the UDS Dial manual.   The readme should
contain enough information to operate D3-3780.  First, a little about what
D3-3780 does and its intended applications.

D3-3780 works with Universal Data Systems' Sync-Up modems to emulate an IBM
3780 work station.  It should work with any device that follows IBM's
Bisynch 3780 protocol and is operating over a compatible modem.  For the
sake of brevity, I will refer to an IBM 3780 work station or any device that
emulates a 3780 work station as merely a "3780" for the remainder of this
document.

The current version of D3-3780 can work by itself or in conjunction with
UDS' dialer which is included on the D3-3780 disk.  D3-3780 has built in
dialing and auto answer capabilities but the setting of the modem options
is not convenient (the options must be entered in hexadecimal) without using 
UDS' dialer.  Convenient commands to support the setting of modem options 
will be added to D3-3780 shortly.

The files on your D3-3780 disk are:

  README.DOC      This file.
  D3-3780.EXE     The D3-3780 3780 emulator.
  D3-3780.HLP     Dummy help file for emulator (the helps are not helpful).
  SU.EXE          The UDS dialer.
  SU.HLP          The dialer's help.
  D3.BAT          Batch file which runs the dialer and then automatically 
                  runs D3-3780 if the connection has been established 
                  successfully.
  MODEMS.DTA	Modem design information
2.0 Background information and terms

Some background information and definitions are required to understand some
of the parameters used by D3-3780.  The next two sections are background 
information.

2.1 The "Std" and "Tran" abbreviations as used in D3-3780

In 3780 two different framing formats are used to transmit files.  The 
standard format is fine for sending text files but cannot transmit certain 
special characters (the data gets confused with the protocol's framing 
characters).  The transparent format can send all possible characters.
D3-3780 transmits and recognizes either format and allows different buffer 
translations of each.  The abbreviations "Std" and "Tran" are used
throughout D3-3780 to refer to standard and transparent framing formats,
respectively.

2.2 The names "Vary", "Fixed", "Binary" and "Hex" as used in D3-3780

An actual 3780 workstation formats the data buffers somewhat differently in 
transparent mode than in standard mode.  The standard mode sends variable
length records separated by record separator characters with consecutive 
spaces compressed.  This buffer format is referred to in D3-3780 as 
"Vary" (short for variable).  

The format most commonly used in transparent mode sends all 80 characters 
in a record and does not send record separators or perform space compression.  
This mode is referred to as "Fixed".  Both "Vary" and "Fixed" formats use 
the EBCDIC character set (D3-3780 performs ASCII/EBCDIC translations when 
sending or receiving).

Another commonly used format is one in which ASCII data is sent and received 
from the PC without being converted.  This will be referred to as "Binary".  
"Binary" data should normally be sent transparently since there is no 
guarantee that invalid characters will be in the file.  The transparent 
"Binary" mode can be used to send executable files from one PC to another. 
Many emulators use this format including UDS' "Bsc" and AST Research's 3780.
Some IBM mainframes are also set up to receive in this mode including the
IRS'.

D3-3780 has a buffer format called "Hex".  This mode transforms ASCII pairs
into bytes and vice versa.  It is primarily useful as a diagnostic tool.
This is not a true trace in that the 3780 framing and control characters are
not written out.  A true trace will be added soon.
3.0 The Default Command Screen

This version of D3-3780 is strictly command driven.  An alternate (menu-
driven) interface will be offered in addition.  The command driven interface
can be used in either interactive or batch mode.  The interactive mode takes
commands from the keyboard and the batch mode takes commands from a text
file.  An example of the command driven D3-3780 Screen appears below:

ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ D3-3780 ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
º 11:58:24  5/10/89   C:\D3-3780\BIN              Copyright D3 Softdesign 1989 º
ÇÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¶
º Print File:DATARECV.000              ³ Send File:°±²Û No File Û²±°           º
º Std:Vary   Tran:Binary Auto-Name:Yes ³ Mode:Std. Vary    Destination:Printer º
ÇÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¶
º Punch File:CON                       ³ Bytes Sent/Received:0              Rs º
º Std:Vary   Tran:Binary Auto-Name:Yes ³ Blocks:0       Naks:0   Enquiries:0   º
ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
?m
Establish a connection with the handset and then press Enter
The modem is now trying to connect (press Esc to abort)
Connected
?dir *.obj
NEWBAT   OBJ    BATCH    OBJ    BATCMDS  OBJ    KEYSTUF  OBJ    CMDS     OBJ
ED       OBJ    HELP     OBJ    INTRUPTS OBJ    DUMMY    OBJ    SCRNLIB  OBJ
SYNC     OBJ    VIDEO    OBJ    BUFRCV   OBJ    GETDTA   OBJ    BUFSEND  OBJ
MDMSTART OBJ    STUBS    OBJ    CONNECT  OBJ    DIE      OBJ    GENCMDS  OBJ
LISEND   OBJ    PARSER   OBJ    RCV      OBJ    SEND     OBJ    MAIN     OBJ
?




                                    Online                                  
------------------------------------------------------------------------------

The boxes at the top of the screen contain status and configuration 
information the area below it is a window which scrolls as commands are
entered and information displayed (like the example directory).  The last
line is for additional status information (with "Online" written on it).

Starting at the top of the screen I'll explain the different parts.  The 
top box contains the time, date, current directory and a copyright message.

Actual 3780 workstations have a printer and, optionally, a punch.  A host or
other 3780 device can specify which destination a transmission will be sent 
to.  D3-3780 maintains separate configuration information for each of these 
psuedo-devices.  

The two boxes to the lower left (with "Punch File" and "Print File" in the 
corners) display configuration information on the psuedo-printer and psuedo-
punch.  The designations "Print File" and "Punch File" mean the filename to
which the printer or punch data will be sent.  The word "CON" can be used in
this place to have incoming data sent to the screen.  

Below the file designations are the "Std", "Tran" and "Auto-Name" 
indicators.  These are the buffer formatting and auto-naming options.
The possible values for the buffer format options are: "Vary", "Fixed",
"Binary" and "Hex".  These values are described in section 2.2 above.
The Auto-Name option determines if separate files will be concatenated
or whether a new extension will be created for each reception.  If yes
an extension of "000" will replace a non-numeric extension and after that
the extension will increment with each new file that is received.  Otherwise,
additional files will be appended to the earlier files.

The box to the right of the printer box (with "Send File" in it) contains
status information for the file being sent.  The send file itself displays
the name of the file being transferred or "CON" if a message is being sent
from the command prompt.  The "Mode" indicates whether the transmission is
standard or transparent ("Std" or "Tran") and what buffer translation 
technique is being used ("Vary", "Fixed", "Binary" or "Hex").  To the right
of this is the indicator of whether the file is being sent to the remote's
printer or punch.

Below the sending box is a status box with some values in it.  These values
are sending status when sending and receiving status when receiving.  The 
"Rs" in the upper right hand corner of this box indicates that the data is
for "R"eceiving in "s"tandard mode.  There will always be either an R or S 
(receive or send) as the first character and an "s" or "t" (standard or 
transparent) for the second character.  Additional information can be
obtained using the "ST"atistics command.

  Bytes Sent/Received: This is the number of bytes sent or received in the 
    last or current reception or transmission (the number is updated during 
    the reception).  This number is not be very meaningful if the receive 
    filename is "CON".  In this case, the remote will send each message as 
    if it were a complete file.

  # of Blocks : This is the number of blocks (chunks of data) received
     or transmitted to the receive or transmit filenames.  These
     numbers are updated dynamically.  The number will increment
     when the block is stored to disk in the receive case or when
     the block is taken from the disk in the send case.

  # of Naks : This is the number of Naks (No acknowledgments) sent
     or received.  A Nak is a message sent by the receiving computer 
     when an error is detected in a transmitted block.  The number of 
     Naks will normally be quite small unless the telephone line 
     quality is poor.

  # of Enquiries : An enquiry is sent under two circumstances:(1)
     when a request is made to initiate a transmission, and (2)
     when data is missed and one end asks for re-transmission.  If
     nothing is missed during an entire transmission then this
     number will be 1.  The number of enquiries should be small.

The large open are below this boxes is the dialogue area in which commands can
be typed or displayed and various other messages will appear.  The "?" is 
used as the prompt.  This prompt is similar to the DOS prompt in that 
commands are typed in with parameters and then the Enter key is pressed to
cause the command to be processed.  The interface differs from DOS in several
detailed ways.

4.0 Interactive Command Line Interface

D3-3780 has an interactive command line interface and a batch interpreter
for running unattended.  These two are very similar in that most of the
commands can be used in either one.  

4.1 Interactive Editing keys

When you are at the D3-3780 prompt there are several editing keys at your
disposal.  Some of these are similar to DOS' keys but differences exist.
Here is a list of each key and its function:

        F1 : This key has the same function as it does in DOS.  It will copy
             the previous command a character at a time.

        F3 : This key has the same function as it does in DOS.  It will copy 
             the portion of the previous command which is to the right of the 
             cursor to the current line.

        F5 : Abort command but store command so that F1 and F3 will bring it
             back up.

        F10: Delete the entire command.

  Backspace: Moves cursor back (left) one position and deletes the character 
             to the left of the original cursor.  This is identical to DOS.

 Left Arrow: Moves the cursor back (left) one position but does not delete 
             the prior character.  In DOS, this key operates the same as the
             backspace key.

Right Arrow: Moves the cursor right one position unless you are already at
             the end of the command.

       Home: Bring the cursor to the beginning of the command.

        End: Bring the cursor to the end of the command.

     Insert: Toggles Insert/Overwrite mode.  Normally, if a letter is typed 
             while the cursor is over a character in the command the new
             letter will be inserted.  This is insert mode.  If D3-3780 is
             in overwrite mode the old character is replaced with the new
             one.  The cursor will appear as a large flashing block in
             overwrite mode.

     Delete: Delete the character over the cursor.

        Esc: A general abort from any type of failed operation.  Will abort
             a command in the middle of it but will not store the command
             like the F5 key.  In this respect the key resembles DOS' use
             of it.

The individual commands that are specific to interactive mode will be
explained in the command summary.

4.2 Delimiters

Certain characters are used to separate parameters in the commands.  These
characters are generally used in the same ways.  They are not always
interchangeable.  These characters are:

   " " (a space):   Normal delimiter used to separate command and first 
                    parameter.

   "," (a comma):   Interchangeable with a space as far as D3-3780 is 
                    concerned.

   ";" (semicolon): Used for optional parameters that modify mandatory
                    parameters.  The semicolon is used in commands that
                    take a set of parameters to set options that affect
                    the parameter before it.  See the "s" and "rite"
                    commands.

   "+" (plus sign): Used for commands that have a variable number of
                    parameters.  Most commands will actually take a blank
                    or comma also but the plus accurately describes the
                    behavior.

   "=" (equal sign):Indicates either equality or assignment depending on 
                    the command.  Used only in batch commands.

5.0 Batch Mode

Batch mode has special variables and functions that are useful to it.  Most
of these are also available in interactive mode but are not particularly
useful there.  They are left in primarily to allow the person writing batch
files to more easily check out a function's behavior.

5.1 Built in Variables

D3-3780 maintains several variables that can be modified and branched of
off in batch mode.  Actually, these variables can be modified and displayed
interactively since I felt it may be convenient to experiment with them
in that mode.  All variables are integers unless otherwise mentioned.  The 
variables and their suggested uses are listed below:

ae    : ASCII to EBCDIC conversion table.  This is the table used to convert
        the ASCII data files on the PC to EBCDIC on the line when sending
        using the "Vary" or "Fixed" buffer types.  The variable is Read/Write
        so individual table entries can be changed if necessary.  This table
        is only 128 bytes long.  PC characters above 7F hex have their 8th
        bit cleared before being converted (this is why PC graphic characters
        cannot be sent in the "Vary" or "Fixed" modes).

as    : Add separator.  This option only has an effect when sending using the
        "Vary" buffer type and the record is longer that the blocksize.  If
        the value of "AS" is 1 then a Record Separator character will be 
        added to the stream at the end of the block if it is a 0 it will not
        be.

ba    : Base Address this integer value is the lowest numbered I/O port 
        address of the modem.  The modem occupies the sixteen locations
        starting at this number in the port address space (actually, in
        the non-PS/2 modems the modem also occupies four images in the
        address space since bits 14 and 15 are not decoded).

bk    : Bad Acknowledgment Limit.  This is the maximum number of bad
        acknowledgments to accept before generating an error.  A zero
        value will cause it to try forever.

bl    : Blocksize, this variable is the current size of the send blocksize.
        It can be both read and assigned to with the desired effect.  
        D3-3780 can accept blocksizes up to 5000 bytes per block.

br    : Blocks received in last or current reception.  This value is read
        only.

bs    : Blocks sent in last transmission.  This value is also read only.

ca    : The Change attribute variable.  This is the attribute which is used
        when "\19" escape character is encountered in a video write.  It is
        also the value which is used when the highlighted filenames are
        returned to another value.  It defaults to white on color screens 
        and normal on monochrome screens.  See sections 8.1 and 8.3 for
        more on attribute variables.

cc    : Cursor Column location.  This value is read only.

co    : Compression.  If this value is 1 then space compression is enabled
        otherwise space compression is disabled.  Compression only affects
        sending with the "Vary" buffer type.

cf    : Command File.  The name of the currently executing batch file.
        Not relevant in interactive mode.  This value cannot be written
        to unless it is the configuration file which is executing.  The
        command file will execute when the configuration file is done
        if the "-F" command line parameter has been specified or the
        "DP" value is set to 'F'.

cl    : Command Line.  The line of the command (batch) file which is
        currently executing.  The first line is number 1 and the number 
        down from there.

cr    : Cursor Row location.  This value is read only.

da    : Default Attribute.  This is the default video attribute used in 
        direct video writes.  It is used if no attribute is specified or
        after the "\18" escape sequence is used.  See sections 8.1 and 8.3 
        for more on attribute variables.

db    : Data Buffer.  This is a pointer which is typically used as a data
        buffer by allocating space to it using the "ALLOC" function.  Some
        functions expect to use pointers into this buffer.  This will
        probably not be true in the future.

dd    : Date-Day.  The current day of the month.  Read Only.

dm    : Date-Month.  The current month.  Read Only.

dp    : This is the Dash Parameter value that was passed on the DOS command
        line.  An 'F' can be assigned to it in the configuration file to
        cause batch processing to be used instead of interactive.  The name
        of the batch file will default to the "D3-3780.CMD" but can be
        assigned a value in the start up file (see "CF" above).

dr    : The current directory.  String type, Read Only.

ds    : Disk Space.  If the disk space is less than 65535 this value will be
        the amount of available disk space on the logged drive.  Otherwise
        the value of ds will be 65535.

dy    : Date-Year.  The current year.  Read Only.

ea    : EBCDIC to ASCII conversion table.  This is the conversion table used
        to convert from EBCDIC on the line to ASCII in the PC when receiving
        using the "Vary" or "Fixed" types.  It is Read/Write and is 256 bytes
        long.

ed    : Emulation Directory.  The directory which contains the D3-3780.EXE
        file.  If using DOS 2.XX the path must contain the emulation
        directory for this value to be correct.  If using DOS 3.XX or 4.XX
        the value will always be correct.

ef    : Exit file.  This is then name of a command file which will be
        automatically be executed when the package is exited.  If the string
        contains a label instead then the configuration file will be
        reloaded and execution will begin at the location of the label.

ei    : Error Indicator.  This variable is the errorlevel of the most recent 
        operation.  This value is reset on EVERY instruction (even comments).  
        It is read only.

el    : Error Line.  This variable is the line number of the most recent
        operation that had a non-zero "ei" value.  The value remains until 
        the next non-zero error "ei" value occurs.  It is read and write.

ep    : Error Persist.  This variable is the errorlevel of the most recent 
        operation that had a non-zero error indicator.  The value remains 
        until the next non-zero error occurs.  It is read and write.

eq    : Enquiry Limit.  The number of consecutive enquiries which must occur
        before a send or receive will generate an error.  0 means try
        forever.

er    : Enquiries received.  The number of enquiries received in the last
        reception.  Read only.

es    : Enquiries sent.  The number of enquiries sent in the last 
        transmission.  Read only.

ex    : Exit string.  This is a direct video write string written out just
        before the package exits.  Typically, it would be used to clear the
        screen and place the cursor if the exit batch file is not setup to
        do so.

ga    : Graph Attribute.  This is the video attribute byte for ASCII 
        characters above 7F hex in video writes.  The attribute is 
        generally used for boarders of boxes.  The "\21" escape sequence 
        will also set the color to the Graph Attribute.  See sections 8.1 
        and 8.3 for more on attribute variables.

ge    : Graph Enable.  If this value is 7F hex then the characters numbered
        above 7F are written out using the graph attribute if the value is
        FF then the automatic setting of the graph attribute is disabled.

ha    : High Attribute.  This is the attribute used to highlight the
        sending or receiving file names and conversion types when they are
        active.  It defaults to Light Blue in color and High intensity in
        monochrome.  The "\20" escape sequence enables this attribute.  See 
        sections 8.1 and 8.3 for more on attribute variables.

i0-i9 : General purpose integers.  These are general purpose integers which
        can be used for loop counters, mathematical operations, flags and
        indices into arrays.

id    : Idle Limit.  This value is the number of ticks (which occur 18.2
        times a second) before a reception will be aborted.  0 means wait
        forever.  It does not run while waiting for a reception to begin,
        only once the reception has started.
        Note: The timeout for the "W" command does not timeout once a 
              reception has been started.  This value will cause an error
              if activity halts during the reception.

it    : Interrupt.  This is the modems interrupt level.  It should be one
        of 2,3,4 or 5.

ka    : Key Attribute.  This is the default attribute used for keyboard
        input in the interactive mode.  Its default values are the same as 
        the default attribute.  See sections 8.1 and 8.3 for more on 
        attribute variables.

kr    : Naks received in last reception. Read only.

ks    : Naks sent in last transmission. Read only.

lf    : List file.  String which is the name of the current listing file.
        The name will be "NUL" if no listing file is being used.  String
        type.  Read only (use the "lf" command to change it).

mb    : Memory Branching.  This is a boolean value which sets the branching
        type of the command file.  There are two branching techniques
        supported in D3-3780.  One is slow but requires no additional memory
        and the other is fast but requires some memory (if enough memory
        cannot be obtained then the slow technique is always used).  If this
        value is 1 (the default) the fast technique is used otherwise the
        slow one is used.  The value must be set before the command file is
        executed and applies to the original command file and any files
        loaded using the "CALL" or "XB" commands.  You may want to set the
        value to 0 if you have several very large buffers and are getting
        the "Insufficient internal memory" error number 93.

mv    : Modem Version.  The version number of the modem.
        Version number in Hex  -  Modem
         0 - Sync-Up 201C
         1 - Sync-Up 208A/B
         2 - Sync-Up 9600B
         3 - Sync-Up 201/212
         4 - Sync-Up V.26
         5 - Sync-Up V.22 bis
         6 - Sync-Up T9628
         7 - Sync-Up 4824
         8 - Sync-Up V.32
        80 - Sync-Up 2/201
        81 - Sync-Up 2/208/201
        83 - Sync-Up 2/201/212
        85 - Sync-Up 2/V.22 bis
        86 - Sync-Up 2/T9628B
        88 - Sync-Up 2/V.32
        ff - if the version number is unavailable.

n#    : Punch auto-naming index.  This is the number in the extension of the
        punch file name (or 0 if no number).  The value is read only but the
        "dn" command can be used to set the number.

na    : Punch Auto-Naming value.  Scalar, 0 means disabled, 1 means enabled.  
        The auto-naming option can be changed by modifying this value.

nk    : No acknowledgment limit.  This is the maximum number of no
        acknowledgments before a reception or transmission is aborted.
        0 means there is no limit.

nn    : String variable which points to the punch name.  This value can have
        strings assigned to it which will affect the next reception.  The 
        maximum length is 65 characters.

ns    : Punch Standard buffer type.  Scalar,0-Vary,1-Fixed,2-Binary,3-Hex.
        This variable is read and write.

nt    : Punch Transparent buffer type.  Scalar,0-Vary,1-Fixed,2-Binary,3-Hex.
        This variable is read and write.

nu    : NULL pointer.  This is a dummy constant value which is used to
        to indicate that a pointer does not point to anything.  There
        are circumstances which this value should be assigned to a pointer.
        Section 5.7 describes the way the "nu" variable should be used in
        detail.

p#    : Printer auto-naming index.  Same as "n#" above except for the 
        printer.

p0-p9 : Pointer variables.  These are used to point into the "db" buffer.
        You can use the "db" buffer as if it were several smaller buffers
        by pointing these into certain locations into it.  They are also
        useful in many string operations.

pa    : Printer Auto-naming value.  Same as "na" above.  

pn    : Printer filename.  Same as "nn" above.

ps    : Printer Standard buffer type.  Same as "ns" above.

pt    : Printer Transparent buffer type.  Same as "nt" above.

ra    : Reverse Attribute.  The attribute used for reverse video in direct
        video writes.  It is activated by using the "\16" escape sequence.
        See sections 8.1 and 8.3 for more on attribute variables.

rl    : Receive Record length.  This value is used to set the implied record 
        length of incoming data when the "Fixed" buffer type is used.

rs    : Receive Size.  The size of the last reception.  Read only.

rt    : Receive type.  Indicates the type of the last reception.  The
        possible values are: 
          0 None    ; No reception since boot up.
          1 std-prn ; Last reception was in standard mode, to the printer.
          2 std-pun ; Last reception was in standard mode, to the punch.
          3 trn-prn ; Last reception was in transparent mode, to the printer.
          4 trn-pun ; Last reception was in transparent mode, to the punch.
        This value is read only.

sc    : The direct video screen.  This is a pointer to the screen to be
        displayed.  It is both read and write and can even be assigned new
        pointer values.  Multiple screens can be loaded and this value can
        be changed to point to different screens for display.

sd    : Send Destination.  Scalar, 0-printer, 1-punch.  The variable is
        both read and write.

sm    : Send Mode.  Scalar 
         0 Standard Mode,  Variable Record type
         1 Standard Mode, Fixed Record type
         2 Standard Mode, Binary Record type
         3 Standard Mode, Hex Record type
         4 Transparent Mode, Variable Record type
         5 Transparent Mode, Fixed Record type
         6 Transparent Mode, Binary Record type
         7 Transparent Mode, Hex Record type
        This variable is both read and write.

sn    : Send name.  String type, Read only.

sr    : Send Record Length.  The implied record length in a "Fixed" buffer
        type send.  This is the number of blanks padded on the left for this
        type.

ss    : Send size.  The size of the last send.

sv    : System variables.  This is a pointer to a ragged array containing all
        the format strings for the display variables.  It is primarily
        included so the '!' operator can be used for you to check the 
        amount of memory your format strings are occupying.  This value is
        a pointer and can be reassigned but this is not recommended.

tb    : Trailing Blanks.  This determines if blanks at the end of a record
        are transmitted when sending with the "Vary" buffer type.  If it is
        0 then trailing blanks are not sent (like a real 3780) if it is a
        1 then trailing blanks are sent.

th    : Time-Hour.  The current hour.  Read Only.

ti    : Timeout.  This is the time (in ticks, 18.2 tick per second) between 
        re-enquiries when sending this value is typically set for 3 seconds
        (or 54 ticks).

tm    : Time-Minute.  The current Minute.  Read Only.

ts    : Time-Second.  The current Second.  Read Only.

ua    : Underline Attribute.  This is attribute defaults to underline in
        monochrome mode and red in color mode.  The "\23" escape sequence
        is used to enable it.  See sections 8.1 and 8.3 for more on 
        attribute variables.

va    : Version-Major.  The major number of the DOS version number.

vb    : Version-Bisync.  The version of D3-3780 multiplied by a 1000.

vi    : Version-Minor.  The minor number of the DOS version number.

vm    : Video Mode.
         2 -- Means Color card running in monochrome mode
         3 -- Means Color
         7 -- Means Monochrome
        See section 8.2 for more on video modes.

wa    : Window Attribute.  This is the default attribute used for writes in
        the scrolling window.  It is gray in color and normal in monochrome.
        See sections 8.1 and 8.3 for more on attribute variables.

wb    : Window Bottom.  The bottom line of the scrolling window.

wr    : Window Right.  The rightmost column of the scrolling window.

wl    : Window Left.  The leftmost column of the scrolling window.

wt    : Window Top.  The top line of the scrolling window.

The following sections will describe how these variables can be used and the
operations which can be performed on them.


5.2 Constants

Numeric constants are the normal numbers 0-9, numbers contained in "<>",
hex numbers <hFF> and characters in single quotes 'A'.
Examples:

    <hff>        ; hexadecimal FF or decimal 255
    'A'          ; The ASCII a character, hex 41 or decimal 65
    89           ; Just like it looks, decimal 89
    <-89>        ; Decimal -89 the "<>" symbols are only required for hex 
                   numbers to make distinguishing the number from the 
                   filename more direct.  More on this later.
    <45>         ; Decimal 45, The "<>" symbols are not required but don't
                   hurt anything either.

Note: There is one place where <45> would be treated differently than 45.
      This is in the destination field of a branching instruction.  See 
      section 5.4 on labels for more on this.

String constants are series' of characters enclosed in double quotes.
Example:

  "This is a dummy string"

Note: Strings are terminated with a hex 0.  If this string were copied into
      a buffer then a hex 0 would be copied to the location past the "g" to
      indicate that the string was finished.

String constants can contain certain escape sequences to allow the entering
of special data.  The escape sequences begin with a backslash and are 
followed by other characters to describe the desired operation. 

These escape sequences are:

  "\###"  -- Where "###" is any decimal number from 0-255.  This number
             is entered directly into the string.
  "\+###" -- The same as "\###" above.
  "\-###" -- Similar to the above two except the number is negative.
  "\x##"  -- Similar to above except the number is in hexadecimal.
  "\a"    -- Same as "\7" (a bell in a video write).
  "\b"    -- Same as "\8" (a backspace).
  "\t"    -- Same as "\9" (a tab).
  "\n"    -- Same as "\10" (a linefeed).
  "\v"    -- Same as "\11" (Scrolls the screen in a video write).
  "\f"    -- Same as "\12" (form feed, clears the screen in a video write).
  "\r"    -- Same as "\13" (a carriage return).

See section 8.4 for more on the video functions of these escape sequences.

5.3 Special Symbols

D3-3780 uses several special symbols to perform operations on and 
distinguish variables.  Every reference to a variable must begin
with one of these symbols in order to stop it from being interpreted as
a filename.  The symbols are listed below.


The variable indicator: % (percent sign) 

Used to designate that this is an internal variable (not a filename).
Whenever a variable is accessed in a normal fashion the "%" sign is
used to distinguish the variable name from the equivalent filename.


The Index indicators: [] (brackets)

Used to index into buffer or pointer variables.  This is the same as many
common languages use the bracket.  Arrays are indexed from 0 rather than 1.
The value can be used on the db and p0-p9 variables and any other pointer
variables.  Once a pointer is set to point to a location then it can be 
indexed as if it were an array starting at that location.  The value inside 
the brackets can be anything which evaluates to a scalar.  
For example:

Given
db = 0 1 5 3 4 5 6 ...
i0 = 0
i1 = 5
p0 points to db[3]

%db[5]      ; The character at location 5 in the db buffer which is 5.
%db[%i1]    ; Since the i1 integer is 5 then the same as above.
%db[%db[2]] ; Since 5 is at db[2] then this is the same as %db[5] or 5.
%db[%db[%p0[2]]] ; Since p0[0] is db[3] then p0[2] is db[5]=5 so this 
                   is 5 also.

The last two examples shows that the index can be another value with an 
index.  There is no practical limit to the number of times indexes can have
other indexes within them.


The "address of indicator": & (ampersand) 

"the address of" operator.  Used to indicate the address of a value
rather than the value itself this is normally used in conjunction with
the an indexed pointer.  
For example:

   mov %p0,&db[1000]

This assigns the address of the character "db[1000]" to the pointer
variable p0.  p0 could then be indexed like an array starting at db[1000]


The "value pointer to by": @ (at sign)

The value pointed to by a pointer variable.  For example:

   mov %p0,&db[1000]
   mov %i0,@p0

If i0 would be set equal to the value at db[1000].  This value is 
equivalent to indexing at zero (@p0 is the same as %p0[0]).  This is a
useful shorthand notation since the first value is frequently needed.

In batch mode, this symbol can also be used to precede a command name to 
stop the command from being echoed to the screen.


The "number indicator": # (pound sign)

Used to convert a string (containing numbers) into the number itself.

   cpy %p0,"789"
   mov %i0,#p0

The "cpy" command copies the string "789" to the location pointed to by
p0.  Then the value 789 decimal is assigned to i0 since "#p0" evaluates
to decimal 789.  The "#p0" could be used anywhere a numeric constant is
needed, even as an index.


The "make string symbol": $ (dollar sign)

Used to turn an integer into a string.
For Example:

  mov %i0,67
  cpy %p0,$i0

This would cause the string "67" to be copied to the location pointed to by
p0.  The "$" operator is supported on all pointer variables.  

An internal string is created by this command with a limited lifetime.  
Specifically, newer uses of the "$" sign operator may destroy the older 
values.  The values are guaranteed to be valid within 10 uses of the "$" 
operator.  After that the oldest value may be destroyed by the newest 
value.

For Example:

  mov
  mov %p0,$i0


To convert another 
variable either move it into an "i#" variable or use the "srite" function
to be discussed later.


The "size (length) of variable operator": !

This will return the length of a variable or (more importantly) the length
of the buffer which a pointer points to.  This is useful for diagnostics
when memory overflow problems occur.

In batch mode, this symbol can also be used to suppress all output from a 
command including the echo of the command itself.


The "make me a label or filename operator": ^ (carat)

To cause any string to be interpreted as a filename or a label.  This is
used when a string contains a filename of label.
For example:

  mov %p5,":out"
  go,^%p5

The "go" statement needs to see a label or line number.  If the carat were
not there then it would look for a label called "%p5".


The operator override: ] (closed bracket) 

Used to start filenames which begin with a special symbol or number.  If a
filename begins with one of the operators it can be forced to be viewed as
a filename by putting a "]" in front of it.
For example:

 open 0,]89file.txt

The second parameter would not be recognized as a filename unless the bracket
preceded it.



5.4 Labels

Labels are used as the destination in batch branching instructions.  They
begin in the first column of a line and must always begin with a ":".  There
is currently no limit to how long you can make a label or how many labels are
in a given file.  Regardless of how many characters you use D3-3780 checks 
for a perfect match.  If you put a string in place of a destination then 
the string will be interpreted as a command and then execution will continue
on the next line (or if the instruction contains a branch on the line
specified by the branch).  If the value is a number then that number is
either the line to branch to (first line is numbered 1) or is relative to
the current line.

Example:
Line  Data
1.    * The "*" that starts this line makes it a comment.
2.
3.    * The "dl" command below will set the ei variable
4.    dl
5.    on %ei,0=:lbl,1="ex",2=<-1>,4=3
6.
7.    * If ei is 0 then execution will begin at label
8.    :lbl

The "on" command is a multiple branch instruction, the values to the 
immediate right of the "=" sign are destinations.  If the value of ei
is 0 then execution will begin at the line follwing the label ":lbl".
if ei=1 then the command "ex" will be executed to leave D3-3780.  If ei=2
then execution will begin one line back from the on statement at line 4 and
if ei=4 then execution will begin at line 3.  Otherwise execution will 
continue at line 6.


5.5 "Scalar" and "Pointer" as used in this document.

There are two basic types of variables used in the D3-3780 command
language.  These are scalars and pointers.  

Scalars are:

          Description                          Examples
-----------------------------------------------------------------
Decimal and hexadecimal constants               89 <hFF>
             Characters constants             'A' 'B' '0'
                Integer variables              %i0 %i9 %bl
      Members of character arrays           %db[5] %p0[3] %nn[8]
       Pointers with the "@" sign              @p0 @p6 @p9
       Pointers with the "#" sign                #p0 #db


Pointers are:
          Description                          Examples
-----------------------------------------------------------------
                String Constants         "a string" "golly wolly"
    db and the pointer variables             p0 db nn pn p9
             i0-i9 with "$" sign               $i0 $i8 $i2
    indexed arrays with "&" sign           &db[5] &p0[7] &pn[8]

The word "string" is used to refer to pointers which point to ASCII data
which uses a 0 character to signify the end of the data.  The word "buffer"
is used for pointers to any type of data that have some memory available at
the location they point to.  Labels and filenames are stored internally as 
strings but they are treated differently by most functions.


5.6 Pointer Variable Fundamentals

One of the more complicated parts of writing D3-3780 batch files is handling
pointer variables and, in general, memory allocation.

A pointer variable is a variable which can contain an address in the 
computer's memory.  In D3-3780, most pointers variables are initially set to 
an invalid value (some status pointers are set to point to specific things by
default).  This invalid value is referred to as "NULL".  If you attempt to 
write a null pointer "(null)" will be displayed.  If you try to copy data to 
the location pointed to by a null pointer an error will result.

Values are assigned to pointers in several of D3-3780's commands.  Some 
commands tell D3-3780 to reserve some memory for the variable and change 
the value of the pointer to "point" to the reserved memory (alloc, allst,
getxt).  Other commands allow the pointer to be assigned a value that 
points within memory that has already been allocated (stc, stst, mov).

The "reall" adjusts the amount of memory which a pointer points to and the
"free" function gives the memory back that was allocated (and sets the
pointer to NULL).

In D3-3780, when a pointer is assigned a value a length is also assigned
(internally) which indicates how much memory is reserved at the location 
the pointer points to.  This length is frequently used when a data is 
transferred to or from the location the pointer points to (load, gbuf, 
rdln, etc.).


5.7 Common Pointer Errors

There are several possible errors which can be made by incorrectly using
pointers.  These errors may be difficult to detect since the error message
frequently lags the actual error and may even result in occur sometime 
later.

Writing to a location that does not have memory allocated to it.

  Example:

    free %p0
    cpy %p0,"A dummy string".

  The p0 variable cannot have any memory allocated to it since the free
  command gave it all back.  This will result in a NULL pointer assignment
  error [77].  The same error will occur if the pointer is never assigned
  a value (p0 is initially NULL).

  A more subtle form of this error is when two pointers have been pointing
  to the same area and one is used to free the memory.  The other pointer
  will no longer be pointing to allocated memory but its value will not be
  NULL.
  Example:

    allst %p0,"This will allocate some memory to the %p0 variable"
    mov %p1,%p0
    free %p0
    cpy %p1,"This is an error but no message will be displayed"

  The problem with this code is that the "free" gave all the memory back to
  the system but the second pointer "p1" continues to use the memory.  This
  error will not result in an immediate error but may cause trouble later on.
  It is a good practice to set invalid pointers to NULL.  This is accomplished
  by using the "nu" variable.  
  Example:

    allst %p0,"This will allocate some memory to the %p0 variable"
    mov %p1,%p0
    free %p0
    mov %p1,%nu
    allst %p1,"This is an no longer an error"

Writing to a read only variable via a pointer variable.
  Another possible error is to write to a read only variable by first assigning
  a pointer to the read only variable.  An error message will be displayed if
  you try to assign to a read only variable directly but no error will be
  generated if a pointer variable is used to do it.  
  Example:

    mov %p0,%ed
    cpy %p0,"garbage.dir"

  This would destroy the emulation directory (which can stop the cleanup 
  section of the configuration file from executing properly).    

Failing to free unused memory
  When memory has served its purpose it should be freed using the "free" 
  command or by allocating it for another purpose (the alloc and allst 
  automatically free a non-NULL pointer if it is passed to them).
  Example:

    alloc %p0,400
    srite %p0,"/copy "+%p1+" "+%p2
    intrp %p0
    mov %p0,%nu

  The first command created a temporary buffer.  The second command assigned a 
  value to the buffer and the third used the value in the buffer.  The fourth
  command destroyed the only pointer to the allocated memory without first
  giving the memory back to the system.  This is a waste of 400 bytes of 
  memory.
  Correct Examples:
  
    alloc %p0,400
    srite %p0,"/copy "+%p1+" "+%p2
    intrp %p0
    free %p0

    or

    alloc %p0,400
    srite %p0,"/copy "+%p1+" "+%p2
    intrp %p0
    allst %p0,"Some string which will be useful later"

  Both of these examples give memory back when they are through with it.  The
  first example does this by using a free command (this command also assigns
  NULL to the pointer).  The second uses the pointer as the argument to the
  allst command.  This command will automatically free the memory pointed to
  by a pointer if the pointer value is not NULL.  The alloc command will also
  free non-NULL pointers.
  
Freeing a pointer which was never alloced
  This error occurs when a non-NULL pointer whose value is was not assigned
  with an alloc, allst or reall is used as an argument to a free, allst or 
  alloc command.  
  Example:

    allst %p0,"Never eat raw vegetables."
    mov %p1,&p0[6]
    rite %p1
    allst %p1,"This is a subtle error."

  The last statement inadvertently causes the value of p1 to be freed (since
  p1 is not NULL but it does not point to an allocated memory block).  This
  is corrected as such:
  
    allst %p0,"Never eat raw vegetables."
    mov %p1,&p0[6]
    rite %p1
    mov %p1,%nu
    allst %p1,"This is no longer an error."

  The assignment of NULL to p1 stops the allst command from assuming that p1
  points to an allocated memory block.

I may add some more run time checking to correct or point generate errors for
some of these conditions (especially the last one).  


5.8 Suppressing Video Output using '@' and '!'

Several techniques and commands are offered to suppress the different kinds of 
video writes.  The two symbols '@' and '!' can be used immediately before a 
command to perform a very short suppression of video.  The '@' symbol is used
to stop the command itself from being echoed to the screen.  The '!' stops the
command and any of its writes from being echoed (except for the rite command).

Examples:

  @sup
  * The sup command will not be displayed.

  !dl "1 (205) 881-8183"
  * The dl command and all status messages from the "dl" will be suppressed.

A variety of other commands exist to suppress video for a set of lines but
these two are useful when you merely want to suppress the output in a few
specific instances.


5.9 Booting D3-3780 in batch mode

There area two ways of having a command file execute automatically on boot
up (rather than going interactive).  

By specifying the "-F" parameter on the DOS command line.
Example:
       C>d3-3780 -fcmdfile.cmd
	  C>d3-3780 -f

In the first example the file "cmdfile.cmd" would execute and in the second
example the file "D3-3780.CMD" (the default name) would execute.  The program
would return to DOS when the command file is through executing.  

The other way is by specifying the "F" parameter in the configuration file.
If the following line is included in the "D3-3780.CFG" file the command file 
"D3-3780.CMD" will execute:

  mov %dp,'F'

The dp (Dash Parameter) variable is expressly designed for this purpose.  This
assignment is only significant in the configuration file.  The command file
which is executed can be set in the configuration file also:

  mov %dp,'F'
  cpy %cf,"cmdfile.cmd"

The command file "cmdfile.cmd" in the active directory would be executed 
in this case.  The command file name can include a path and can be up to 65
characters long.  The following would execute the command file in the 
emulation directory:

  mov %dp,'F'
  srite %cf,%ed+"\cmdfile.cmd"

The srite will command the ed (emulation directory) plus the command file name
to the command file variable in this case.  Assigning a value to the cf 
variable is only relevant in the configuration file.

The default names ("D3-3780.CMD" and "D3-3780.CFG") can be changed to other
values.  See chapter 9 for a discussion of how to change these names.

  6.0 Command Summary by Class

This section lists all the commands and has some fundamentals about how and
when they should be used.  The following sections have in depth descriptions
of some of these classes of commands.  Chapter 7 has in depth descriptions
of every command.


Branching Control Commands
--------------------------
These commands affect the the logical flow of the command files.  Section
6.1 discusses this class of command in detail.  The commands:

call   clrca   end     go      if      ife     ifef    ifi     ifo     ifp     
ifs    ift     il      on      ret     xb


Quick and Dirty File Commands
-----------------------------
These commands allow some simple file manipulation.  Section 6.2 discusses
these commands in more detail.  The commands:

app    load    save


File Commands using handles
---------------------------
These commands allow some extensive file manipulation.  Section 6.2 discusses
these commands in more detail.  The commands:

astat  clall   close   frite   fstat   gbuf    open    pbuf    rdln    read
seek   tell


Other File Commands
-------------------
These commands are copies of standard DOS commands.  Section 6.2 discusses
file commands.  The commands:

del    dir     er      ld      size    ren


Communications Buffering Commands
---------------------------------
These commands are used to save incoming data so that it can be easily 
manipulated within the command language.  The individual descriptions
of these commands in section 7.0 provide more detail.

bdn    bdp     buf


String Processing Commands
--------------------------
These commands provide a variety of string and memory manipulation features.
Sections 6.4, 6.5 and 6.6 provide more detail as to their operation.

allst  cat     cpy     lwr     setbf   slen    sptr    srite   stc     stst    
upr


Connection Control Commands
---------------------------
These commands are used to establish and break connections with a host or 
another PC.

aa     c       dl      ds      kl      m


Modem Diagnostic Commands
-------------------------
These commands are used to test and determine the type of modem in the PC.
The are primarily used if the modem or its configuration is suspect.

mo     mome    mv      


General Diagnostic Commands
---------------------------
These commands provide diagnostic capabilities for debugging command files,
determining what is occurring on the line and storing logs of information to
disk.

astat  dt      lf      ss      st      svals   td      tr      vals


General Commands
----------------
?      *       comp    da      help    intrp   p       redir   rstrt   tk      
uncmp  w


DOS Call commands
-----------------
These commands allow the D3-3780 command files to call DOS and execute batch
and/or executable programs.  See section 6.3 for more information on these
commands.

>      .       /


Sending Commands
----------------
These commands send information to the remote computer and sometimes request
information back from the remote.

rem    s       ss      svals


Receive Control Commands
------------------------
These commands control the file names and buffer conversions used for files
received.

dn      dp     w 


Screen Control Commands
-----------------------
These commands control the appearance of D3-3780.  More information on how
these commands can be used to control the screen is provided in sections
6.7 and chapter 8.

cls    drite   dsup    getxt   key     lscrn   lstvs   putxt   redsp   rite    
stoff  ston    sup     undsp   unsup   vtype


Number Manipulation Commands
----------------------------
These commands are used to perform numeric calculations and assignment on
integer, character and pointer variables.

dec    inc     mov     opr


Program Termination Commands
----------------------------
These commands terminate the command file and/or D3-3780.

enz    end     ex      fq      q       qnz


Memory Allocation Commands
--------------------------
These commands allocate memory, free previously allocated memory and/or
adjust the size of previously allocated memory.  Section 6.5 discusses these
commands in detail.

alloc  allst   free    reall


System Initialization Commands
-----------------------------
These commands are used to set up and modify the system's configuration.
Chapters 7 and 9 have detailed descriptions of these commands and their
usage.

lscrn  lstvs   mseth   sdefs   setpr   sform   smask   smax    so      sptyp
tabls  vtype


6.1 Branching Control Commands

The branching commands are commands which cause a batch file to resume 
execution at another line in the file.  

call   clrca   end     go      if      ife     ifef    ifi     ifo     ifp     
ifs    ift     il      on      ret     xb


6.2  File Commands 

Section 6,0 lists three classes of file functions: "Quick and Dirty", 
"Commands using Handles" and the "Other file commands".  

We'll start with "Commands using Handles".  The first parameter in these 
commands is a number which is associated with the a specific file.  This 
number is referred to as a "File Handle".  The allowed file handles are 0 
through 9.  Before any of the handle based file operations can be used the
file must be "open"ed to associate the file with the handle (that is the sole
purpose of the "open" command).  This command creates a file if the file 
doesn't already exist or opens the file for read only if it does exist 
(this can be changed using an options parameter).  When you are through 
processing a file the "close" command is used to free up the desired handle.

There is an implied location in the "handle" based commands at which reads and
writes occur.  This location is referred to as the file pointer.  The "seek"
command is used to explicitly move the location of the file pointer and the
"tell" is used to read the location of the file pointer.  The file pointer is
advanced whenever a read or write is performed on the file.  In this way,
successive reads will continue to read through the file from beginning to end
and successive writes will continue to append data to an open file.

The quick and dirty file commands save you the trouble of having to open, 
close, etc. files.  These commands need only the file's name as a parameter.
The main drawback of the quick and dirty commands is that they can only work
on a buffer full of data at one time.  For example, there is no way to read
a part of a file which is farther in the file than the size of your buffer.
However, many operations can be done simply by using these commands.

The other file commands are essentially DOS replacements that stop you from
constantly having to shell to DOS.  There are also some alias command names
("er" for del and "ld" for dir) which are included for compatibility with the
Bsc command language.


6.3 DOS Call commands
>      .       /


6.4 Data Copying Commands
cat     cpy     setbf   srite  
load    read    gbuf    rdln   read


6.5 Memory Allocation Commands
alloc  allst   free    reall


6.6 Other pointer assignment commands
mov    stc     stst    


6.7 Format options for writing strings out

cls    drite   dsup    getxt   key     lscrn   lstvs   putxt   redsp   rite    
stoff  ston    sup     undsp   unsup   vtype

The D3-3780 command language has several commands that allow you to write
strings and numbers out.  These are:

rite        ; For writing to the screen
frite       ; For writing to a file
srite       ; For writing to a buffer

These three functions all have a similar syntax in that they all will accept
multiple parameters which can be any combination of scalars and pointers.
I'll use the "rite" function for the examples (since you can immediately
see the results of your command).

The basic syntax of the rite function is:

rite val[;ops][+val[;ops]][+val[;ops]]...

or (with brackets removed)

rite val;ops+val;ops+...

The val is any scalar or pointer and the ops consist of a string (not 
necessarily quoted) that modifies the way the val is output.

Lets start with some simple examples (remember that the "?" is a prompt):


Writing a string

  ?rite "This will be written to the screen"
  This will be written to the screen

Writing a string variable

  ?cpy %db,"This will also will be written to the screen"
  ?rite %db
  This will also will be written to the screen

Writing a scalar

  ?mov %i0,89
  ?rite %i0
  89

Writing a combination of strings and scalars

  ?rite "The number "+<h40>+" is 40 hex"    
  The number 64 is 40 hex

The last example demonstrates how values can be concatenated.  Now, lets go
over some of the formatting options.  The formatting options is a string
that has combinations of letters and numbers to precisely control the
output.  Unlike most strings, the quotes surrounding it can (normally) be 
left off.  The general form of the options is:

         [flags][width][.precision]type

Each field of the string is a single character or number signifying a 
particular format option.  The following describes each field.

Type: The 'type' character determines whether the associated argument is 
      interpreted as a character, string, or integer.  The simplest format 
      string contains only 'type' character.  
      
         D or I  Scalar     Signed decimal integer (scalar default)
         U       Scalar     Unsigned decimal integer
         O       Scalar     Unsigned octal integer
         X       Scalar     Unsigned hexadecimal integer
         C       Scalar     Single character
         S       Pointer    Only way to print a string (pointer default)

Examples:

?rite "The number "+64;d+" is "+64;x+" hex"
The number 64 is 40 hex

?rite "The signed number "+<-34>;d+" is "+<-34>;u+" in two's complement"
The signed number -34 is 65502 in two's complement

?rite "The number "+'A';d+" is an ASCII '"+65;c+"'"
The number 65 is an ASCII 'A'


Flags: An optional sequence of flag characters controls the justification of 
       output and printing of signs and blanks.  
       The flag characters available are:

   Flag                Action                           Default
   ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    Ä          Left justify the result within        Right justify
               the field width.

    +          Prefix the output value with a        Sign appears only
               + or Ä sign if it is of a signed      for negative
               type.                                 signed values(Ä)

    blank      Prefix the output value with a        No blank
               blank (ASCII 32) if the output
               values is signed and positive;
               the "+" flag overrides the blank
               flag, and a positive signed value
               will be output with a sign.

If the "+" or blank is used then the options string must be enclosed in 
double quotes (") characters to stop those signs from being interpreted as 
parameter separators.  Both these options are useful for lining up columns 
of numbers.  More than one flag can be included in the option list.

Example Using Flags (more examples using flags will be with width info):

?rite "This value will always be prefixed with a sign "+90;"+d"
This value will always be prefixed with a sign +90


Width: The optional width specifier is a decimal integer specifying 
       the minimum number of characters to print, padding with blanks 
       and zeros.  Width never causes a value to be truncated.

Examples using Width:

?rite "Wide number padded with zeros "+90;08d
Wide number padded with zeros 00000090

?rite "Wide number padded with blanks "+90;8d
Wide number padded with blanks       90

?rite "Wide number padded with blanks "+90;-8d+" left justified"
Wide number padded with blanks 90       left justified


Precision: An optional precision specifier is a decimal integer preceded by 
           a period (.) which specifies the maximum number of characters 
           printed for all or part of an output field.  It is identical to
           width for numeric output (D,I,U,O,X) but is used in strings to
           limit the length of strings which are output.  This is useful
           when limiting the size of a string.

Examples:

?cpy %db,"This is a really long string which can cause the line to overflow"
?rite "Only 5 characters will be putout '"+%db;.5s+"' ..see"
Only 5 characters will be putout 'This ' ..see

?rite "The parameter has no effect if the string is small, "+"see";.8s+" none"
The parameter has no effect if the string is small, see none

Their is one more option which does not fit among these.  An "R" can be put
anywhere in the option string to cause a carriage return after the parameter
has been printed.  As many R's can be included as you want carriage returns.

Examples using R:

?rite "This will be on one line";rs+"This will be on another"
This will be on one line
This will be on another

?rite "Two returns here";rsr+90;0r8d+"the R's can be anywhere"
Two returns here

00000090
the R's can be anywhere

That completes the explanation of formatting options.  They're a bit 
complicated but they are pretty flexible.


7.0 Alphabetical Command summary:

These names are used throughout the command descriptions for the sake of
brevity.

dest = label or line number
ptr  = any pointer type { strings or buffers }
num  = any scalar, other values are assumed
val  = Scalar or pointer
file = a filename (no wildcards)
spec = a filename (wildcards allowed)

Also, "[]" brackets are used to enclose optional parameters and "..."
ellipses are used to indicate that more similar options can follow.

Each command includes a description of the errors it can generate.  There
are several errors which can be generated by any command which takes a 
parameter.

  52  "&" not allowed on data type in "?????"
  53  Brackets not allowed in "?????"
  54  "^" on non-string "?????"
  55  Did not understand syntax (Press "?<Enter>" for help)
  56  Bad final character in "?????"
  57  Bad index in "?????", index must be a scalar
  65  Unknown Variable or Symbol and parameter not allowed together in "?????"
  66  Unknown Variable [?????]
  73  Number in "?????" must be between 0-9
 109  User Abort

Commands which do not accept parameters cannot generate these errors.  The
DOS shell commands (">", ".", "/") and comments "*" also cannot generate 
these errors.  All other commands can generate them so they will not be 
included in the individual lists of possible errors.

The branching commands (if,ifi,on,etc.) allow a command to be executed 
in place of a label.  If this is the case then the errors generated by the
command can occur as well as the errors possible from the branching command
itself.

Here Goes:

     Command: ? or help
     Purpose: Provide help for user
Restrictions: D3-3780.HLP must be available
      Syntax: ?[,D3-3780 command or page number]
    Argument: If None, provides general help
              If a number, it provides later pages of general help
              If a command, it will be a specific help about the command

The "?" by itself supplies a general help on D3-3780.  More pages will
available by typing "?,#" where "#" is a digit (0-9).  Also, a specific
help on a particular command will be available by typing "?,command".
This command cannot return an error.


     Command: > or .
     Purpose: Load a DOS shell
Restrictions: Sufficient memory must be available.
      Syntax: >[DOS command]
    Argument: If None, loads DOS shell, you must enter "exit" to return
              If a DOS command, the DOS command is executed

The ">" and "." characters are a quick way to call up a DOS shell when
running interactive.  They are not useful for batch mode since they ask
before returning back into the D3-3780.  The "/" command below is used
for that.  The ">" is mnuemonic for DOS but the "." is does not require
the use of the shift key.  Thus, either can be used.  Incidentally,
redirection and piping on the command line are supported, more on this
later.  The errors for this command are:

  50 Argument List too big
  96 Insufficient memory to process command

The 50 and 95 are the values which will be assigned to the "ei" variable.
The messages to the left will be displayed on the screen.


     Command: /
     Purpose: Load a DOS shell
Restrictions: Sufficient memory must be available.
      Syntax: /[DOS command]
    Argument: If None, loads DOS shell, you must enter "exit" to return
              If a DOS command, the DOS command is executed

Same as ">" and "." above except it returns immediately without asking.
This is useful in batch mode or as a remote command.  Also if the command
does not produce results that you want to view before returning.  Errors 
are the same as ">" and "." above.


     Command: *
     Purpose: Comment
Restrictions: None
      Syntax: *[Any thing you want out here up to 200 characters]
    Argument: Nothing or a string containing anything

Just a comment.  If the screen output is suppressed then the comments will
not be seen either.  See the "rite" command for displaying information for 
batch file spectators.  No errors generated for this command.


     Command: aa
     Purpose: Set the modem to answer the phone.
Restrictions: The modem cannot be online already
      Syntax: aa[,+timeout] or [,hh:mm]
    Argument: If None, waits forever
              If a "+" with timeout number, waits for timeout 10 seconds
              if a 24 hour timeout time, waits until that time

This sets the modem to answer the phone.  The command can, optionally, be
made to timeout at a certain time (24 hour time) or after a certain number
of 10 second intervals.  The error indicator will be set appropriately
if the timeout occurs.

Errors:
   7  This command cannot be performed while online
  29  Timeout expired
  91  The time designation should contain a colon


     Command: alloc
     Purpose: Allocates memory and assigns a pointer to point to it
Restrictions: None
      Syntax: alloc ptr,num
 Arguments 1: Pointer which will be point to the memory
           2: The number of bytes to allocate

This command is used to allocate a memory buffer.  The first value is any
pointer variable and the second value is the number of bytes to allocate.
This is useful to make buffers in which to load parts of files and/or to
make buffers in which received data will be stored.  If ptr is not NULL 
(equal to "nu") then the memory pointed to by it will automatically be 
freed.  See section 5.7 for more information on the use of pointers.

Errors:
  84  Parameter [?????] should be a pointer variable
  86  This command requires 2 parameter(s)
  87  Parameter [?????] should be a scalar
  93  Insufficient internal memory to process command


     Command: allst
     Purpose: Allocates memory for a string and a assigns pointer to it
Restrictions: None
      Syntax: allst ptr,ptr
 Arguments 1: Pointer which will point to the string
           2: String or pointer to be copied into allocated memory

This command is used to allocate memory for a string and copy the string 
into the allocated memory.  The "cpy" command is similar except the pointer 
variable must already be pointing to some allocated memory.  If ptr is not 
NULL (equal to "nu") then the memory pointed to by it will automatically be 
freed.  See section 5.7 for more information on the use of pointers.

Errors:
  84  Parameter [?????] should be a pointer variable
  85  Parameter [?????] should be a string constant or pointer
  86  This command requires 2 parameter(s)
  93  Insufficient internal memory to process command


     Command: app
     Purpose: Appends data pointed to by ptr for file named by file
Restrictions: None
      Syntax: app ptr,file[,val]
 Arguments 1: A pointer to a buffer (to write)
           2: filename to write out to
           3: If None, copies until a 0 is found
              if a scalar then the value is the number of bytes to write
              if a pointer then the value will be the upper bound

The "app"end command is a quick and dirty "add data to a file" command.  It
is especially useful if you want to log information to file.  This command
saves you the trouble of having to open the file, write to it and then
close it.  The third optional parameter is either a length (scalar) or a
pointer to the first location past the end of the buffer.  If neither is
specified then the command will write until a hex 0 is found in the buffer.
The pointer technique is useful if you set up the series of p? variables to
point into an allocated buffer for different purposes.  For example:

app %p3,dummy.txt,%p4

If p4 were the next designated data area this would cause the entire p3
data area to be written out but none of p4.

The "!" operator is useful here to write the contents of a binary buffer to
a file.  For example:

alloc %p3,100
load %p3,binfile.exe
app %p3,dummy.bin,!p3

This would write 100 bytes to the end of file dummy.bin regardless of the 
contents of %p3.  Also, the source pointer need not have been the pointer 
used with the "alloc" or other memory allocation command.  When pointers 
are assigned values then the implied lengths are to the end of the data 
area to which they point.  For example:

alloc %p0,1000
mov %p1,&p0[900]
load %p1,binfile.exe
app %p1,dummy.bin,!p1

This has the same effect as the prior example since the implied length of
the p1 variable is 100.

The "ptr" parameter can also be an integer.  If "ptr" is an integer then its 
ASCII equivalent value will be written to the file.  That is, the if the 
integer is a 99 the string "99" will be written to the file.  The "val" 
parameter is irrelevant if "ptr" is not a scalar type.  

Errors:
   2  Unable to open file [?????]
  69  Length pointer [%s] must point into the memory buffer
  74  At least 2 parameter(s) required for this command
  80  Parameter [??????] must be a filename
  82  Length Parameter [?????] cannot be a file or label
  98  The filename cannot include wildcards


     Command: astat
     Purpose: Displays the size and time and data of all open files.
Restrictions: None
      Syntax: astat     

This command gives a list containing the file size, and time and date of
last modification of all the currently open files.  This command does
not return any errors.


     Command: bdn
     Purpose: Sets up buffer for data coming to the punch.
Restrictions: None
      Syntax: bdn buf[,val][;op]     
Argument buf: Pointer to the buffer in which to put data
         val: if None length array is used
              if a scalar then the value is the number of bytes to write 
              if a pointer then the value will be the upper bound
          op: A "L" to get the last of the receive or blank for the first

This command allows you to set up a buffer which will receive data from the
punch.  The regular destination (set with dn) will still receive the data but
an extra copy is put in this buffer.  The optional "val" specifier indicates
the length of the buffer.  If it is a scalar then the value is used as the
length and if it is a pointer it should point to the first location beyond 
the buffer.  If it is blank then the length array l? will be used.  If l? is
0 then the area until the end of the db buffer will be used.  Specifying a
zero length will disable the buffer pointer.

The op parameter is either a "L" or nothing.  The "L" stands for last.  If 
the size of the reception is larger than the buffer then, by default, the 
buffer will take the first values from the reception and stop saving them 
after that.  If the "L" option is selected then new data will wrap around 
and overwrite the old data.  In this way the newest data will be in the 
buffer.  After the reception the buffer will automatically be unwrapped so 
that the last data in the file occurs in chronological order from beginning 
to end in the buffer.

Errors:
  69  Length pointer [%s] must point into the memory buffer
  77  Buffer pointer [?????] must have memory allocated to it
  82  Length Parameter [?????] cannot be a file or label
  94  Label not allowed in parameter [?????]
 100  Optional parameter must be 'L' or nonexistent


     Command: bdp
     Purpose: Sets up buffer for data coming to the printer.
Restrictions: None
      Syntax: bdp buf[,val][;op]     
Argument buf: Pointer to the buffer in which to put data
         val: if None length array is used
              if a scalar then the value is the number of bytes to write 
              if a pointer then the value will be the upper bound
          op: A "L" to get the last of the receive or blank for the first

Same as bdn except for the printer rather than punch.


     Command: buf
     Purpose: Sets up buffer for incoming data.
Restrictions: None
      Syntax: buf buf[,val][;op]     
Argument buf: Pointer to the buffer in which to put data
         val: if None length array is used
              if a scalar then the value is the number of bytes to write 
              if a pointer then the value will be the upper bound
          op: A "L" to get the last of the receive or blank for the first

This option is similar to the bdn and bdp options except that it buffers both
of them.  It can be used at same time as the bdn and bdp commands.  Thus,
it is possible to have data copied into two different buffers (plus its
destination) during the same reception.  It may be useful to use both at the
same time to catch both the first and last parts of a reception (by 
specifying the "L" option for one buffer).  The errors are the same as in 
bdn command.


     Command: c
     Purpose: Takes modem off hook in private line mode.
Restrictions: Must have access to MODEMS.DTA file, the modem cannot be online
      Syntax: c

This option allows the modem to communicate in private line mode.

Errors:
   7  This command cannot be performed while online
  11  The modem was unable to train


     Command: call
     Purpose: Calls another command file or a subroutine in the current file
Restrictions: Batch mode only
      Syntax: call dest or file
    Argument: if a file, that file will become the new command file.
              if a label, that label will be branched to
              if a scalar, the line number will be branched to

This is a command allows you to make a super-command either in the same file
or in other files.  If the call is to another file then the processing will
return to the line following the call once the batch file has been executed.
If the call is within the same file then the processing will return to the
line following the call when a "ret" return instruction is processed.

Errors:
  58  Label [?????] not found
  59  Line number ??,[??] exceeds command file length
  67  This command is only allowed in batch mode
  68  Command file read error
  79  The destination parameter [?????] must be label or line number
  93  Insufficient internal memory to process command
  97  Could not return to file \"???????\".


     Command: cat
     Purpose: Concatenates two strings.
Restrictions: None
      Syntax: cat destptr,sourceptr
  Argument 1: Destination string
           2: Source string

Copies the string pointed to by sourceptr onto the end of the string pointed 
to by destptr.

Errors:
  77  Buffer pointer [?????] must have memory allocated to it
  85  Parameter [?????] should be a string constant or pointer
  86  This command requires 2 parameter(s)


     Command: clall
     Purpose: Closes all open files
Restrictions: None
      Syntax: clall

Closes the file for every handle.  No errors are possible.


     Command: close
     Purpose: Closes a file
Restrictions: None
      Syntax: close handle
    Argument: The handle of the file to close

This command closes the file specified by handle.

Errors:
  20  The file specified by handle [?????] is not open
  86  This command requires 1 parameter(s)


     Command: clrca
     Purpose: Clears the unreturned calls
Restrictions: None
      Syntax: clrca

This command clears all unreturned calls.  It is useful when an error occurs
in a subroutine and you want to branch to a general purpose error handler.
There are no possible errors returned for this command.


     Command: cls
     Purpose: Clears the command window
Restrictions: None
      Syntax: cls

This command clears the command window and puts the prompt at the top line.
No errors are possible with this command.


     Command: cpy
     Purpose: Copies a buffer or string to another location.
Restrictions: None
      Syntax: cpy destptr,sourceptr[,val]
  Argument 1: Destination pointer
           2: Source pointer
           3: If None, copies until a 0 is found
              if a scalar then the value is the number of bytes to write 
              if a pointer then the value will be the upper bound

The area pointed to by destptr will receive the data pointed to by 
sourceptr.  The optional "val" parameter is used to set the number of 
characters to be copied.  If it is a number then the number will be 
the maximum.  If it is a pointer then it will be the first location after 
destptr which will not be allowed to receive a character.  If no "val" is 
specified then the copy will go on until a hex 0 is encountered.  The no 
"val" technique is used to copy strings.

Note: The buffer must have memory allocated to it already.  Use the "allst"
      command if you need to allocate memory for the string as well as copy 
      it.

Errors:
  69  Length pointer [%s] must point into the memory buffer
  74  At least 2 parameter(s) required for this command
  77  Buffer pointer [?????] must have memory allocated to it
  82  Length Parameter [?????] cannot be a file or label
  85  Parameter [?????] should be a string constant or pointer


     Command: da
     Purpose: Puts the modem in Data mode.
Restrictions: None
      Syntax: da

This has no effect now since the "tk" command is not implemented yet.  When 
the tk command is implemented then this command will put the modem back in 
control of the line.  This command will not currently generate any errors.


     Command: dec
     Purpose: Decrements either a scalar or a pointer variable.
Restrictions: None
      Syntax: dec val
    Argument: Scalar or pointer to decrement (cannot be db)

This command will reduce the value of a scalar (i0-i9,bl,db[5],etc.) by one.
It will also decrement the value of pointer variable.  This will cause the
pointer to point one character earlier in the buffer.

Error:
  83  Parameter [?????] should be a pointer or scalar variable


     Command: del (also er)
     Purpose: Deletes one or more files
Restrictions: None
      Syntax: del spec
    Argument: File specification which can include a path and/or wildcards

This command will delete any files indicated by the file specification.  A
path can be included and it will not generate a "Are you sure" message if
"*.*" is used.  Thus, "del *.*" can be used in batch mode without user
intervention.  This is identical to the "er" command.

Errors:
   5  Unable to delete file [?????]
  86  This command requires 1 parameter(s)
  89  Parameter [?????] should be a filename or file specification


     Command: dir (also ld)
     Purpose: Does a wide format directory
Restrictions: None
      Syntax: dir spec
    Argument: File specification which can include a path and/or wildcards

This is just like the DOS dir /w command.  Any valid DOS path and wildcards
can be used.

Errors:
  89  Parameter [?????] should be a filename or file specification


     Command: dl
     Purpose: Dials a number that is in a string or file.
Restrictions: The modem cannot be online
      Syntax: dl string or file
    Argument: If a string, then the number in the string is dialed
              If a file then a number is read from the file and is dialed

This dials a number out of a file or in a string.
   2  Unable to open file [?????]
   4  Received busy signal
   7  This command cannot be performed while online
  11  The modem was unable to train
  19  No tone detected
  61  Error in phone number
  86  This command requires 1 parameter(s)
  98  The filename cannot include wildcards
 104  Parameter [?????] must be a string of filename



     Command: dn
     Purpose: Defines the file and options to be used for the punch.
Restrictions: None
      Syntax: dn,file[,ops]
  Argument 1: The filename to which punch data will be written
           2: If none, default naming and buffer types
              If a string, the characters will set the options

The define punch specifies the filename to which punch data will be written.
There are several special filenames:

CON          : This writes data to the screen.  Works!
NUL          : This throws away all the incoming data.
PRN          : This writes data to the default printer (parallel port).  This 
               option is not fully supported yet.  It will be in the final 
               revision however (the current revision will accept the 
               parameter but will fail if large files are to be received).
LPT1 and LPT2: This is the similar to PRN except that the specific parallel 
               port is identified.
AUX          : This refers to the first serial port (same as COM1).  It is 
               used to send data to a serial printer.  It not supported in
               this revision.
COM1 and COM2: These are supposed to send data out the serial ports but they 
               are also not supported yet.

The options that go with the the dn command are used to set the types of
buffer conversions and to enable or disable auto-naming.  The four types
of buffer conversions are the same ones as described in section 2.2.  The
auto-naming option determines if multiple files are received between "dn"
definitions whether they will be concatenated or whether new files will be
created by creating or incrementing a numeric extension.  The options 
consist of a series of characters, each of which has special meaning.
There are two forms of options for this command the (shorter) normal ones
and the more extensive form which can set the options in more possible 
ways.
The normal options are:

  S - To set the standard mode to the "Vary" buffer type.
  T - To set the transparent mode to the "Fixed" buffer type.
  B - To set the transparent mode to the "Binary" buffer type.
  C - To turn auto-naming off (Concatenate).
  N - To turn auto-naming on.

Less common short options:
  H - To set both standard and transparent to the "Hex" buffer type.
  V - To set both standard and transparent to the "Vary" buffer type.
  F - To set both standard and transparent to the "Fixed" buffer type.

Examples:

dn file.txt,s      ; Specifies standard with vary buffer type expected.
dn file.txt,tc     ; Specifies transparent with fixed buffer type expected
                     and disables auto-naming.
dn file.txt,nb     ; Specifies transparent with binary buffer type expected
                     and disables auto-naming.

Note: The order of the options is not important when using the short form.

The long form uses the "S" and "T" followed by either "V", "F", "B" or "H"
to indicate the buffer type and the mode in which it is used precisely.

For example:

dn file.txt,sftb   ; Specifies that fixed format be assumed for standard 
                     receptions and that binary format be assumed for
                     transparent receptions.

dn file.txt,nshtf  ; Specifies auto-naming and that the hex buffer type be 
                     used for standard receptions and that the fixed format
                     be used for transparent receptions.

In general the "V", "F", "B" and "H" options will refer to the reception type
of the nearest "S" or "T" to its left (usually the preceding character).  The
"N" and "C" options can be placed anywhere without having any affect.

Errors:
  80  Parameter [?????] must be a filename
  94  Label not allowed in parameter [?????]
  98  The filename cannot include wildcards
 101  The option [????] is not valid


     Command: dp
     Purpose: Defines the file and options to be used for the printer.
Restrictions: None
      Syntax: dp,file[,ops]
  Argument 1: The filename to which printer data will be written
           2: If none, default naming and buffer types
              If a string, the characters will set the options

Same as punch (above) except for printer.


     Command: ds
     Purpose: Disconnects the line in an orderly fashion.
Restrictions: The modem must be online
      Syntax: ds

This command sends a message to the remote 3780 that it is going to
disconnect and then drops the line.  The disconnect is automatically
performed if you exit with the "Q" command.  If you cannot send the
disconnect message to the remote then the line can be dropped with
the "fq" command.

Errors:
   6  This command cannot be performed unless online
  15  The modem is not able to transmit, It will not raise CTS
  18  The modem is not able to transmit, SCC TX buffer error


     Command: dsup
     Purpose: Suppresses direct video output
Restrictions: None
      Syntax: dsup

Suppresses all direct video writes.  This includes:
  1. All status variables
  2. The screen (after a redsp)
  3. DRITE writes?
  4.?

     Command: dt
     Purpose: Dumps the contents of a trace buffer to the disk.
Restrictions: Not supported yet
      Syntax: dt,file
    Argument: File to dump trace to

This command is used in conjunction with the tr command to capture and
write a hex dump of the line activity to the disk.  It is not supported yet
but will be soon.  No errors are generated yet.


     Command: end
     Purpose: Terminate processing of the current command (batch) file.
Restrictions: None
      Syntax: end

This command is used to prematurely return from a command file.  It differs
from the "ex" command in that control will return to the calling batch file
and D3-3780 will continue.  "ex" will terminate D3-3780.  This command is
identical to D3-3780 reaching the end of a command file.  No errors are
possible with this command.


     Command: enz
     Purpose: Conditionally, exiting the package without dropping the line.
Restrictions: None
      Syntax: enz

If there was an error on the prior command then this will exit D3-3780 with
the DOS errorlevel set to the same value as the D3-3780 error.  If online,
the line will remain active.  No possible errors with this command.


     Command: er (or del)
     Purpose: Deletes one or more files
Restrictions: None
      Syntax: er spec
    Argument: File specification which can include a path and/or wildcards

Identical to the "del" command above.


     Command: ex
     Purpose: Exit to DOS without dropping line.  Optionally, set errorlevel.
Restrictions: None
      Syntax: ex[,errorlevel]
    Argument: If none, errorlevel is 0
              If a scalar, the errorlevel is its value

This command will exit D3-3780 without breaking the connection with the
other 3780.  If a value is specified the DOS errorlevel will be set to that
value.  Otherwise, the errorlevel will be 0.

Errors:
  70  The value [?????] of parameter 1 is too big, maximum allowed is 255
  71  The value [?????] of parameter 1 is too small, minimum allowed is 0
  87  Parameter [?????] should be a scalar


     Command: free
     Purpose: Give back memory that is no longer needed.
Restrictions: None
      Syntax: free ptr
    Argument: A pointer to memory that was allocated with ALLST or ALLOC.



     Command: fq
     Purpose: Drop the line and go to DOS without hesitation.
Restrictions: None
      Syntax: fq

This command will leave drop the line without informing the other 3780 that
it is about to do so and will then exit to DOS.  No errors are possible.


     Command: frite
     Purpose: Format and write data to an open file.
Restrictions: None
      Syntax: frite han,val[;ops][+val[;ops]]...
Argument han: The handle of the file to write to
         val: If a scalar, the value is written out
              If a string, the string is written out
         ops: If none, default display format
              If string, characters determine format

The frite command allows the batch programmer to write strings and variable
values out to the disk.  The first option is the file handle and the
parameters following parameters are the same as those for the "rite" command
as described in section 5.7 above.

Errors:
  20  The file specified by handle [?????] is not open
  70  The value [?????] of parameter 1 is too big, maximum allowed is 9
  71  The value [?????] of parameter 1 is too small, minimum allowed is 0
  74  At least 2 parameter(s) required for this command
  87  Parameter [?????] should be a scalar
  90  Parameter [?????] should be a pointer or scalar
  94  Label not allowed in parameter [?????]


     Command: fstat
     Purpose: Displays information on an open file
Restrictions: None
      Syntax: fstat handle
    Argument: The handle of the file to use

This option is useful to display size, time and date information on a file
and to check if a handle is in use.  If you call fstat on a handle that
does not have a file associated with it then it will generate an error.
The "if" command can then be used to branch based on that error.

Example:
  ?open 0,d3-3780.exe
  File "D3-3780.EXE" opened in "R" mode.
  ?fstat 0
  Size is 75804 bytes, Time stamp is Tue May 23 13:14:02 1989

Errors:
  20  The file specified by handle [?????] is not open
  70  The value [?????] of parameter 1 is too big, maximum allowed is 9
  71  The value [?????] of parameter 1 is too small, minimum allowed is 0
  86  This command requires 1 parameter(s)
  87  Parameter [?????] should be a scalar


     Command: gbuf
     Purpose: Get data from file and put it into a buffer.
Restrictions: None
      Syntax: gbuf handle,buf[,val]
  Argument 1: The handle of the file to use
           2: A pointer to the location where the data will be copied
           3: if None length array is used
              if a scalar then the value is the number of bytes to read
              if a pointer then the value will be the upper bound

The gbuf command is used to read data from a file.  The "buf" value is the
location of the buffer in which to read the data.  The optional "val" is
the number of bytes to read if a scalar and the location to read up to if
a pointer.  This is useful if you are using the same buffer to store two
different things.  If the value of the next pointer into the buffer is
used here then the memory that it points two will not be overwritten.

If the optional "val" parameter is not included then "gbuf" will read to 
the length buffer (the value used when memory was allocated to the buffer).

The "buf" parameter can also be an integer or in individual character in a
buffer.  If "buf" is an integer or character then a value will be read from 
the file and assigned to the scalar.  The "val" parameter is irrelevant in 
this case since one character is read for character types and two for 
integers.

Errors:
  20  The file specified by handle [?????] is not open
  21  At end of file [?????], can't read anymore
  69  Length pointer [%s] must point into the memory buffer
  70  The value [?????] of parameter 1 is too big, maximum allowed is 9
  71  The value [?????] of parameter 1 is too small, minimum allowed is 0
  74  At least 2 parameter(s) required for this command
  76  The parameter [?????] cannot be assigned to
  77  Buffer pointer [?????] must have memory allocated to it
  82  Length Parameter [?????] cannot be a file or label
  87  Parameter [?????] should be a scalar
  90  Parameter [?????] should be a pointer or scalar


     Command: getxt
     Purpose: Saves a portion of the screen in a dynamically allocated buffer
Restrictions: None
      Syntax: getxt ptr,roupper,colupper,rolower,collower
  Argument 1: A pointer which will point to the stored screen
           2: The highest row to be stored
           3: The leftmost column to be stored
           4: The lowest row to be stored
           5: The rightmost column to be stored

The rows and columns are numbered starting at 1,1 in the upper left corner.


     Command: go
     Purpose: Resume execution somewhere else in the command file
Restrictions: Batch only
      Syntax: go dest
    Argument: The label or line number to branch to

This is a simple branching instruction.  It will take either a label
or a line number.  It also will take the letter "Q" to exit.  This is
not very useful in this instruction since a "Q" by itself would have the
same effect.

Errors:
  58  Label [?????] not found
  59  Line number ??,[??] exceeds command file length
  67  This command is only allowed in batch mode
  68  Command file read error
  78  The destination parameter [?????] cannot be a filename


     Command: help[,command]
     Purpose: Same as "?"
Restrictions: None



     Command: if
     Purpose: Conditionally, resume execution somewhere else
Restrictions: Batch only
      Syntax: if errdest,noterrdest
  Argument 1: If none, drop through on error
              If label or line number, branch on error
           2: If none, drop through on no error
              If label or line number, branch on no error

This can be read as if (error) then go to dest else go to noterrdest.  The first
branch will be executed if the prior instruction resulted in an error.  If
the second branch exists a non-error will cause it to be traversed.  If the
second branch does not exist then the next line in the command file will be
executed.  In all the branching instructions, a blank branch indicates go
to the next line for execution.  This instruction is the only instruction 
which is affected by the "il" command.  The "il" command is used to limit 
the number of times a negative branch is executed.  A complete explanation 
will be given with that command.

Note: The prior instruction is meant literally here.  An intervening comment
      will reset the error value.  If you want to have intervening commands
      then save the ei value in an i0-i9 variable and branch off it later.

Same errors as "go" command above plus:
  13  Loopcount expired


     Command: ife
     Purpose: Check for existence of file
Restrictions: Batch only
      Syntax: ife spec,existdest,notexistdest
  Argument 1: Filename which can contain a path and wildcards
           2: If none, drop through if file exists
              If label or line number, branch if file exists
           3: If none, drop through if file doesn't exist
              If label or line number, branch if file doesn't exist

This would read "if spec exists then go to dest else go to dest2.  The spec
can contain wildcards and a pathname.

Same errors as "go" command above plus:
  74  At least 1 parameter(s) required for this command
  89  Parameter [?????] should be a filename or file specification


     Command: ifef
     Purpose: Check for end of file condition
Restrictions: Batch only
      Syntax: ifef handle,eofdest,noteofdest
  Argument 1: The handle of the file to check for end of file
           2: If none, drop through if end of file
              If label or line number, branch if end of file
           3: If none, drop through if not end of file
              If label or line number, branch if not end of file

This would read "if at the end of file handle then go to dest else go to 
dest2".  When file input/output is performed on files using handles then
a file pointer is maintained by the system.  This file pointer tells the
system where to read from or write to.  The "end of file" condition is 
when that file pointer is at the end of the file.  Thus, when reading a 
file the "end of file" condition means that there is no more file to be 
read.  If the file has not been opened then eofdest will be branched to.

Same errors as "go" command above plus:
  70  The value [?????] of parameter 1 is too big, maximum allowed is 9
  71  The value [?????] of parameter 1 is too small, minimum allowed is 0
  74  At least 2 parameter(s) required for this command
  87  Parameter [?????] should be a scalar


     Command: ifi
     Purpose: Check for two strings or scalars being identical
Restrictions: Batch only
      Syntax: ifi lval=rval,equdest,diffdest
Argument 1&2: The values to be compared
           3: If none, drop through if identical
              If label or line number, branch if identical
           4: If none, drop through if not identical
              If label or line number, branch if not identical

This would read "if lval is identical to rval then go to equdest else go to 
diffdest".  If lval and rval are pointers then a string compare is performed.
If lval and rval are scalars then the values are compared.

Same errors as "go" command above plus:
  74  At least 3 parameter(s) required for this command
  95  Pointer and scalar operands cannot both be present in this command


     Command: ifo
     Purpose: Check if online
Restrictions: Batch only
      Syntax: ifo onlinedest,offlinedest
  Argument 1: If none, drop if online
              If label or line number, branch if online
           2: If none, drop through if offline
              If label or line number, branch if offline

A simple check to determine if the modem is online.  This is useful after
"W" commands to determine if the line has been dropped.  It may also come
in to check after an auto-answer if the line stayed up.  Same errors as 
"go" command above.


     Command: ifp
     Purpose: Check the type of the last reception
Restrictions: Batch only
      Syntax: ifp errdest,prindest,punchdest
  Argument 1: If none, drop through if error
              If label or line number, branch if error
           2: If none, drop through if last receive was to printer
              If label or line number, branch if last receive was to printer
           3: If none, drop through if last receive was to punch
              If label or line number, branch if last receive was to punch

This would read "If an error during reception go to errdest else if last
reception was to the printer go to prindest else go to punchdest".  The
error branch is only in reference to the command immediately preceding the
"ifp" command but the other two branches will go back to the last "W" 
command that was executed.  The "rt" variable can be useful for similar for
similar branching operations.  Same errors as "go" command.


     Command: ifs
     Purpose: Compare two strings up until the end of the leftmost string
Restrictions: Batch only
      Syntax: ifs lstr=rstr,equadest,diffdest
Argument 1&2: The strings to be compared, comparison is to end of left string
           3: If none, drop through if a match
              If label or line number, branch if a match
           4: If none, drop through if not a match
              If label or line number, branch if not a match

This command is useful for checking the start of a string for a match.  If
a long string is stored in a buffer then the value on the left can be a
short version which is large enough to distinguish it from the other 
possibilities.  This compare is case insensitive.

Same errors as "go" command above plus:
  74  At least 3 parameter(s) required for this command
  85  Parameter [?????] should be a string constant or pointer
  95  Pointer and scalar operands cannot both be present in this command


     Command: ift
     Purpose: Compare time stamps of files
Restrictions: Batch only
      Syntax: ift rfile=lfile,equadest,rfilenewerdest,lfilemewerdest
Argument 1&2: The files to be compared
           3: If none, drop through if a match
              If label or line number, branch if a match
           4: If none, drop through if rfile is newer than lfile
              If label or line number, branch if rfile is newer than lfile
           5: If none, drop through if lfile is older than rfile
              If label or line number, branch if lfile is older than rfile

This command is for comparing the timestamps of files.  If one (or both) of 
the files does not exist then it will drop through.

Same errors as "go" command above plus:
   2  Unable to open file [?????]
  74  At least 3 parameter(s) required for this command
  80  Parameter [??????] must be a filename
  98  The filename cannot include wildcards


     Command: il
     Purpose: Set a negative branch limit for the "if" command
Restrictions: None
      Syntax: il loopcount
    Argument: The maximum number of times to execute the negative branch
              of an "if" command

This command was mainly offered to reduce the pain that users converting
from BSC will experience.  The "if" command is the only one which checks
this value.  If you set a value with "il" then its value will be decremented
each time the negative branch of an "if" is executed.  On the count which
reaches 0 the "if" will drop through rather than branch.

Errors:
  87  Parameter [?????] should be a scalar


     Command: inc
     Purpose: Increment a scalar or pointer
Restrictions: None
      Syntax: inc val
    Argument: The scalar or pointer to be incremented

This command simply increments a scalar or pointer.  Incrementing a pointer
will simply make it point to the next (to the right) character in the
buffer.

Error:
  83  Parameter [?????] should be a pointer or scalar variable


     Command: intrp
     Purpose: Interpret a string as if it were a command
Restrictions: None
      Syntax: intrp str
    Argument: The string to be interpreted.

This command takes the value in a string and processes it as the command.
This can be used in a subroutine to get the effect of passing a pointer to
a command.  The calling function can load a command into a predefined
buffer and the subroutine can used "intrp" to execute the command.

Another use of this functions is to interpret commands that are created in
a buffer.  This be can useful for the two DOS shell commands.  The DOS shell
commands take there arguments literally (%i0, %p0, etc. are not converted
to there equivalent values).  If you want to use internal variables on the
command line of one of these commands you can create a command with the
"srite" command and then process it with intrp.

Example:

  srite %db,"/copy file.jnk file2."+%i0;03d
  intrp %db

This would copy the file "file.jnk" to a file with "file2" primary and the
number in %i0 for the extension.

Errors:
  85  Parameter [?????] should be a string constant or pointer
  + The errors that the command can generate


     Command: key
     Purpose: Display a string and then get a key from user
Restrictions: None
      Syntax: key num[;op],val[;ops][+val[;ops]]...
Argument num: An integer or character variable which will be assigned a key
          op: if op is a c num is assigned a character else an integer
         val: If a scalar, the value is written out
              If a string, the string is written out
         ops: If none, default display format
              If string, characters determine format

This command is used to construct interactive command files.  The "num"
argument receives the result of a stroke from the keyboard.  A keystroke
result consists of 2 things; the character the key generated and the scan
code of the key.  If the num is an integer (i0-i9) then the high byte will
be the scan code and the low byte will be the character.  The scan code is
required to check for special keys (function keys, arrow keys, etc.).  The
high byte being non-zero will cause comparisons to character constants ('A',
'B','C',etc.) to fail.  Set the value of "op" to "c" if you are not trying
to decode special keys.  The other parameters are just like those to the
rite command.  They will display on the screen prior to the retrieving of
a key.

Note: An appendix will list the scan code of all the keys on the keyboard.

Errors:
  88  The parameter [?????] cannot be assigned a scalar
  90  Parameter [?????] should be a pointer or scalar
  94  Label not allowed in parameter [?????]
 100  Optional parameter must be 'C' or nonexistent


     Command: kl
     Purpose: Stop current activity
Restrictions: None
      Syntax: kl

The "kl" command is used to terminate a send, receive or auto-answer before
it is complete.

Error:
   8  No process in progress to kill


     Command: ld (also dir)
     Purpose: Does a wide format directory
Restrictions: None
      Syntax: ld spec
    Argument: File specification which can include a path and/or wildcards

Same as "dir" above.


     Command: lf
     Purpose: Causes record of screen I/O to be echoed to disk
Restrictions: Batch only
      Syntax: lf file
    Argument: File name or NUL to disable listing file

The list file command causes the commands and other values which are 
displayed in the command window to be written to disk also.  This does not
stop the information from displaying on the screen also (use "sup" for that).
If the file already exists the "lf" command will cause the additional data
to be appended to it.

Errors:
   2  Unable to open file [?????]
  80  Parameter [??????] must be a filename
  98  The filename cannot include wildcards


     Command: load
     Purpose: loads buffer pointed to by ptr from file named by file
Restrictions: None
      Syntax: load ptr,file[,val]
 Arguments 1: A pointer to a buffer (to read)
           2: filename to read from
           3: if None, buffer length is used
              if a scalar then the value is the number of bytes to write 
              if a pointer then the value will be the upper bound

This is a quick and dirty load buffer command.  It save the hassle of
having to open and then read it.  The length determination is similar
to the other commands.

The "ptr" parameter can also be an integer.  If "ptr" is an integer then 
ASCII equivalent value will be read from the file and assigned it.  That is,
the if the file contains the string "99" the value 99 will be assigned the
integer.  

The "ptr" parameter can also be an individual character.  If this is the 
case then the first character in the file is read into it.

The "val" parameter is irrelevant if "ptr" is not a scalar type.

Errors:
   2  Unable to open file [?????]
  69  Length pointer [%s] must point into the memory buffer
  76  The parameter [?????] cannot be assigned to
  77  Buffer pointer [?????] must have memory allocated to it
  80  Parameter [??????] must be a filename
  82  Length Parameter [?????] cannot be a file or label
  90  Parameter [?????] should be a pointer or scalar
  98  The filename cannot include wildcards


     Command: lscrn
     Purpose: Loads direct memory screen from disk
Restrictions: None
      Syntax: lscrn file
    Argument: File which contains a direct write screen


     Command: lsvts
     Purpose: To load the status variable format strings
Restrictions: None
      Syntax: lwr val
    Argument: If a filename then the file contains the format strings
              If a label then the label is the location in the file of
                the format strings.


     Command: lwr
     Purpose: Makes a string of scalar lowercase
Restrictions: None
      Syntax: lwr val
    Argument: If a string the whole string will be made lowercase
              If an integer or character just the character will be made 
                lowercase

This command is just like is sounds.  Characters that are non-alphabetic or
already are lower case are not affected.

Error:
  76  The parameter [?????] cannot be assigned to
     Command: m
     Purpose: Allows the performing of a manual connect
Restrictions: The modem cannot be online
      Syntax: m

This command is used when you want to manually connect with the remote
modem and then switch the local modem online.  It is mainly useful for
diagnostic purposes when having trouble auto-dialing.  Manually
connecting is a three part process:
  1. Enter the "m" command
  2. Dial the required number and listen for answer back tone
  3. Before the tone has stopped press the "Enter" key

Errors:
   7  This command cannot be performed while online
  11  The modem was unable to train


     Command: mo
     Purpose: Gets and displays the modem's options
Restrictions: The modem cannot be online
      Syntax: mo

This command is also primarily diagnostic.  It performs a query of the
modem asking it to return the values of the options.  Since these options
are in hex they are not very useful.  If the modems data file is available
this command will be made to display the names for the values.  I have not
implemented this feature yet

Errors:
   7  This command cannot be performed while online
  15  The modem is not able to transmit, It will not raise CTS
  18  The modem is not able to transmit, SCC TX buffer error
  75  Error interfacing modem [?????]


     Command: mome
     Purpose: Sends and optionally receives a message from the modem
Restrictions: The modem cannot be online
      Syntax: mome str[;op]
  Argument 1: The string is a hex string for the modem to accept
           2: if op=N then no response is expected from the modem
              if none then a response is looked for

This command is another diagnostic command.  It allows the properly informed
user to run modem self test and do several other checks.  More commands
will be added later which use modem dependent information in the MODEMS.DTA.

Errors:
   7  This command cannot be performed while online
  15  The modem is not able to transmit, It will not raise CTS
  18  The modem is not able to transmit, SCC TX buffer error
  75  Error interfacing modem [?????]
  85  Parameter [?????] should be a string constant or pointer
  94  Label not allowed in parameter [?????]
 100  Optional parameter must be 'N' or nonexistent


     Command: mov
     Purpose: Assigns a scalar or pointer a value
Restrictions: None
      Syntax: mov destval,sourceval
  Argument 1: The scalar or pointer to receive a new value
           2: The scalar or pointer value to be assigned

This is a simple assignment command.  It can be used to assign array values,
integers or pointers new values.

Errors:
  83  Parameter [?????] should be a pointer or scalar variable
  86  This command requires 2 parameter(s)
  90  Parameter [?????] should be a pointer or scalar
  95  Pointer and scalar operands cannot both be present in this command


     Command: mseth
     Purpose: Assigns values for base address and interrupt level of modem
Restrictions: None
      Syntax: mseth base,intrupt
  Argument 1: The base address of the modem (default is 300 hex)
           2: The intrupt value of the modem (default is 3)



     Command: mv
     Purpose: Used to display the modem version
Restrictions: The modem cannot be online
      Syntax: mv 

This command will perform a version request from the modem and display the
four hex bytes which are returned.  If the MODEMS.DTA file is available then
it will also display the name of the modem.  This command is primarily for
checking modem "ROM" revisions when problems occur.

Errors:
   7  This command cannot be performed while online
  15  The modem is not able to transmit, It will not raise CTS
  18  The modem is not able to transmit, SCC TX buffer error
  75  Error interfacing modem [?????]


     Command: on
     Purpose: Multy way conditional branch statement
Restrictions: Batch mode only
      Syntax: on num,lownum[;highnum][=dest],lownum[;highnum][=dest],...
Argument num: The value whose value is being compared against
      lownum: The low number in the range check
     highnum: The high number in the range check 
              if blank then num must equal lownum to execute the branch
        dest: The label or line number to branch to

This statement conditionally causes execution to begin at one of a number of
locations.  The value "num" is compared to each of the respective 
lownum;highnum pairs to determine if it is between or equal to either.  If
it is then the corresponding branch "dest" is jumped to.  If highnum is
blank then an exact match with lownum is required.  If dest is blank and the
value is in range then the on will drop through.  If "num" doesn't match any
of the ranges then the on will drop through.
  This expression is scanned from left to right and the lownum;highnum sets
can overlap or include one another.  Generally the lower ranges would occur 
earlier and the higher later.  However, the scanning order can be used to 
your advantage.  If a large range is to be checked with a few exceptions, 
the exceptions can be eliminated by ranges which are checked earlier.

Example:

on %ei,0=:onlinedest,4=:busydest,19=:notonedest,1;<h7fff>=errdest

The above example is a simple check which will branch to "onlinedest" if
ei is 0, busydest if ei is 4, notonedest if ei is 19 and errdest otherwise.

The following example demonstrates how a few values can be excluded from
a check of a larger range.

on %i0,5,7,9,11,1;100=:errordest,101;<h7fff>=:baderrdest

If the value of %i0 is 0 or below, 5, 7, 9 or 11 it will drop through.
Note: None of the expressions match 0 or below.  5, 7, 9, 11 all have
      blank destination fields.
If %i0 is none of those but between (or equal to) 1 and 100 it will branch to
errordest.
If the value is above 100 then the batch will branch to baderrdest.  

Note: The highest possible value for an integer is <h7fff>.
Also: The values lownum and highnum need not be constants.  The can be any
      scalar type.

Errors:
  67  This command is only allowed in batch mode
  74  At least 2 parameter(s) required for this command
  78  The destination parameter [?????] cannot be a filename
  87  Parameter [?????] should be a scalar


     Command: open
     Purpose: open a file
Restrictions: None
      Syntax: open handle,file[;ops]
  Argument 1: The handle of the file to use
           2: The name of a file (can include path)
           3: An option string which determine how the file will be opened.

The open command is used to open a file so that the other handle based file
commands can be used.  The handle is merely a number 0-9.  The filename is
can include a path and/or drive designation.  The options consist of a
string (quotes are optional) which contains option characters.  I'll explain
each character individually:

 "R"  Open file for reading.  The file must exist or an error will be 
      generated.  Values cannot be written to this file unless the "P" 
      option (below) is also selected.

 "W"  Open file for writing.  If the file exists then its contents will
      be destroyed.  If the "P" option is not selected then this file
      cannot be read from.

 "A"  Open file for appending.  If the file exists then the data will be
      appended to it.  If it doesn't exist then it will be created.

 "P"  "P"lus.  Used in conjunction with "R" it allows the file to be
      written to also.  If used in conjunction with "W" allows the file
      to be read from also.  Allows both reading and writing when used
      with the "A" option but will still not allow the overwriting of
      original data (writes must be two the end of the file).

 "B"  "B"inary option.  This is used if the file does not contain text.
      Normally, a carriage return-line feed pair is converted to a line 
      feed when read in and vice versa when written out.  This process 
      is suppressed when the "B" option is used.

Note: Only one of the "R", "W" and "A" options should be included.  
      combinations of more than one are not supported (the last one in
      the string will be used).

A handle must be opened before any of the operations using handles will
work properly.  Use the "fstat" command and check for an error if there
is a question about whether the handle has been opened.

Errors:
   3  Unable to open file "?????" in "?????" mode
  70  The value [?????] of parameter 1 is too big, maximum allowed is 9
  71  The value [?????] of parameter 1 is too small, minimum allowed is 0
  74  At least 2 parameter(s) required for this command
  80  Parameter [?????] must be a filename
  87  Parameter [?????] should be a scalar
  94  Label not allowed in parameter [?????]
  98  The filename cannot include wildcards


     Command: opr
     Purpose: Performs a numeric operation and assigns the result
Restrictions: None
      Syntax: opr destval,sourcenum,opchar
  Argument 1: The scalar or pointer to receive the resulting value
           2: The second operand, always a scalar
           3: A character representing the operation to be performed

This command is used for performing numeric operations on integers,
characters and pointers.  Some of the operations are not valid with
pointers.  The left argument is assigned the value resulting from the
operation being performed on both the arguments.  

For example:

  mov %i0,20
  opr %i0,5,'-'

This would result in %i0 being 20-5 or 15.

Here is an explanation of each of the valid operations and the characters
used:

  '+' : Addition, Can use scalars or pointers.
  '-' : Subtraction, destval=destval-sourcenum, Can use scalars or pointers.
  '*' : Multiplication, Scalars only.
  '/' : Division, destval=destval/sourcenum, Scalars only.
  '|' : Bitwise "or" operation, Scalars only.
  '&' : Bitwise "and" operation, Scalars only.
  '^' : Bitwise "exclusive or" operation, Scalars only.
  '%' : Modulus (remainder after a division) operation, Scalars only.
  '>' : Bitwise shift right operation.  Sourcenum is the number of bits to 
          shift.  Scalars only.
  '<' : Bitwise shift left operation.  Sourcenum is the number of bits to 
          shift.  Scalars only.

Errors:
  62  Operator '?' not recognized
  63  Operator '?' not valid with pointers or not recognized
  83  Parameter [?????] should be a pointer or scalar variable
  86  This command requires 3 parameter(s)
  87  Parameter [?????] should be a scalar


     Command: p
     Purpose: To delay for a certain interval or until a certain time.
Restrictions: None
      Syntax: p[,+timeout] or [,hh:mm]
    Argument: If None, generates an error
              If a "+" with timeout number, waits for timeout/10 seconds
              if a 24 hour timeout time, waits until that time

This is just a delay command.  The command must be made to timeout at a 
certain time (24 hour time) or after a certain number of 1/10 second 
intervals.

Errors:
  29  Timeout expired
  70  The value [?????] of parameter 1 is too big, maximum allowed is 23
  70  The value [?????] of parameter 2 is too big, maximum allowed is 59
  71  The value [?????] of parameter 1 is too small, minimum allowed is 0
  71  The value [?????] of parameter 2 is too small, minimum allowed is 0
  87  Parameter [?????] should be a scalar
  91  The time designation should contain a colon


     Command: pbuf
     Purpose: Put data from a buffer into a file
Restrictions: None
      Syntax: pbuf handle,buf[,val]
  Argument 1: The handle of the file to use
           2: A pointer to the data that will be written to the file
           3: if None, length array is used
              if a scalar then the value is the number of bytes to read
              if a pointer then the value will be the upper bound

The pbuf command is used to write data to a file.  The "buf" value is the
location of the buffer to be written out.  The optional "val" is the number 
of bytes to write if a scalar and the location of the next buffer if a 
pointer.  If the optional "val" parameter is not included then "pbuf" will 
write to the length specified by the length "l0-l9" associated with the
pointer.  If the length value is zero then it will write until the end of 
the db buffer.

The "buf" parameter can also be an integer.  If "buf" is an integer then a 
value will be read from the file and assigned to it.  The "val" parameter is 
irrelevant in this case since two characters are read for integers.

Errors:
  20  The file specified by handle [?????] is not open
  69  Length pointer [%s] must point into the memory buffer
  70  The value [?????] of parameter 1 is too big, maximum allowed is 9
  71  The value [?????] of parameter 1 is too small, minimum allowed is 0
  74  At least 2 parameter(s) required for this command
  82  Length Parameter [?????] cannot be a file or label
  87  Parameter [?????] should be a scalar
  90  Parameter [?????] should be a pointer or scalar


     Command: putxt
     Purpose: Put data from a GETXT buffer back onto the screen
Restrictions: None
      Syntax: putxt ptr
    Argument: Pointer which was used with GETXT earlier.
     Command: q
     Purpose: Drop the line and exit to DOS.  Optionally, set errorlevel.
Restrictions: None
      Syntax: q[,errorlevel]
    Argument: If none, errorlevel is 0
              If a scalar, the errorlevel is its value

This command will break the connection with the other 3780 and then exit 
D3-3780.  If a value is specified the DOS errorlevel will be set to that
value.  Otherwise, the errorlevel will be 0.

Errors:
  15  The modem is not able to transmit, It will not raise CTS
  18  The modem is not able to transmit, SCC TX buffer error
  70  The value [?????] of parameter 1 is too big, maximum allowed is 255
  71  The value [?????] of parameter 1 is too small, minimum allowed is 0
  87  Parameter [?????] should be a scalar


     Command: qnz
     Purpose: Conditionally, drop the line and exit the package.
Restrictions: None
      Syntax: qnz

If there was an error on the prior command then this will exit D3-3780 with
the DOS errorlevel set to the same value as the D3-3780 error.  If online,
the line will be dropped.

Errors:
  15  The modem is not able to transmit, It will not raise CTS
  18  The modem is not able to transmit, SCC TX buffer error


     Command: rdln
     Purpose: Get a line of text from a file and put it into a buffer.
Restrictions: None
      Syntax: rdln handle,ptr[,val]
  Argument 1: The handle of the file to use
           2: A pointer to the location where the line will be copied
           3: Specifies maximum number of characters to copy
              if None length array is used
              if a scalar then the value is the number of bytes to read
              if a pointer then the value will be the upper bound

The rdln command is used to read a line of data from a file.  The "ptr" value 
is the location of the buffer in which to read the data.  This command will,
normally, read until a carriage return-line feed pair is encountered (this
indicates the end of a line in an ASCII text file).  A subsequent read will
read the next line.  In this way a file can be read a line at a time.

The optional "val" is used to set a maximum value for the read in case a
long line is encountered.  If "val" is a scalar it is the maximum number of 
bytes to read.  If a pointer, it should be the location of the next buffer.
If "val" is not included then "rdln" will use the length specified by the 
length "l0-l9" associated with the pointer.  If the length value is zero 
then it will use the end of the db buffer.

Errors:
  20  The file specified by handle [?????] is not open
  21  At end of file [?????], can't read anymore
  69  Length pointer [%s] must point into the memory buffer
  70  The value [?????] of parameter 1 is too big, maximum allowed is 9
  71  The value [?????] of parameter 1 is too small, minimum allowed is 0
  74  At least 2 parameter(s) required for this command
  77  Buffer pointer [?????] must have memory allocated to it
  82  Length Parameter [?????] cannot be a file or label
  87  Parameter [?????] should be a scalar


     Command: read
     Purpose: Read specially formatted data from a file
Restrictions: None
      Syntax: read han,val[;ops][+val[;ops]]...
Argument han: The handle of the file to read from
         val: If a scalar, the value is read in
              If a string, the string is read in
         ops: If none, default read format
              If string, characters determine format

The read command allows the batch programmer to read strings and variable
values from the disk.  The first option is the file handle and the parameters 
following parameters are the same as those for the "rite" command as 
described in section 5.7 above.  These options are somewhat different when
read from than when written out.  This command will only read a single word
(until the next blank or end of line) when it reads in a string so it may
take several string reads to read a string that was written out with one
write.    The numeric values are expected to be in their ASCII string 
equivalent form, (like they would be written out with EDLIN or some other 
word processor) so the files could be modified directly by the user if 
necessary.  This command can be used to read simple configuration files.

Errors:
  20  The file specified by handle [?????] is not open
  21  At end of file [?????], can't read anymore
  70  The value [?????] of parameter 1 is too big, maximum allowed is 9
  71  The value [?????] of parameter 1 is too small, minimum allowed is 0
  74  At least 2 parameter(s) required for this command
  76  The parameter [?????] cannot be assigned to
  87  Parameter [?????] should be a scalar
  90  Parameter [?????] should be a pointer or scalar
  94  Label not allowed in parameter [?????]


     Command: reall
     Purpose: Adjust size of previously allocated memory
Restrictions: None
      Syntax: reall ptr
    Argument: The pointer used in a prior ALLOC or ALLST


     Command: redir
     Purpose: Redirect the output of an individual command to a file
Restrictions: None
      Syntax: reall command
    Argument: The command to be interpreted
    NOT SUPPORTED YET

     Command: redsp
     Purpose: Redisplay the direct video screen
Restrictions: None
      Syntax: redsp


     Command: rem
     Purpose: Give a command to the another copy of D3-3780
Restrictions: Must be communicating with another version of D3-3780.
      Syntax: rem commandstr[+commandstr]...
   Arguments: A string containing any D3-3780 command.  
   
This command is only useful when talking to another copy of D3-3780.  Each
parameter is a string containing a D3-3780 command.  An indefinite number 
of these commands can be strung together using "+" signs.  This can be
especially useful with the "/" command.  

For Example:

  rem "/dir > dummy.txt"+"s dummy.txt"

This would cause the remote to take a local directory and put the output in
the file dummy.txt and then send the resulting file back to the 3780 that
sent the command.  This command can be used to change the remote directory
and execute remote batch files among many other things.

Another Example:

  rem "dp dummy.bat;s"
  s dummy.bat;s
  rem "/dummy"

These commands would send a batch file to the remote and then cause that
file to be executed.  The remote control possibilities here are pretty
extensive (imagine modifying the remote's autoexec.bat).  I will introduce
some more extensive security features to deal with this in the near
future.

Errors:
   1  The remote computer dropped the line
   6  This command cannot be performed unless online
   9  This command cannot be performed until current send is done
  15  The modem is not able to transmit, It will not raise CTS
  18  The modem is not able to transmit, SCC TX buffer error
  24  Bad acknowledgment limit exceeded.  Send aborted
  25  Incomplete file sent - Enquiry limit was exceeded
  26  No acknowledgment limit exceeded.  Send aborted
  27  Remote computer aborted send
  64  Unexpected state [???]
  74  At least 2 parameter(s) required for this command
  85  Parameter [?????] should be a string constant or pointer
  93  Insufficient internal memory to process command


     Command: ren
     Purpose: Rename a file or files
Restrictions: None
      Syntax: ren oldspec newspec
  Argument 1: Old value including path and wildcards  
           2: New value including path and wildcards  

This is very similar to DOS' "ren" command except that the paths can be used
to move a file from one directory to another.  The DOS rename will not allow
this.

Errors:
  16  No files found (using [?????])
  17  File [?????] not found
  51  "?????" already exists or invalid path
  60  Wildcards on left must be in same positions as those on right
  74  At least 2 parameter(s) required for this command
  89  Parameter [?????] should be a filename or file specification
  99  Attempt to move a file to another device


     Command: ret
     Purpose: Returns to line after previous CALL command in the file
Restrictions: None
      Syntax: ret

This is the function which returns control after a subroutine has been
called.  Control will return to the line following the most recent internal
"call" command.  Intervening "call" commands to (or within) other command 
files do not effect the behavior of the internal calls.

Errors:
  67  This command is only allowed in batch mode
 103  Return without a call


     Command: rite
     Purpose: Format and write data to screen
Restrictions: None
      Syntax: rite val[;ops][+val[;ops]]...
Argument val: If a scalar, the value is written out
              If a string, the string is written out
         ops: If none, default display format
              If string, characters determine format

The rite command allows the batch programmer to write strings and variable
values to the screen even when display echoing has been suppressed.  The
parameters are described in section 5.7 above.

Errors:
  74  At least 1 parameter(s) required for this command
  90  Parameter [?????] should be a pointer or scalar
  94  Label not allowed in parameter [?????]


     Command: rstrt
     Purpose: Restart the program
Restrictions: None
      Syntax: rstrt
      NOT SUPPORTED, this one may become irrelevant



     Command: s
     Purpose: Send files and buffers to the other 3780
Restrictions: Must be online
      Syntax: s dat[;ops][+dat[;ops]]... ops
Argument dat: If a string, the string is transmitted
              If a file, the file is transmitted
         ops: If none, default values are used
              If string, characters determine values

This is the general purpose send command.  It is used to send a combination 
of strings and files.  The files can include wildcards.  The "ops" strings  
is used to specify details on how to send a file.  The options specify the
buffer type (section 2.2) expected, the destination (printer or punch) and 
whether the remote will receive the files as separate files or all in one.

Like the format option strings, the send option string does not require
quotes and is a list of characters each of which has a meaning.  There 
are two forms of options for this command the (shorter) normal ones
and the more extensive form which can set the more unusual options.
The normal options are:

  S - To send standard mode with the "Vary" buffer type.
  T - To send transparent mode with the "Fixed" buffer type.
  B - To send transparent mode with the "Binary" buffer type.

  C - To concatenate files as they are transmitted (use ETB between files).
      If used on a specific file it will cause that file to be concatenated
      to the next file in the send.
  X - To leave files separate as they are transmitted (use ETX between files)

  P - To Send to the remote printer
  N - To Send to the remote punch

Less common short options:
  H - To send standard mode with the "Hex" buffer type.
  V - To send standard mode with the "Vary" buffer type (same as S).
  F - To send transparent mode with the "Fixed" buffer type (same as T).

Examples:

  s file.txt s             ; Specifies standard with vary buffer type
  s file.txt+file2.txt tc  ; Specifies transparent with fixed buffer type 
                             and sends both files as one file.
  s file.txt nb            ; Specifies transparent with binary buffer type
                             and sends to the remote punch

Note: The order of the options is not important when using the short form.

The long form uses the "S" and "T" followed by either "V", "F", "B" or "H"
to indicate the buffer type and the mode in which it is used precisely.

For example:

  s file.txt sf  ; Specifies that fixed format be used with standard mode

  s "48 65 6C 6C 6F" nth  ; Specifies that the send go to the punch and the 
                            transparent mode be used with hex buffer type

In general, specify the sending mode with an "S" or "T" and then use a "V", 
"F","B" or "H" to specify the buffer type.  The "P","N","C" and "X" options 
can be placed anywhere in the string.

When sending several files with one "s" command, the syntax of this command 
allows one default option string for all the files and specific option 
strings to modify the options for specific files in the list.  The default
option list is at the end and is separated from the list by a blank or a
comma.  The specific option lists should follow the file they modify and be
separated by a semicolon.

For Example:

  s file0.txt;bc+file2.txt;s+file3.txt;t

This command concatenates the first two files and sends the third separate.
Transparent mode and binary buffer type is used for file0, Standard mode
and vary buffer type is used for file2 and transparent mode with fixed
buffer type is used for file3.

  s file0.txt+file1.txt;p+file3.txt ns

This will send file0 and file3 to the remote punch and file1 to the remote 
printer.  These will all all be sent in standard mode with the vary buffer
type.  They will also be sent as separate files.

Note: Concatenating a punch file to a printer file or visa versa will not
      work properly.  Both the files will go to the destination of the
      first and one garbage character may be inserted at the start of the
      second file (a hex 12).

If the options list is left blank then the power up defaults or the buffer
type and destination options from the last send will be used.  The 
concatenation option always resets itself to disabled between send commands.
The power up defaults are to send standard mode with the vary buffer type
to the printer.

Errors:
   1  The remote computer dropped the line
   2  Unable to open file [?????]
   6  This command cannot be performed unless online
   9  This command cannot be performed until current send is done
  15  The modem is not able to transmit, It will not raise CTS
  18  The modem is not able to transmit, SCC TX buffer error
  24  Bad acknowledgment limit exceeded.  Send aborted
  25  Incomplete file sent - Enquiry limit was exceeded
  26  No acknowledgment limit exceeded.  Send aborted
  27  Remote computer aborted send
  64  Unexpected state [???]
  72  Filename (and path) is too big in [?????]
  93  Insufficient internal memory to process command
  94  Label not allowed in parameter [?????]
 104  Parameter [?????] must be a string of filename


     Command: save
     Purpose: saves buffer pointed to by ptr to file named by file
Restrictions: None
      Syntax: save ptr,file[,val]

The save command is a quick and dirty command to make a file and with the
given data in it.  This command saves you the trouble of having to open 
the file, write to it and then close it.  The third optional parameter is 
either a length (scalar) or a pointer to the first location past the end of 
the buffer.  If neither is specified then the command will write until a 
hex 0 is found in the buffer.  

The "ptr" parameter can also be an integer.  If "ptr" is an integer then its 
ASCII equivalent value will be written to the file.  That is, the if the 
integer is a 99 the string "99" will be written to the file.  The "val" 
parameter is irrelevant if "ptr" is not a scalar type.

Errors:
  69  Length pointer [%s] must point into the memory buffer
  74  At least 2 parameter(s) required for this command
  80  Parameter [?????] must be a filename
  82  Length Parameter [?????] cannot be a file or label
  90  Parameter [?????] should be a pointer or scalar
  98  The filename cannot include wildcards


     Command: sdefs
     Purpose: Sets default send buffer type and destinations
Restrictions: None
      Syntax: sdefs ops
    Argument: "ops" value identical to that of the send command.


     Command: seek
     Purpose: Change the location of the file pointer
Restrictions: None
      Syntax: seek handle,wherenum[,refnum]
  Argument 1: The handle of the file
           2: The location to seek to
           3: If none, wherenum is relative to the beginning of the file
              If refnum=1, wherenum is relative to the current location
              If refnum=2, wherenum is relative to the end of the file

When file input/output is performed on files using handles then a file 
pointer is maintained by the system.  This file pointer tells the system 
where to read from or write to the file.  This command moves the file
pointer to a different location.  The third parameter determines whether
the second parameter is relative to the start of the file, the current
location or the end of the file.  The value can be negative and must be if
the location is referenced from the end of the file.

Errors:
  20  The file specified by handle [?????] is not open
  70  The value [?????] of parameter 1 is too big, maximum allowed is 9
  70  The value [?????] of parameter 3 is too big, maximum allowed is 2
  71  The value [?????] of parameter 1 is too small, minimum allowed is 0
  71  The value [?????] of parameter 3 is too small, minimum allowed is 0
  74  At least 2 parameter(s) required for this command
  87  Parameter [?????] should be a scalar


     Command: setbf
     Purpose: Set the values of a buffer to a single character
Restrictions: None
      Syntax: setbf buf[;num][,val]
  Argument 1: The buffer in which to set the values
         num: if none, the buffer locations will be set to zero
              if a scalar the buffer locations will be set to its value
         val: Specifies number of locations to set
              if None length array is used
              if a scalar then the value is the number of bytes to set
              if a pointer then the value will be the upper bound

This command is normally used to clear a buffer out.  It can also be used to
set the values in a buffer to some known value.

Errors:
  69  Length pointer [%s] must point into the memory buffer
  70  The value [?????] of parameter 2 is too big, maximum allowed is 255
  71  The value [?????] of parameter 2 is too small, minimum allowed is 0
  74  At least 1 parameter(s) required for this command
  77  Buffer pointer [?????] must have memory allocated to it
  82  Length Parameter [?????] cannot be a file or label
  87  Parameter [?????] should be a scalar


     Command: setpr
     Purpose: Sets the string to be used at the prompt in the window
Restrictions: None
      Syntax: setpr ptr
    Argument: A string or pointer argument
    I will allow a full argument list at some time (time date etc.)

     Command: sform
     Purpose: Sets the format string for a display variable
Restrictions: None
      Syntax: sform num ptr
  Argument 1: A number indicating which display variable
           2: The new format string


     Command: size
     Purpose: Determine the size of a given file
Restrictions: None
      Syntax: size numlow[;numhigh],file
  Arg numlow: Low integer of file size
     numhigh: High integer of file size (0 if filesize < 65535 )
        file: The name of the file

This command is used to check the size of a file.  The optional numhigh
parameter is used if dealing with a very large file.  An error will be 
produced if numhigh is not included and the file is too large to put in
an integer.

Errors:
   2  Unable to open file [?????]
  28  File is too large for an integer to store its length
  74  At least 2 parameter(s) required for this command
  80  Parameter [?????] must be a filename
  81  The value in parameter 1,[?????] cannot be assigned an integer
  81  The value in parameter 2,[?????] cannot be assigned an integer
  98  The filename cannot include wildcards


     Command: slen
     Purpose: Determine the length of a string
Restrictions: None
      Syntax: slen num,str
  Argument 1: The number to be assigned the length
           2: The string whose length is being checked

This command is used to check the length of a string.

Errors:
  85  Parameter [?????] should be a string constant or pointer
  86  This command requires 2 parameter(s)
  88  The parameter [?????] cannot be assigned a scalar


     Command: smask
     Purpose: Sets the mask for a display variable
Restrictions: None
      Syntax: smask num mask
  Argument 1: A number indicating which display variable
           2: A bit mapped number which indicates when the variable should
              be updated

     Command: smax
     Purpose: Sets the maximum length for a display variable
Restrictions: None
      Syntax: smax num len
  Argument 1: A number indicating which display variable
           2: The maximum number of chars to display


     Command: so
     Purpose: Sends modem's options to modem
Restrictions: The modem cannot be online
      Syntax: so file|ptr
    Argument: If a file, it contents are converted to hex and sent
              If a string, then the strings contents are converted and sent

This command is used to send modem option settings from a file.  The
should contain ASCII text which represents hex option bytes ("AA" to
mean hex AA).  This can be used to send previously determined options which
are generated with a word processor.  A more elegant way of setting up
the options interactively will be added soon (It will probably include
a way to write files out which this command can send to the modem).

Errors:
   2  Unable to open file [?????]
   7  This command cannot be performed while online
  15  The modem is not able to transmit, It will not raise CTS
  18  The modem is not able to transmit, SCC TX buffer error
  98  The filename cannot include wildcards
 104  Parameter [?????] must be a string of filename


     Command: sptr
     Purpose: Subtracts two pointers and assigns the difference to an integer
Restrictions: None
      Syntax: sptr num,ptrbigger,ptrsmaller
  Argument 1: The number to receive the value
           2: The left operand in the subtraction
           3: The right operand in the subtraction

This command can be represented as "num=ptrbigger-ptrsmaller".  It is useful
for determining the number of locations between any two pointers.  The result
will be negative if ptrsmaller>ptrbigger.

Errors:
  85  Parameter [?????] should be a string constant or pointer
  88  The parameter [?????] cannot be assigned a scalar


     Command: sptyp
     Purpose: Sets conditionals for working with special hardware
Restrictions: None
      Syntax: sptyp num
    Argument: A character which specifies use with a multiprotocol card or
              out the DTE port of the modem.


     Command: srite
     Purpose: Format and write data to a string
Restrictions: None
      Syntax: srite str,val[;ops][+val[;ops]]...
Argument str: The string to write the formatted string to.
         val: If a scalar, the value is written out
              If a string, the string is written out
         ops: If none, default format
              If string, characters determine format

The srite command allows the batch programmer to write strings and variable
values out to another string.  The first option is the string (buffer) and 
the parameters following parameters are the same as those for the "rite" 
command as described in section 5.7 above.  This command is useful when
constructing strings for filenames and to compare with incoming values.

Errors:
  74  At least 1 parameter(s) required for this command
  77  Buffer pointer [?????] must have memory allocated to it
  90  Parameter [?????] should be a pointer or scalar
  94  Label not allowed in parameter [?????]


     Command: ss
     Purpose: Send status to the remote 3780
Restrictions: The modem must be online
      Syntax: ss

This command sends a variety of status information to the remote 3780.  It
is mainly useful as a remote command when talking to another copy of
D3-3780.  The information that is sent is identical to the "ST" status 
command which merely displays the data.

Errors:
   1  The remote computer dropped the line
   6  This command cannot be performed unless online
   9  This command cannot be performed until current send is done
  15  The modem is not able to transmit, It will not raise CTS
  18  The modem is not able to transmit, SCC TX buffer error
  24  Bad acknowledgment limit exceeded.  Send aborted
  25  Incomplete file sent - Enquiry limit was exceeded
  26  No acknowledgment limit exceeded.  Send aborted
  27  Remote computer aborted send
  64  Unexpected state [???]
  93  Insufficient internal memory to process command


     Command: st
     Purpose: Display status information
Restrictions: None
      Syntax: st

This command displays a variety of status information on the screen.  The
values in it are updated dynamically during a reception.  No possible
errors with this command.


     Command: stc
     Purpose: Scan a string for the first occurrence of a character.
Restrictions: None
      Syntax: stc destptr,sourcestr,char
  Argument 1: The pointer variable which is assigned the result
           2: The string which is being searched
           3: The character which is to be matched

This command is used to determine the first location in a string that
contains a certain character.  If the string doesn't have the character
in it anywhere then the destptr will be set to point to the "0" that
terminates the string.

Errors:
  70  The value [?????] of parameter 3 is too big, maximum allowed is 255
  71  The value [?????] of parameter 3 is too small, minimum allowed is 0
  84  Parameter [?????] should be a pointer variable
  85  Parameter [?????] should be a string constant or pointer
  87  Parameter [?????] should be a scalar


     Command: stoff
     Purpose: Turns off all status variable display
Restrictions: None
      Syntax: stoff

     Command: ston
     Purpose: Turns on all status variable display
Restrictions: None
      Syntax: ston


     Command: stst
     Purpose: Scan a string for the first occurrence of a substring.
Restrictions: None
      Syntax: stst destptr,sourcestr,substr
  Argument 1: The pointer variable which is assigned the result
           2: The string which is being searched
           3: The substring which is to be matched

This command is used to determine the first location the beginning of a
substring in a string.  If the string substring doesn't occur anywhere in
the sourcestr the destptr will be set to point to the "0" that terminates 
the string.

Errors:
  84  Parameter [?????] should be a pointer variable
  85  Parameter [?????] should be a string constant or pointer
  87  Parameter [?????] should be a scalar


     Command: sup
     Purpose: Suppress command window screen writes
Restrictions: Batch Only
      Syntax: sup

This command is used to suppress all video output except "rite" and "key"
statements.  It gives the batch programmer extensive control over what
appears in the command window.

Error:
  67  This command is only allowed in batch mode


     Command: svals
     Purpose: Sends the values of internal variables to the remote
Restrictions: The modem must be online
      Syntax: svals

This command sends a variety of status information to the remote 3780.  It
is mainly useful as a remote command when talking to another copy of
D3-3780.  The information that is sent is identical to the "VALS" status 
command which merely displays the data.  The information is a dump of
several of the batch language internal variables.

Errors:
   1  The remote computer dropped the line
   6  This command cannot be performed unless online
   9  This command cannot be performed until current send is done
  15  The modem is not able to transmit, It will not raise CTS
  18  The modem is not able to transmit, SCC TX buffer error
  24  Bad acknowledgment limit exceeded.  Send aborted
  25  Incomplete file sent - Enquiry limit was exceeded
  26  No acknowledgment limit exceeded.  Send aborted
  27  Remote computer aborted send
  64  Unexpected state [???]
  93  Insufficient internal memory to process command


     Command: tabls
     Purpose: Loads new conversion table from ASCII file
Restrictions: None
      Syntax: tabls filename
      NOT SUPPORTED YET (note:The tables can be modified using variables)


     Command: td
     Purpose: Displays the current time and date
Restrictions: None
      Syntax: td

This command displays the current time and date.  It is mainly useful for
logging that information in a batch file when a list file is being used.
No errors are possible with this command.


     Command: tell
     Purpose: Get the location of the file pointer
Restrictions: None
      Syntax: tell handle,varnum
  Argument 1: The handle of the file
           2: The variable to assign the file pointer value to.

When file input/output is performed on files using handles then a file 
pointer is maintained by the system.  This file pointer tells the system 
where to read from or write to the file.  This command tells how far the
file pointer is from the beginning of the file.

Errors:
  20  The file specified by handle [?????] is not open
  70  The value [?????] of parameter 1 is too big, maximum allowed is 9
  71  The value [?????] of parameter 1 is too small, minimum allowed is 0
  86  This command requires 2 parameter(s)
  87  Parameter [?????] should be a scalar
  88  The parameter [?????] cannot be assigned a scalar


     Command: tk
     Purpose: Talk (verbally) to the person at the remote 3780
Restrictions: Must be online
      Syntax: tk

This command is used to engage in verbal conversation with the remote
user.  It is not supported yet.  No errors yet also.


     Command: tr
     Purpose: Store a record of exactly what goes on the line, a trace.
Restrictions: None
      Syntax: tr

This command is used for line diagnostics.  It keeps a record of exactly
what is communicated on the line.  The tr command works as a toggle.
If the trace is enabled then the command will disable it.  If the trace is
disabled then the command will enable it.  The command is not supported yet
and does not have any errors yet either.


     Command: undsp
     Purpose: Restore the direct video display after a "dsup" command
Restrictions: None
      Syntax: unsup



     Command: unsup
     Purpose: Restore the video display after a "sup" command
Restrictions: None
      Syntax: unsup

This command is used to reverse the effect of the "sup" command.  Thus, it
restores the video back to normal.

Error:
  67  This command is only allowed in batch mode


     Command: upr
     Purpose: Makes a string of scalar upper-case
Restrictions: None
      Syntax: upr val
    Argument: If a string the whole string will be made upper-case
              If an integer or character just the character will be made
                upper-case

This command is just like is sounds.  Characters that non alphabetic or
already are upper case are not affected.

Error:
  76  The parameter [?????] cannot be assigned to


     Command: vals
     Purpose: Display the values of the internal batch variables
Restrictions: None
      Syntax: vals

This is a diagnostic command for displaying the values of the built in
D3-3780 variables (i0-i9,p0-p9,db,etc.).  No errors can be generated by this
command.


     Command: vtype
     Purpose: Set display type to direct or through BIOS
Restrictions: None
      Syntax: vtype[ ch]
    Argument: if 'B' then BIOS will be used otherwise direct ram writes will
              be used.


     Command: w
     Purpose: Wait to receive a file or files from the remote
Restrictions: Must be online
      Syntax: w,timeout
    Argument: The maximum number of seconds to wait before a transmission
              is initiated.

This command is used to receive a transmission from the remote.  More
than one file can be sent in a transmission since the end of the transmission 
is signaled by an EOT character from the remote, files are separated by ETX 
characters.  If auto-naming is enabled the n# and p# variables can be used to
determine whether multiple files were received.

Errors:
   1  The remote computer dropped the line
  10  Disk error, See if disk is full
  12  Idle timeout during receive
  14  No activity timeout exceeded
  22  No acknowledgment limit exceeded.  Receive aborted
  23  Remote aborted receive
  64  Unexpected state [???]
  67  This command is only allowed in batch mode
  87  Parameter [?????] should be a scalar


     Command: xb
     Purpose: Execute (chain to) another batch (command) file
Restrictions: None
      Syntax: xb file
    Argument: The file to execute

This command is used to chain to another batch file on disk.  It is somewhat
limited in batch mode in that it will not return to the calling batch file.
In interactive mode this command is useful for automating sequences that
are used frequently.  When in batch mode, the line following the "XB" should
never execute.

Errors:
   2  Unable to open file [?????]
  80  Parameter [?????] must be a filename
  98  The filename cannot include wildcards

Possible New commands
----------------------------------------
command which tells exactly how many blocks a file transmission will take
command which transmits to the remote how many blocks a file would take
  at the current blocksize
Relative Branch Facility
number of records in a block
number of blocks in a file
math function, takes an equation on far left ex.
  math %i0,%i0+5*%i1+6*%i2-~%i3
Scripts take command line arguments
Pass variables from one script to another
  Already can pass values from one script to another by the values in
  the global variables.
  Local variables, put in variables that are maintained across remote
    calls to subroutines or scripts.
Emits an Audible Tone (frequency, duration)
Persist Error variable,
Line of persist error variable
Double variable containing both of the above variables
Functions for inputting strings and integers
Functions which allow access to wildcard based filenames
  findfirst, findnext, etc.8.0 Screen Customization Fundamentals

The following sections are for those want to perform extensive modification 
to the appearance of the D3-3780 package.  There are a variety of commands 
and variables which allow this.

In the D3-3780 package there are fundamentally two different kinds of screen
writes: Serial and Direct.  The Serial writes take place in a window which
scrolls upward as more information is written.  This window contains the
flashing cursor and video writes always begin at the cursor.  The cursor will
remain at the line following a serial write.  Direct writes can be written 
anywhere on the screen without regard to the cursor and do not (normally) 
affect the cursor.  The words "serial" and "direct" will be used frequently
in the following descriptions.


8.1 Video Attributes

For each character on the video screen there is a byte which determines the
color and other characteristics of how it is displayed.  This byte is
referred to as an attribute byte.  Attribute bytes are bit-mapped in that
different bits of the attribute have specific meanings.  The Bit definitions
of the attribute bytes are:

   Bit 7 (Most significant bit) Flashing (0 - normal, 1 - character flashes)

   Bit 6 Background Red
   Bit 5 Background Green
   Bit 4 Background Blue

   Bit 3 Intensity                    (0 - Low intensity, 1 - High intensity)

   Bit 2 Foreground Red
   Bit 1 Foreground Green
   Bit 0 Foreground Blue

 In color modes bits 4-6 bits combine to generate 8 distinct background
 colors.  Bits 0-3 are used to generate 16 unique foreground colors.
 The first eight foreground colors look the same as the 8 background colors
 (the characters aren't visible if the background and foreground colors
 match).  The last 8 foreground colors are merely brighter versions of the 
 first eight colors.  These colors are:

   0 - Black
   1 - Blue
   2 - Green
   3 - Cyan
   4 - Red
   5 - Violet
   6 - Brown (or Yellow if in foreground with intensity is set)
   7 - White

 If the system is on a monochrome monitor then the following meanings
 apply:

   Flashing bit determines flashing (same as on color)
   Background, 7 is lit with low intensity all others are black
   Intensity bit determines intensity (same as on color)
   Foreground, 0 is black, 1 is underlined, all others look normal

 Sometimes a user is running a monochrome monitor on a color display card
 (this is especially common in portables).  This is functionally similar 
 to monochrome except that the underline cannot be supported.


8.2 Video Modes

The Basic Input/Output System of a PC (really, the video adapter) has a
variety of video modes.  Currently, D3-3780 supports three video modes
directly (other modes can easily be added if desired, these modes however
are the most common).

  Mode 2: Color adapter in monochrome mode.
  Mode 3: Color adapter in color mode.
  Mode 7: Monochrome adapter (only has one mode).

All three of these modes are 25 rows by 80 columns.  The default video
attributes are set according to which mode the adapter is found in.  If
the package is booted while the system is in another mode then it is
switched into mode 3 (this always works since monochrome monitors have
to be in mode 7 and all color cards support mode 3).

When a user is running a monochrome monitor on a color adapter, mode 2 may
look better than mode 3.  This depends on how well the monochrome monitor
can display color using intensity.  If a user complains of an illegible screen
then it may be desirable to use DOS' mode command to switch to mode 2.

Mode Commands:

 A>mode bw80          -- Sets mode to 2
 A>mode co80          -- Sets mode to 3
 A>mode mono          -- Sets mode to 7 (relevant in two monitor system only)

The "VM" variable can be accessed in the command language to determine the
video mode.


8.3 Attribute variables

Variables which can be changed in the command language are used heavily to
determine the colors used in video writes.  Certain characteristics tend to
be tied to certain attribute variables.  Changing one of these variables can 
a dramatic effect on the appearance of the package (especially on color 
monitors).  For example, changing the value of the Graph Attribute will 
change the color of all the graphic character (often used for borders) on t
he screen.  

The names of these variables are: 

  CA - Change Attribute
  DA - Default Attribute 
  GA - Graph Attribute
  HA - High Attribute
  KA - Key Attribute
  RA - Reverse Attribute
  UA - Underline Attribute
  WA - Window Attribute

  The Change attribute is generally used to the distinguish the changing
    parts of the screen from the parts which do not change.  The distinction
    is only made on color monitors.  The default is White on color monitors
    and normal (low intensity) on monochrome monitors.  I've generally used 
    this attribute for displaying the values of options and status 
    information in the direct writes.  The implied meaning could easily be 
    changed.

  The Default attribute is used in a write until the color is explicitly
    set using an escape sequence (see the next section).  It defaults to 
    bright yellow on color monitors and normal on monochrome monitors.

  The Graph attribute is automatically used for any character which is 
    above 127 decimal (hex 7F).  This is used to make the borders of 
    boxes a different color than the text.  The "16" decimal (hex 10)
    escape sequence can be used to toggle the automatic use of this
    attribute.

  The High attribute is used to highlight the filenames and buffer types 
    of the printer or punch when files are received.  When files are sent 
    the attribute is used for the send filename.  It appears as Light
    Blue on a color screen and High Intensity on monochrome.

  The Key attribute is the default attribute in interactive mode for the
    keys that are being pressed (at the command "?" prompt).  Its default
    values are the same as the default attribute.

  The Reverse attribute defaults to black letters on lighted background on 
    a monochrome screen, black on green on a color screen.  It is not used 
    for any particular class of operation.

  The Underline attribute defaults to underline on a monochrome screen and
    red on a color screen.  It is not used for any particular class of
    operation.

  The Window attribute is the default attribute for all writes in the 
    scrolling window of the screen except a command being edited in 
    interactive mode.  Its default value is normal (low intensity, gray 
    on color monitors).

The next section has a description of a large number of video escape 
sequences.  Several of the escape sequences deal with the setting of the 
attributes for video writes and use these variables to determine the
new attribute value.


See section 5.1 for information on built in variables.


8.4 Video Escape Sequences

Video escape sequences can be used in either the direct or serial writes. 
The row,column values for the serial writes however are with respect to
the current window while the row,column values for the direct writes are
with respect to the entire screen.  Which functions use direct and which 
are serial will be discussed later.

The video writes have a number of special escape sequences which allow 
you to change the colors and where the following characters will be 
written.  

The terms "row" and "column" are used throughout the descriptions.  Row 1 
is the highest row and column 1 is the leftmost column.  In direct writes, 
the rows are always numbered from 1 to 25 and the columns from 1 to 80.
In serial writes, rows are defined relative to window variables (wt,wl,wr 
and wb for top, left, right and bottom).  The allowed range for serial 
rites is 26-wt for rows and 81-wl for columns.  

The term "location" refers to the row and column which the next character
will be written.  This can be thought of as the cursor location (although
the actual flashing cursor is not necessarily moved with these video 
writes).

Video Escape Sequences (brief descriptions, long ones will follow):
dec hex
 1  01 row col -- Relative goto. Write continues at:(row+old row,col+old col)
 2  02 row col -- Absolute goto. Write continues at:(row,col)  
 3  03         -- Put Flashing cursor at current (row,col) when done writing.
 4  04         -- Switch to minimum escape set (07,08,09,0A and 0D)
 5  05         -- Take next byte literally.  Allows writing of escape chars.
 6  06         -- Take rest of string literally (disables all escape chars).
 7  07         -- Audible Bell
 8  08         -- Backspace (Same as a relative move back one space)
 9  09         -- Tab (default stops are set at 1,11,21,31,...)
10  0A         -- Linefeed
11  0B ##      -- Scroll Window "##" lines (Scrolls backward if negative)
12  0C         -- Clear video window (full screen for direct writes)
13  0D         -- Carriage Return
14  0E         -- Toggle Flash Bit of attribute
15  0F         -- Toggle Intensity Bit of attribute
16  10         -- Toggle automatic use of graph attribute
17  11 ??      -- Change attribute byte to "??"
18  12         -- Return to default attribute (either DA or WA variables)
19  13         -- Change Attribute (White on color screens, normal on mono)
20  14         -- High Attribute (Light Blue on color, High intensity mono)
21  15         -- Graph Attribute (also used for chars above 127 decimal)
22  16         -- Reverse Attribute (Black on Green in color, white in mono)
23  17         -- Underline Attribute (Underline on mono,Red on color)
24  18         -- Displays as itself (Up arrow)
25  19         -- Displays as itself (Down arrow)
26  1A         -- Displays as itself (Right arrow)
27  1B         -- Displays as itself (Left arrow)
28  1C ##      -- Repeat the row above "##" times, must be in column 1
29  1D ##      -- Write "##" blanks, do not advance location (clears area)
30  1E ## ch   -- Make column by writing "ch", "##" times, vertically
31  1F ## ch   -- Write "ch", "##" number times

There are shorthand aliases for some of the escape sequences.  These are:

   \a - \7         - Bell 
   \b - \8         - Backspace
   \t - \9         - Tab
   \n - \10 or \xA - Linefeed
   \v - \11 or \xB - Vertical Tab -- Scrolls the screen
   \f - \12 or \xC - Form Feed    -- Clears Screen
   \r - \13 or \xD - Carriage Return

The sequences are functionally identical to the numerical sequences.  They 
are also the same sequences used in the C programming language.

Now for extensive descriptions of each of the escape sequences.


       Escape Character : 1
                Purpose : Set location for subsequent writes
                  Usage : "\1\ro\col"
 Additional Character 1 : Number of rows to add to current location
 Additional Character 2 : Number of columns to add to current location

 This sequence causes subsequent characters to be written starting at the
 location specified by (row+current row,column+current column).  Where the 
 next two characters in the string are "row" and "column".  The row and 
 column numbers can  be negative if the following write needs to be in a 
 lower numbered column or row.  If the addition results in an out of range 
 value then the row/column will not change.  When leaving the row/column 
 unchanged, a value that is always out of range (such as 100) should be 
 used in place of a zero (null byte) since the null byte will terminate 
 the string.


       Escape Character : 2 
                Purpose : Set location for subsequent writes
                  Usage : "\2\ro\col"
 Additional Character 1 : Row for new location
 Additional Character 2 : Column for new location

 This sequence causes subsequent characters to be written starting at the
 location specified by (row,column), the next two characters in the string.
 In the direct writes the (row,column) values are relative to the upper
 right-hand corner of the screen.  In the serial writes the (row,column)
 values are relative to the current window as defined by the (wt,wl,wb,wr)
 variables (variable names are mnuemonic for Top, Left, Bottom and Right).
 The row and column values start numbering at (1,1) not (0,0).


       Escape Character : 3 
                Purpose : Set the cursor location when write is complete

 This sequence has no effect in serial writes since the cursor is always
 placed at the end of the string (actually after the subsequent prompt).
 If serial writes have been suppressed then the direct writes can place
 the cursor using this sequence.  The cursor will be set at whatever location
 in the string that the "\3" sequence would be written if it were a normal 
 character.


       Escape Character : 4
                Purpose : Disable non-standard escape characters

 Most DOS display functions (like the "type" command) only support a few
 escape characters.  These are the bell (7), backspace (8), tab (9), linefeed
 (10 dec, 0A hex) and the Carriage Return (13 dec, 0D hex).  When this
 escape sequence is encountered all escape characters are turned off except
 for those mentioned above.  This is useful for writing the contents of files
 which may inadvertently have a few escape characters in them.


       Escape Character : 5
                Purpose : Display graphic of escape character
                  Usage : "\5ch"
   Additional Character : The character to display

 The escape characters themselves display as a variety of interesting
 symbols.  There may be times that you want to display the symbol.  This
 command allows you to display a single symbol.  
   
   For example, the command: rite "\5\1 I feel happy! \5\1"
   would display the message "I feel happy" with little happy faces
   before and after.


       Escape Character : 6
                Purpose : Turn off all escapes (except terminating zero)

 This command disables all of the escape characters except the terminating
 zero.  It is useful for displaying binary data when debugging or using
 an unknown file.


       Escape Character : 7 or \a
                Purpose : To make an audible bell

 This is useful when wanting to make a noise to notify a user of a problem
 who may not be nearby.


       Escape Character : 8 or \b
                Purpose : To back the write location up one position

 This is the same as a relative move back one column.  It is supported since
 DOS supports this function.


       Escape Character : 9 or \t
                Purpose : To go to the next tab stop

 This escape character is useful for assuring that columns will be aligned
 properly when uneven length data is being displayed.  The default tab
 widths is 10 characters which is compatible with IBM mainframe printers
 and 3780's.  PC's normally have tab stops every 8 characters.  The "TW"
 variable can be used to set the widths to any character value.


       Escape Character : 10 dec, 0A hex or \n
                Purpose : Move down one line

 This is the same as a relative move down one line except that it will
 scroll if necessary.  It does not affect the column setting.  This
 character is almost always coupled with a carriage return ("\r") to put
 the location back to column 1.


       Escape Character : 11 dec, 0B hex or \v
                Purpose : Scroll window "##" lines
                  Usage : "\11\##"
   Additional Character : The number of lines to scroll

 This sequence can cause the window to scroll any number of lines up or down.
 It is the only way to get a reverse scroll in the command language since it
 will accept a negative value.  The whole screen will scroll on direct
 writes.  This is not a standard DOS capability.


       Escape Character : 12 dec, 0C hex or \f
                Purpose : Clear the video window

 This is the "Form Feed" escape character.  It serves to clear the screen in
 this video write but DOS functions will merely display a little feminine
 symbol.


       Escape Character : 13 dec, 0D hex or \r
                Purpose : Return to column 1

 This is the standard DOS carriage return except that it is relative to the
 window.  It is almost always coupled with a linefeed to begin the next line.


       Escape Character : 14 dec, 0E hex
                Purpose : Toggles the flashing attribute bit

 This character is used to make displayed characters flash.  The other 
 attributes that are currently being used are left unchanged.  To make a
 part of the string flash merely put a "\14" before and after the
 affected portion.  If the value is not toggled off before the end of the
 string it will NOT cause the next write to display in flashing mode.  The
 effect only lasts until the end of the string.


       Escape Character : 15 dec, 0F hex
                Purpose : Toggles the Intensity attribute bit

 This is similar in behavior to the "\14" character above except that if
 effects the brightness with which the characters are displayed rather than
 the flashing.


       Escape Character : 16 dec, 10 hex
                Purpose : Toggles automatic use of the graph attribute

 This character is used to enable and disable the feature that automatically
 uses the graph attribute for characters numbers above 127.  This allows the
 current attribute to be used when necessary.  This is useful when using
 a few graphic characters to construct images that are not borders.  It is
 a toggle but will automatically reset at the end of the string.  The value
 can be permanently disabled by setting the global variable "GE" to FF hex.
 It can be re-enabled by setting the variable to 7F hex.


       Escape Character : 17 dec, 11 Hex
                Purpose : To set video attribute
                  Usage : "\17\##"
   Additional Character : New Attribute byte 

 This changes the video attribute of characters put to the screen until 
 the end of the string or another escape sequence sets the attribute to 
 another value.  This is typically used when an unusual attribute is 
 desired for a character or small set of characters.  The escape sequences 
 for one of the default, high, key or graph attributes are shorter and, 
 normally, more useful.  This is also somewhat less flexible in that the
 string has to be modified if different value are to be used in different
 video modes.  The other escape sequences can be globally modified at the
 start by setting the appropriate variables.


       Escape Character : 18 dec, 12 Hex
                Purpose : To set video attribute back to default

 This is used to set the attribute back to the value of the DA variable
 for direct writes and to the WA variable for the serial (window) writes.  
 The default values in color are bright yellow (0E hex) and white (07 hex) 
 respectively.  They both default to normal (07 hex) in monochrome.


       Escape Character : 19 dec, 13 Hex
                Purpose : To set video attribute to change attribute

 This is used to set the attribute to the value of the CA variable.  The 
 default value in color is bright white (0F hex).  The monochrome default 
 to normal (07 hex).


       Escape Character : 20 dec, 14 Hex
                Purpose : To set video attribute to high attribute

 This is used to set the attribute to the value of the CA variable.  The 
 default value in color is bright cyan (0B hex).  The monochrome default 
 is normal (07 hex).


       Escape Character : 21 dec, 15 Hex
                Purpose : To set video attribute to graph attribute

 This is used to set the attribute to the value of the GA variable.  
 The default value in color is bright green (0A hex).  The monochrome 
 default is normal (07 hex).


       Escape Character : 22 dec, 16 hex
                Purpose : Sets attribute to reverse video as defined by the 
                          RA variable.

 This sets to the attribute to the value of the RA variable until the end of
 the string or until another escape sequence modifies the video attribute.
 The default value of RA is 70 hex in monochrome and 20 hex (green background
 black characters) in color.


       Escape Character : 23 dec, 16 Hex
                Purpose : To set video attribute to underline attribute

 This is used to set the attribute to the value of the UA variable.  
 The default value in color is bright red (0C hex).  The monochrome 
 default is underline (01 hex).

        Characters : 24-27 dec, 18-1B hex
           Purpose : Display arrows

 Technically, these are not "Escape characters".  They merely display as
 their IBM character values.  The values are:

      24 dec, 18 hex -- Up arrow
      25 dec, 19 hex -- Down arrow
      26 dec, 1A hex -- Right arrow
      27 dec, 1B hex -- Left arrow


       Escape Character : 28 dec, 1C Hex
                Purpose : To copy the line above
                  Usage : "\28\##"
   Additional Character : The number of times to copy the line

 This is used to copy the line above a number of times.  This produces 
 strange results when not used in column one (the prior window widths worth
 of characters are copied instead of an even line).


       Escape Character : 29 dec, 1D Hex
                Purpose : Clears an area ahead of the current location
                  Usage : "\29\##"
   Additional Character : The number locations ahead to clear

 This sequence is used to clear the area for a string prior to writing it.  
 It does this by writing a set of number of blanks.  The character following 
 the escape character is the number of blanks to write the character.  This
 sequence does not change the location (subsequent characters will be written
 over the blanks).


       Escape Character : 30 dec, 1E Hex
                Purpose : Make a column
                  Usage : "\30\##ch"
 Additional Character 1 : The number of rows in the column
 Additional Character 2 : The character to write in the column

 This sequence is used to create a column on the screen.  The column will
 start at the current location and will go down as many rows as specified
 by the character "##" character following the "\30".  The column will be 
 made using the "ch" character which should follows the "##".  Once the
 column is written the location will be in the column below the last
 character written.  If drawing a box, the location will be where a
 corner should be written.  This sequence will scroll the screen if the
 column is too long to fit.


       Escape Character : 31 dec, 1F Hex
                Purpose : Write a character multiple times
                  Usage : "\31\##ch"
 Additional Character 1 : The number of times to write the character
 Additional Character 2 : The character to write

 This sequence is normally used to write horizontal lines or blanks in an
 efficient manner.  The "##" character is the number of times to write
 the character and the "ch" character is the character to write.  The 
 location is set to one column beyond the last character written.



8.5 Status Variables

The status variables are the ones which appear in the boxes in the upper
part of the screen and on the bottom line.  These can be made to appear
anywhere on the screen with different formats and colors.  The different
variables which may be displayed are:

  0 -- Send Mode, an integer value from 0 to 7.  It is used to index and
       array of strings which are:
        0 - "Std. Vary   " 
        1 - "Std. Fixed  " 
        2 - "Std. Binary "
        3 - "Std. Hex    "
        4 - "Tran. Vary  "
        5 - "Tran. Fixed "
        6 - "Tran. Binary"
        7 - "Tran. Hex   "
       The values of these strings cannot be changed yet but the option will
       be added soon.  This is true of any of the strings that represent
       names for the status variables.

  1 -- Current Directory, This string is normally displayed on line 2.
       It is a varying length string so the format string should contain
       escape sequences to erase the prior value.  See the second
       example in section 8.6 for more information.

  2 -- Bytes Received. This is the number of bytes received on the last or
       current reception.  By default it is displayed when receiving but
       not when sending so it can occupy the same space as Bytes Sent below.
       This is a long data type, the "l" option must be included in the
       format string specification (see sections 5. and .).  The third
       example in section 8.6 is for this variable.

  3 -- Bytes Sent.  This is the number of bytes sent in the current or last
       transmission.  This is also a long value.

  4 -- This is the Printer Auto-Naming option, 0 displays as "No " and
       1 displays as  "Yes".

  5 -- Printer Filename.  This is also a varying length string.

  6 -- Printer Standard Conversion.  This is the conversion type for a
       standard receptions to the printer.  The values and corresponding
       messages are:
         0 -- "Vary  "
         1 -- "Fixed "
         2 -- "Binary"
         3 -- "Hex   "

  7 -- Printer Transparent Conversion.  Same values as 6 above.

  8 -- Punch Auto-Naming option same as 4 except for punch.

  9 -- Punch Filename. Same as 5 except for punch.

 10 -- Punch Standard Conversion.  Same values as 6 above.

 11 -- Punch Transparent Conversion. Same values as 6 above.

 12 -- Receive Block count.  This is an integer.  It displays in the
       "Blocks" field during a reception (by default).

 13 -- Receive Enquiry Count.  Another integer, It displays in the
       "Enquiries" field during a reception (by default).

 14 -- Receive Nak count.  Integer, displays in "Naks" field.

 15 -- Send block Count.  This integer displays in the "Blocks" field
       during a Send.

 16 -- Printer destination, displays as "Printer" or "Punch  ".

 17 -- Send filename.  Varying length so it requires a clear sequences.

 18 -- Send Enquiry Count.  Integer.

 19 -- Send Nak Count.  Integer.

 20 -- This status variable is used to the "R" and "S" in the upper left part
       of lower right box on the default screen.  It is "R" when sending,
       "S" when receiving and does not display anything otherwise (it however
       will not overwrite the prior "R" or "S" if neither is true).

 21 -- Status Value.  This generates the bottom line in the default screen.
       Its possible values are:
         "    Offline     "
         "Waiting for Call"
         "   Connecting   "
         "    Dialing     "
         " Got Dial Tone  "
         "    Ringing     "
         "Modem Handshake "
         "     Online     "
         "    Sending     "
         "   Receiving    "

       See the example format string in section 8.6 for this one.

 22 -- This generates the "s" and "t" beside the "R" and "S".  It is "s" if
       the send or receive was standard and "t" if the last send or receive
       was transparent.

 23 -- This is the date, it is passed two integers month and day.  Year
       is passed as a string.  The order is month, day, year.  See the
       example format string in section 8.6 for this one.

 24 -- Time, passed hour, minutes and second.  See the example format
       string for this one.

The locations, colors, times and many other details of how these options are
displayed is under you're control.  The options used to control these are:

  format string
  status mask
  maximum length parameter (for strings only)

The format string is the most significant of these.


8.6 The Status Variable Format String

The format string determines the location color and other details of how the
Status Variable is displayed.  It can contain any of the sequences from
section 8.5 above and also contains a format specification which is the same
as the one used in the C programming language's "printf" statement.  This 
string typically has four or five components:

 1  Attribute (color) Escape sequences
    These are sequences from section 8.4 above.  The sequences 12-17 are 
    recommended to be the first byte of the format string.  In fact 7 of 
    the status variables require that the first byte be one of these 
    sequences (if the variable is displayed at all).  These are:

       5 - Printer Filename
       6 - Printer Standard Conversion
       7 - Printer Transparent Conversion
       9 - Punch Filename
      10 - Punch Standard Conversion
      11 - Punch Transparent Conversion
      17 - Send Filename

    The reason these must begin with the attribute byte is because the color
    is switched dynamically while a transmission or reception is going on.
    The first character of the format string is dynamically switched between
    the Change attribute setting (when idle) and the High attribute setting
    (when active).

    The escape sequences are processed from left to right so the highlighting
    of the active printer/punch/send filenames can be disabled by following
    the first attribute setting byte with another to cancel its affect.

    Other format strings do not have any special requirements concerning
    escape sequences for setting attributes.

  2 The location to display the variable.  This must be included since the 
    variable will be displayed at a semi-random location if it is not.  The
    "\2" escape sequence is used to set the location.

  3 The format specification (like C's printf).  This is necessary if the
    variable is going to be displayed.  The format spec begins with a
    percent sign ('%') and is followed by characters which describe the 
    way in which the variable will be displayed.  The other characters are
    very similar to format options used in the "RITE" and "DRITE" commands.
    Section 8.9 is on the C format specification.

  4 A NULL (true zero) at the end of the format string to terminate it.

Other parts of the format string are normally printable characters.  These
characters are displayed as they would be with a normal direct video write 
(see the "DRITE" function).

Examples:

A format string for the Send Mode (status variable 0)

   "\19\2\5\47%s\0"

  The "\19" sets the color to that Change video attribute.  By default it 
  is white on color screens and normal on monochrome screens.  The built in
  variable "CA" can be used to modify the affect of the "\19" (same as \x13).

  The "\2\5\47" causes the value to be displayed at row 5 and column 47.  The
  rows and columns are numbered starting at row 1, column 1 in the upper
  left-hand corner.

  The "%s" is the format specification used to display the string.

  The "\0" terminates the format string.

  The Send Mode format is a typical format string.


This example is for the current directory display (status variable 1)

    "\19\2\2\23\29\27%s\0"

  The "\19" sets the color.
  The "\2\2\23" moves to location row 2, column 23.
  The "\29\27" erases the previous directory name (does not advance location).
  The "%s\0" are the format string and string terminator (same first example).

  The clearing of the prior string is required for strings which have varying
  lengths.  In general, the status variables which display as strings
  (conversion types, send mode, etc.) have blanks filled to the left to
  assure that the the next value will completely overwrite the prior value.

  Also, the status variables are only re-displayed when the values change
  so there is not a "flickering" effect when a string is cleared and then
  immediately rewritten.


This example is for the bytes received variable (number 2).

    "\19\2\7\62%-10lu\0"

  The "\19\2\7\62" set the color and location.
  The format specification is "%-10lu".
    The "-" causes the display to be left justified.
    The "10" makes sure that 10 blanks to the right are written (this clears
      any prior value from that location).
    The "l" is necessary because the bytes received is a long value.
    The "u" is for unsigned decimal display.
  The "\0" terminates the string.


This example is for the Status Value variable, number 21.

    "\2\25\1\22\29\80\2\25\32%s\0"

  The "\2\25\1" sets location to bottom row (25) and column 1.
  The "\22" sets color to reverse video (determined by the "RA" variable).
  The "\29\80" writes a full line of reverse video blanks.
  The "\2\25\32" goes back to the location where the string is to be written.
  The "%s\0" is the format specifier and string terminator.

  The strings are center justified by having the display values centered 
  within their length (See the values in section 8.5).  The names for the
  different states will be added shortly so the centering affect will be able
  to be achieved for any of the values which display as strings.


This example is for the Date variable, number 23.

    "\19\2\2\13%d/%d/%s\0"

  The "\19\2\2\13" sets the attribute and location.
  The "%d" determines the format for the month.
  The "/" is printed.
  The second "%d" is for the day.
  The second "/" is printed.
  The "%s" is needed because the year is passed in as a two character string.
  The "\0" terminates the format string.


This example is for the Time variable, number 24.

    "\19\2\2\3%.2d:%.2d:%.2d\0"

  The "\19\2\2\3" determine the attribute and location.
  The "%.2d"'s cause the values to be displayed with so that they always
    occupy 2 locations with a leading zero on the left if necessary.
  The ":"'s are displayed between the values
  The "\0" terminates the format string.


8.7 The Status Mask value

The status mask value one byte value associated with each status variable
which determines whether it will be displayed or not.  The status mask
value is bitwise and'ed against an internal variable to determine if the
variable will be displayed.  The bits in the internal variable are as
such:

  Bit      Value
   0   -- Always 1
   1   -- 1 if sending, 0 otherwise
   2   -- 1 if receiving, 0 otherwise
   3   -- 1 if the printer is defined to be active, 0 if punch
   4   -- 1 it the punch is defined to be active, 0 if printer
   5   -- Always 0
   6   -- Always 0
   7   -- Always 0

Bit 0 is always 1 so a mask value of 1 will cause the status variable to
always be displayed (if its value is changed).  The default masks of all
status variables except 2,3,12,13,14,15,18 and 19 are 1.

Bits 1 and 2 are not complements.  If neither a receive or send is going
on then both bits will be 0.  A mask of 02 hex will cause a status variable 
to be updated only when sending and a mask of 04 hex will cause a status 
variable to be updated only when receiving.

Status variables 3,15,18 and 19 have 02 as their default mask and variables 
2,12,13 and 14 have 04 as their default mask.  This allows any of 3,15,18
or 19 to occupy the same place on the screen as any of 2,12,13 or 14.

Since nothing will be written for these values when neither a send or
receive is going on the value of the last send or receive will persist
until a new send or receive occurs. 
 
When the package is loaded, neither bit will be 1 so the portion of the 
screen in which a send/receive variable is written will be blank.  In the
default D3-3780 screen "0"'s are explicitly written out in the screen
itself to stop these locations from being blank.

Bits 3 and 4 are complements of one another.  The active destination is
always one or the other even if a receive is currently not going on.  The
initial value is set to the printer and afterwards will be set to whichever 
was the last to receive data.

The "FMASK" command is used to set the value of this mask.


8.8 The Status Variable Maximum Length value

The maximum length value is used to truncate variable length strings so that
they won't overwrite other parts of the screen when they get too long.  The
length parameter is used in the default package for filenames and the
current directory.  The strings are truncated on the left leaving the
rightmost characters.  The rightmost characters in a filename are generally 
more relevant than the first so the maximum length parameter is useful in
cases in which a filename is displayed.  If truncation on the right is
desired instead the precision value of the format string can be used to
limit the number of characters displayed.  The "FMAX" command is used to
set the maximum length values.


8.9 The C format specification

    Section 5.7 covers the format options for writing strings out.  These
    format parameters differ in only a few ways.  These are:

      1 - Case is significant, the upper-case values will not necessarily work
      2 - The string must be preceded by a '%' sign
      3 - The 'R' for carriage return is not supported

    The following reiterates most of what is in section 5.7 (However,
    section 5.7 has examples).

    Here is a simplified explanation of the fields of a format statement:

            %[flags][width][.precision][l]type

         Each field of the format specification is a single
         character or number signifying a particular format
         option.  The following describes each field.

         The 'type' character determines whether the associated
         argument is interpreted as a character, string, or
         number.   The simplest format specification
         contains only a percent sign and a 'type' character. (For
         example: %s prints a string.) The 'type' characters are:

          d   Integer         Signed decimal integer
          i   Integer         Signed decimal integer
          u   Integer         Unsigned decimal integer
          o   Integer         Unsigned octal integer
          x   Integer         Unsigned hexadecimal integer  (abcdef)
          X   Integer         Unsigned hexadecimal integer  (ABCDEF)

          c  Character        Single character

          s  String           Characters printed up to the first null
                              character ('\0') or until 'precision'
                              is reached.

Flags:    An optional sequence of flag characters controls the
          justification of output and printing of signs, blanks,
          decimal points, and octal and hexadecimal prefixes.  The
          flag characters available are:

   Flag                Action                           Default
   ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    Ä          Left justify the result within        Right justify
               the field width.

    +          Prefix the output value with a        Sign appears only
               + or Ä sign if it is of a signed      for negative
               type.                                 signed values(Ä)

    blank      Prefix the output value with a        No blank
               blank (ASCII 32) if the output
               values is signed and positive;
               the "+" flag overrides the blank
               flag, and a positive signed value
               will be output with a sign.

    #          When used with o, x, or X, the        No prefix
               "#" flag prefixes any nonzero
               output value with 0, 0x, or 0X,
               respectively.

            More than one flag can appear in a format specification.

      Width:    The optional width specifier is a nonÄnegative decimal
                integer specifying the minimum number of characters to
                print, padding with blanks and zeros.  Width never causes
                a value to be truncated.

  Precision:    An optional precision specifier is a nonÄnegative decimal
                integer preceded by a period (.) which specifies the
                maximum number of characters printed for all or part of
                the output field, or the minimum number of digits printed
                for integer values.  Precision can cause truncation of
                the output value.  Here's how precision can affect
                different types:

d,i,o,u,x,X:    With any of these types, precision specifies the minimum
                number of digits to be printed. If number of digits is
                less than specified in precision, output is padded on the
                left with zeros.  The value is not truncated when the
                number of digits exceeds precision. By default, if
                precision is 0 or omitted, the precision is set to 1.

          c:    Precision has no effect.  By default, one character is
                printed.

          s:    Precision specifies the maximum number of characters to
                be printed. Characters in excess of precision are not
                printed. By default, characters are printed until a null
                character is encountered.  This will cause the leftmost
                characters of the string to be displayed.  The maxlen
                value (set by the "FMAX" command) will leave the
                rightmost characters.

Mandatory l:    The two status variables Bytes Received (2) and Bytes 
                Sent (3) require that an "l" precede the type element
                since these variables are of a the "long" data type.
                These values are long since they can be larger than
                65535.  Other variables should not have an "l" preceding
                the type specifier.
9.0 The D3-3780.CFG file and its options

D3-3780 will automatically look for a configuration file.  This file is 
named "D3-3780.CFG" (see the next section for details on how to change 
this name) and is a setup command file.  D3-3780 will look for the 
configuration file first in the current directory and then in the directory
which contains "D3-3780.EXE" (this name can be changed in the next section
also).  If the file doesn't exist then a default setup is used.

The filename can be overridden by putting the filename on the
command line.

Examples:

	C>D3-3780 file.cfg
	C>D3-3780 -Ffile.cmd file.cfg

The configuration file is fundamentally another command file.  However,
there are a couple of significant differences:  

  The most significant difference is that the modem has not been 
  initialized in any way when the file is run.  However, the "MSETH" 
  command can be used to initialize the modem in the configuration file.

  All video writes are automatically suppressed.  The "unsup" and "undsp"
  commands can be used to turn on video writes.  If you intend to use
  direct video writes within the command file then the "undsp" function
  must be performed.

  The branching is done using the slow "searching" technique rather than
  the faster table based technique (see section 5.1 on the "MB" variable).
  The branching technique cannot be changed within the file.

  Assigning values to the "CF" (command file name) and DP (Dash Parameter)
  status variables will have the desired effect.  These variables should 
  only be read in a normal command file but can be use instead of the 
  "-F" and "file.cmd" command line options if used in the configuration 
  file.  This allows D3-3780 to run any file without (DOS) command line 
  parameters.


Typically, this file will be used to save and restore the startup screen and
cursor location and to load the direct video screen and the format strings
for the status variables.  The configuration file itself can contain the
direct video screen and format strings.  See the descriptions of the "LSCRN"
and "LSTVS" options to see how this is done.


9.1 Setting the Package and Configuration filenames.

There is a utility program available to people with an extreme need to
customize D3-3780 named PACKINST.EXE.  This program allows you to 
change the name of the executable and configuration file by modifying the
executable program itself.  Run PACKINST.EXE from DOS with no parameters
and it will ask for three strings:

  The package name is the first parameter it will ask for.  This value is
  used in place of the "D3-3780" string in all prompts throughout the
  package.  If the package name were "packname" then the executable file
  should be "packname.exe", the help file "packname.hlp" and the default
  command file "packname.cmd" (used if -F is not followed by a filename).
  The package name is case sensitive since it is displayed in several
  places in the program.

  The startup (or configuration) filename is the second parameter which
  is asked for.  This name is normally, "D3-3780.CFG".  Any name can be
  used instead.

  The third value is the name of the executable in which to install the
  first two values.  If you have renamed the package from "D3-3780.EXE"
  then the new name should be entered here.  Otherwise press enter.

The installation modifies the executable file itself but does not affect
the time stamp of the executable file.  The time and date values can still
be trusted.

System Initilization Commands
----------------------------------------------------------------------------
lscrn  lstvs   mseth   sdefs   setpr   sform   smask   smax    so      sptyp
tabls  vtype
