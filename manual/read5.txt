@CHAPTER HEAD = Script Mode

<$M[Bmode]>Script mode has special variables and functions that are 
useful to it. Most of these are also available in interactive mode 
but are not particularly useful there. They are left in primarily 
to allow the person writing script files to more easily check out 
a function's behavior.

@SECTION HEAD = Built in Variables

<$M[Bvars]><$R[V*,Packname]D3-3780> maintains several variables that 
can be modified and branched from in script mode. Actually, these 
variables can be modified and displayed interactively since it may 
be convenient to experiment with them in that mode. All variables 
are integers unless otherwise mentioned. The variables and their suggested 
uses are listed below:

@LIST EDGE IND = <$IA#>A~, A0-A9

@LIST ITEM = Arguments. Pointer variables which point to the arguments
passed on the command line from DOS. Once the  program has begun executing
then these can be used as  normal pointers. A0 contains the path and
name of the executable program (ex: C:\D3\<$R[V*,Packname]D3-3780>.EXE).

@LIST EDGE IND = <$IAA>AA

@LIST ITEM = Argument Array. This is an array which contains all the DOS
command line parameters. The pointer variables A0-A9 point into this
array. The command line parameters are stored in the order that they were
entered on the command line and are separated only by the terminating 0
bytes.

@LIST EDGE IND = <$IAC>AC

@LIST ITEM = Argument count. This integer is initially set to the 
number of arguments passed on the DOS command line.

@LIST EDGE IND = <$IAE>AE

@LIST ITEM = ASCII<$IASCII> to <$IEBCDIC>EBCDIC conversion table. This is the table used
to convert the ASCII data files on the PC to EBCDIC on the line when 
sending using the <MI>Vary<D> or <MI>Fixed<D> buffer types. The variable 
is Read/Write so individual table entries can be changed if necessary. 
This table is only 128 bytes long. PC characters above 7F hex have 
their 8th bit cleared before being converted (this is why PC graphic 
characters cannot be sent in the <MI>Vary<D> or <MI>Fixed<D> modes).

@LIST EDGE IND = <$IAS>AS

@LIST ITEM = Add record separator<$iRecord Separator>. This option only has an effect
when sending using the <MI>Vary<D> buffer type and the record is longer
than the blocksize. If the value of <BI>AS<D> is 1 then a Record Separator
character will be added to the stream at the end of the block. If
it is a 0 then no record separator will be added.

@LIST EDGE IND = <$IBA>BA

@LIST ITEM = Base Address<$IBase Address>. This integer value is the lowest numbered
I/O port address of the modem. The modem occupies the sixteen locations
starting at this number in the port address space (actually, in the
non-PS/2 modems the modem also occupies four images in the address
space since bits 14 and 15 are not decoded).

@LIST EDGE IND = <$IBK>BK

@LIST ITEM = Bad Acknowledgment Limit. This is the maximum number
of bad acknowledgments to accept before generating an error. A zero 
value will cause it to try forever.

@LIST EDGE IND = <$IBL>BL

@LIST ITEM = Block Size<$IBlock Size>, this variable is the current size of the send
block size. It can be both read and assigned to with the desired effect.
<$R[V*,Packname]D3-3780> can accept block sizes up to 5000 bytes per
block.

@LIST EDGE IND = <$IBR>BR

@LIST ITEM = Blocks received in last or current reception. This value 
is read only.

@LIST EDGE IND = <$IBS>BS

@LIST ITEM = Blocks sent in last transmission. This value is also 
read only.

@LIST EDGE IND = <$ICA>CA

@LIST ITEM = The Change attribute variable. This is the attribute
which is used when <169>\19<170> escape character is encountered in 
a video write. It is also the value which is used when the highlighted 
filenames are returned to another value. It defaults to bright white 
on color screens and normal (low intensity) on monochrome screens. 
See Sections <$R[S*,Vidmodes]8.2> and <$R[S*,Attvars]8.3> for more
on attribute variables.

@LIST EDGE IND = <$ICB>CB

@LIST ITEM = This is the buffer in script mode which contains the 
current command. 

@LIST EDGE IND = <$ICC>CC

@LIST ITEM = <$ICursor>Cursor Column location. This value is read only.

@LIST EDGE IND = <$ICE>CE

@LIST ITEM = This one byte variable is the block ending character to be used
on remote commands. It is normally an EBCDIC ENQ (0x2D). <$R[V*,Packname]D3-3780> recognizes
this block as a remote command but other devices will treat this like a
bad block. This option exists to allow mainframe programmers to send and
receive remote commands.

@LIST EDGE IND = <$ICF>CF

@LIST ITEM = Configuration File<$IConfiguration File>. This is the name of the configuration
file which was used when <$R[V*,Packname]D3-3780> was executed.

@LIST EDGE IND = <$ICO>CO

@LIST ITEM = Compression<$ICompression>. If this value is 1 then space compression
is enabled; otherwise space compression is disabled. Compression only
affects sending with the <MI>Vary<D> buffer type.

@LIST EDGE IND = <$ICL>CL

@LIST ITEM = Command Line. The line of the script file which is currently 
executing. The first line is number 1 and succeeding line numbers 
increase sequentially. This is completely unrelated to the DOS command line.

@LIST EDGE IND = <$ICR>CR

@LIST ITEM = Cursor Row location. This value is read only.

@LIST EDGE IND = <$IDA>DA

@LIST ITEM = Default Attribute. This is the default video attribute 
used in direct video writes. It is used if no attribute is specified 
or after the <169>\18<170> escape sequence is used. See Sections <$R[S*,Vidatts]8.1> 
and <$R[S*,Attvars]8.3> for more on attribute variables.

@LIST EDGE IND = <$IDB>DB

@LIST ITEM = Data Buffer. This is a pointer which is typically used
as a data buffer by allocating space to it using the <BI>ALLOC<D>
function.

@LIST EDGE IND = <$IDC>DC

@LIST ITEM = This variable allows the DB-25 connector on the back of the
modem to be used as a DCE connector. If this variable is set to a non-zero
value then the modem can be driven by the connector during execution of
the <BI>PAUSE<D> command.

@LIST EDGE IND = <$IDD>DD

@LIST ITEM = Date-Day. The current day of the month. Read Only.

@LIST EDGE IND = <$IDF>DF

@LIST ITEM = Display variable<$IDisplay Variable> format strings. This is an
array of pointers to Display variable format strings (See the SFORM command)
and section .

@LIST EDGE IND = <$IDI>DI

@LIST EDGE IND = <$IDM>DM

@LIST ITEM = Date-Month. The current month. Read Only.

@LIST EDGE IND = <$IDO>DO

@LIST EDGE IND = <$IDP>DP

@LIST ITEM = This is the Dash Parameter value that was passed on the 
DOS command line. An 'F' can be assigned to it in the configuration 
file to cause script processing to be used instead of interactive. 
The name of the script file will default to the <169><$R[V*,Packname]D3-3780>.SCR<170> 
but can be assigned a value in the start up file (see <BI>SF<D> above).

@LIST EDGE IND = <$IDR>DR

@LIST ITEM = The current directory. String type, Read Only.

@LIST EDGE IND = <$IDS>DS

@LIST ITEM = Disk Space. If the disk space is less than 65535 this 
value will be the amount of available disk space on the logged drive. 
Otherwise the value of ds will be 65535.

@LIST EDGE IND = <$IDT>DT

@LIST ITEM = The primary DOS version number.

@LIST EDGE IND = <$IDV>DV

@LIST EDGE IND = <$IDY>DY

@LIST ITEM = Date-Year. The current year. Read Only.

@LIST EDGE IND = <$IEA>EA

@LIST ITEM = EBCDIC to ASCII conversion table. This is the conversion 
table used to convert from EBCDIC on the line to ASCII in the PC when 
receiving using the <MI>Vary<D> or <MI>Fixed<D> types. It is Read/Write 
and is 256 bytes long.

@LIST EDGE IND = <$IED>ED

@LIST ITEM = Emulation Directory. The directory which contains the 
<$R[V*,Packname]D3-3780>.EXE file. If using DOS 2.XX the path must 
contain the emulation directory for this value to be correct. If using 
DOS 3.XX or 4.XX the value will always be correct.

@LIST EDGE IND = <$IEF>EF

@LIST ITEM = Exit file. This is the name of a script file which will 
automatically be executed when the package is exited. If the string 
contains a label instead, then the configuration file will be reloaded 
and execution will begin at the location of the label.

@LIST EDGE IND = <$IEI>EI

@LIST ITEM = Error Indicator. This variable is the errorlevel of the 
most recent operation. This value is reset on EVERY instruction (even 
comments). It is read only.

@LIST EDGE IND = <$IEL>EL

@LIST ITEM = Error Line. This variable is the line number of the most 
recent operation that had a non-zero <BI>EI<D> value. The value remains 
until the next non-zero error <BI>EI<D> value occurs. It is read and 
write.

@LIST EDGE IND = <$IEM>EM

@LIST ITEM = Errormessages. This array of pointers contains the error 
messages which <$R[V*,Packname]D3-3780> uses. The indexes of the messages 
are the error numbers. This allows the error messages to be modified.

@LIST EDGE IND = <$IEN>EN

@LIST EDGE IND = <$IEP>EP

@LIST ITEM = Error Persist. This variable is the errorlevel of the 
most recent operation that had a non-zero error indicator. The value 
remains until the next non-zero error occurs. It is read and write.

@LIST EDGE IND = <$IEQ>EQ

@LIST ITEM = Enquiry Limit. The number of consecutive enquiries which 
must occur before a send or receive will generate an error. 0 means 
try forever.

@LIST EDGE IND = <$IER>ER

@LIST ITEM = Enquiries received. The number of enquiries received 
in the last reception. Read only.

@LIST EDGE IND = <$IES>ES

@LIST ITEM = Enquiries sent. The number of enquiries sent in the last 
transmission. Read only.

@LIST EDGE IND = <$IEV>EV

@LIST EDGE IND = <$IFB>FB

@LIST EDGE IND = <$IG#>G~,G0-G9

@LIST ITEM = General purpose integers. These are general purpose integer 
variables which can be used for loop counters, mathematical operations, 
flags and indices into arrays.

@LIST EDGE IND = <$IGA>GA

@LIST ITEM = Graph Attribute. This is the video attribute byte for 
ASCII characters above 7F hex in video writes. The attribute is generally 
used for borders of boxes. The <169>\21<170> escape sequence will 
also set the color to the Graph Attribute. See Sections <$R[S*,Vidatts]8.1> 
and <$R[S*,Attvars]8.3> for more on attribute variables.

@LIST EDGE IND = <$IGE>GE

@LIST ITEM = Graph Enable. If this value is 7F hex then the characters 
numbered above 7F are written out using the graph attribute. If the 
value is FF then the automatic setting of the graph attribute is disabled.

@LIST EDGE IND = <$IHA>HA

@LIST ITEM = High Attribute. This is the attribute used to highlight 
the sending or receiving file names and conversion types when they 
are active. It defaults to Light Cyan in color and High intensity 
in monochrome. The <169>\20<170> escape sequence enables this attribute. 
See Sections <$R[S*,Vidatts]8.1> and <$R[S*,Attvars]8.3> for more 
on attribute variables.

@LIST EDGE IND = <$IHC>HC

@LIST ITEM = Hide Cursor. If this variable is set to one then the 
cursor is hidden. If it is reset to one then the cursor will return.

@LIST EDGE IND = <$II#>I~, I0-I9

@LIST ITEM = General purpose integers.

@LIST EDGE IND = <$IID>ID

@LIST ITEM = Idle Limit. This value is the number of ticks (which 
occur 18.2 times a second) before a reception will be aborted. 0 means 
wait forever. Time counting does not run while waiting for a reception 
to begin, it begins once the reception has started. Note: The timeout 
for the <BI>W<D> command does not timeout once a reception has been 
started. This value will cause an error if activity halts during the 
reception.

@LIST EDGE IND = <$IIO>IO

@LIST EDGE IND = <$IIT>IT

@LIST ITEM = Interrupt. This is the modems interrupt level. It should 
be either a 2,3,4 or 5.

@LIST EDGE IND = <$IK#>K0-K9

@LIST ITEM = General purpose pointer arrays.

@LIST EDGE IND = <$IKA>KA

@LIST ITEM = Key Attribute. This is the default attribute used for 
keyboard input in the interactive mode. Its default values are the 
same as the default attribute. See Sections <$R[S*,Vidatts]8.1> and 
<$R[S*,Attvars]8.3> for more on attribute variables.

@LIST EDGE IND = <$IKR>KR

@LIST ITEM = Naks received in last reception. Read only.

@LIST EDGE IND = <$IKS>KS

@LIST ITEM = Naks sent in last transmission. Read only.

@LIST EDGE IND = <$IL#>L0-L9

@LIST EDGE IND = <$ILE>LE

@LIST EDGE IND = <$ILF>LF

@LIST ITEM = List file. String which is the name of the current listing 
file. The name will be <169>NUL<170> if no listing file is being used. 
String type. Read only (use the <BI>LF<D> command to change the value 
of this variable).

@LIST EDGE IND = <$IM#>M0-M9

@LIST EDGE IND = <$IMB>MB

@LIST ITEM = Memory Branching. This is a boolean value which sets 
the branching type of the script file. There are two branching techniques 
supported in <$R[V*,Packname]D3-3780>. One is slow but requires no 
additional memory and the other is fast but requires some memory (if 
enough memory cannot be obtained then the slow technique is always 
used). If this value is 1 (the default) the fast technique is used; 
otherwise the slow technique is used. The value of <BI>MB<D> must 
be set before the script file is executed and applies to the original 
script file and any files loaded using the <BI>CALL<D> or <BI>XB<D> 
commands. You may want to set the value to 0 if you have several very 
large buffers and are getting the <169><F1P10M>Insufficient internal 
memory<F255P255D><170> error number 93.

@LIST EDGE IND = <$IML>ML

@LIST EDGE IND = <$IMN>MN

@LIST EDGE IND = <$IMS>MS

@LIST EDGE IND = <$IMT>MT

@LIST EDGE IND = <$IMV>MV

@LIST ITEM = Modem Version. The version number of the modem.

@Z_TBL_BEG = COLUMNS(4), DIMENSION(IN), WIDTH(4.0000), HGUTTER(.0560), 
VGUTTER(.0560), BOX(Z_DOUBLE), HGRID(Z_SINGLE), VGRID(Z_SINGLE), KEEP(ON), 
ALIGN(RT), L2(R2C0..R2C4), L2(R1C0..R1C4), L2(R0C2..R11C2)

@Z_TBL_BODY = TABLE TEXT, TABLE TEXT, TABLE TEXT, TABLE TEXT

XT/AT Bus<$!B11>, +, PS/2<$!B11>, +

# (Hex)<$!B11>, Name<$!B11>, # (Hex)<$!B11>, Name<$!B11>

0, 201C, 80, 2/201

1, 208 A/B, 81, 2/208/201

2, 9600B, 82, None

3, 201/212, 83, 2/201/212

4, V.26, 84, None

5, V.22, 85, 2/V.22

6, T9628B, 86, 2/T9628B

7, 4824, 87, None

8, V.32, 88, 2/V.32

@Z_TBL_END = 

@LIST ITEM = <169>FF<170> means the version number is unavailable.

@LIST EDGE IND = <$IN#>N#

@LIST ITEM = Punch auto-naming index. This is the number in the extension 
of the punch file name (or 0 if no number). The value is read only 
but the <BI>DN<D> command can be used to set the number.

@LIST EDGE IND = <$IN#>N0-N9

@LIST ITEM = General purpose integer array variables.

@LIST EDGE IND = <$INA>NA

@LIST ITEM = Punch Auto-Naming value. Scalar, 0 means disabled, 1 
means enabled. The auto-naming option can be changed by modifying 
this value.

@LIST EDGE IND = <$INK>NK

@LIST ITEM = No acknowledgment limit. This is the maximum number of 
no acknowledgments before a reception or transmission is aborted. 
0 means there is no limit.

@LIST EDGE IND = <$INN>NN

@LIST ITEM = String variable which points to the punch name. This 
value can have strings assigned to it which will affect the next reception.The 
maximum length is 65 characters.

@LIST EDGE IND = <$INS>NS

@LIST ITEM = Punch Standard buffer type. Scalar.

@Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), WIDTH(4.0000), HGUTTER(.0560), 
VGUTTER(.0560), BOX(Z_DOUBLE), HGRID(Z_SINGLE), VGRID(Z_SINGLE), KEEP(OFF), 
ALIGN(RT), L2(R1C0..R1C2)

@Z_TBL_BODY = TABLE TEXT, TABLE TEXT

Value<$!B11>, Meaning<$!B11>

0<$!B10>, Vary<$!B10>

1<$!B10>, Fixed<$!B10>

2<$!B10>, Binary<$!B10>

3<$!B10>, Hex<$!B10>

@Z_TBL_END = 

@LIST ITEM = This variable is read and write.

@LIST EDGE IND = <$INT>NT

@LIST ITEM = Punch Transparent buffer type. The values correspond 
to the buffer types as in NS variable above.  This scalar is read 
and write.

@LIST EDGE IND = <$INU>NU

@LIST ITEM = NULL pointer. This is a dummy constant value which is 
used to to indicate that a pointer does not point to anything. There 
are circumstances in which this value should be assigned to a pointer. 
Section <$R[S*,Poifunds]5.6> describes the way the <BI>NU<D> variable 
should be used.

@LIST EDGE IND = <$INY>NY

@LIST EDGE IND = <$IO#>O0-O9

@LIST ITEM = General purpose integer array variables.

@LIST EDGE IND = <$IOC>OC

@LIST EDGE IND = <$IOG>OG

@LIST EDGE IND = <$IP#>P#

@LIST ITEM = Printer auto-naming index. Same as <BI>N#<D> above except 
that it applies to the printer.

@LIST EDGE IND = <$IP#>P~, P0-P9

@LIST ITEM = Pointer variables. These are general purpose pointer 
variables. They can be used to point to buffers that are being allocated 
or within previously allocated buffers. They are also useful in many 
string operations. Note that all pointer variables can be indexed 
as if they were arrays.

@LIST EDGE IND = <$IPA>PA

@LIST ITEM = Printer Auto-naming value. Similar to <BI>NA<D> above.

@LIST EDGE IND = <$IPB>PB

@LIST EDGE IND = <$IPK>PK

@LIST EDGE IND = <$IPN>PN

@LIST ITEM = Printer filename. Similar to <BI>NN<D> above.

@LIST EDGE IND = <$IPP>PP

@LIST EDGE IND = <$IPS>PS

@LIST ITEM = Printer Standard buffer type. Similar to <BI>NS<D> above.

@LIST EDGE IND = <$IPT>PT

@LIST ITEM = Printer Transparent buffer type. Similar to <BI>NT<D> 
above.

@LIST EDGE IND = <$IRA>RA

@LIST ITEM = Reverse Attribute. The attribute used for reverse video 
in direct video writes. It is activated by using the <169>\22<170> 
escape sequence. See Sections <$R[S*,Vidatts]8.1> and <$R[S*,Attvars]8.3> 
for more on attribute variables.

@LIST EDGE IND = <$IRC>RC

@LIST EDGE IND = <$IRE>RE

@LIST EDGE IND = <$IRL>RL

@LIST ITEM = Receive Record length. This value is used to set the 
implied record length of incoming data when the <MI>Fixed<D> buffer 
type is used.

@LIST EDGE IND = <$IRM>RM

@LIST EDGE IND = <$IRN>RN

@LIST EDGE IND = <$IRS>RS

@LIST ITEM = Receive Size. The size of the last reception. Read only.

@LIST EDGE IND = <$IRT>RT

@LIST ITEM = Receive type. Indicates the type of the last reception. 
The possible values are:

@Z_TBL_BEG = COLUMNS(3), DIMENSION(IN), COLWIDTHS(E1,E2,E4), WIDTH(4.0000), 
HGUTTER(.0560), VGUTTER(.0560), BOX(Z_DOUBLE), HGRID(Z_SINGLE), VGRID(Z_SINGLE), 
KEEP(ON), ALIGN(RT), L2(R1C0..R1C3)

@Z_TBL_BODY = TABLE TEXT, TABLE TEXT, TABLE TEXT

Value<$!B11>, Mode<$!B11>, Received<$!B11>

0, None, No reception since boot up

1, Standard, Printer

2, Standard, Punch

3, Transparent, Printer

4, Transparent, Punch

@Z_TBL_END = 

@LIST ITEM = This value is read only. 

@LIST EDGE IND = <$IS#>S~,S0-S9

@LIST EDGE IND = <$ISC>SC

@LIST ITEM = The direct video screen. This is a pointer to the screen 
to be displayed. It is both read and write and can even be assigned 
new pointer values. Multiple screens can be loaded and this value 
can be changed to point to different screens for display. Such a technique 
causes new screens to pop up very quickly.

@LIST EDGE IND = <$ISD>SD

@LIST ITEM = Send Destination. Scalar.

@Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), WIDTH(4.0000), HGUTTER(.0560), 
VGUTTER(.0560), BOX(Z_DOUBLE), HGRID(Z_SINGLE), VGRID(Z_SINGLE), KEEP(ON), 
ALIGN(RT), L2(R1C0..R1C2)

@Z_TBL_BODY = TABLE TEXT, TABLE TEXT

Value<$!B11>, Destination<$!B11>

0, Printer

1, Punch

@Z_TBL_END = 

@LIST ITEM = The variable is both read and write. 

@LIST EDGE IND = <$ISF>SF

@LIST ITEM = Script File. The name of the currently executing script 
file. Not relevant in interactive mode. This value can only be written 
to in the configuration file. The script file will execute when the 
configuration file is finished executing if the <BI>DP<D> value is 
set to 'F' (See the <BI>DP<D> variable that follows).

@LIST EDGE IND = <$ISL>SL

@LIST EDGE IND = <$ISM>SM

@LIST ITEM = Send Mode. Scalar.

@Z_TBL_BEG = COLUMNS(3), DIMENSION(IN), WIDTH(4.0000), HGUTTER(.0560), 
VGUTTER(.0560), BOX(Z_DOUBLE), HGRID(Z_SINGLE), VGRID(Z_SINGLE), KEEP(ON), 
ALIGN(RT), L2(R1C0..R1C3)

@Z_TBL_BODY = TABLE TEXT, TABLE TEXT, TABLE TEXT

Value<$!B11>, Mode<$!B11>, Buffer Type<$!B11>

0, Standard, Variable

1, Standard, Fixed

2, Standard, Binary

3, Standard, Hex

4, Transparent, Variable

5, Transparent, Fixed

6, Transparent, Binary

7, Transparent, Hex

@Z_TBL_END = 

@LIST ITEM = This variable is both read and write.

@LIST EDGE IND = <$ISN>SN

@LIST ITEM = Send name. String type, Read only.

@LIST EDGE IND = <$ISR>SR

@LIST ITEM = Send Record Length. The implied record length in a <MI>Fixed<D> 
buffer type send. This determines the number of blanks padded on the 
left for this type.

@LIST EDGE IND = <$ISS>SS

@LIST ITEM = Send size. The size of the last send.

@LIST EDGE IND = <$IST>ST

@LIST EDGE IND = <$ISV>SV

@LIST ITEM = System variables. This is a pointer to a ragged array 
containing all the format strings for the display variables. It is 
primarily included so the '!' operator can be used for you to check 
the amount of memory your format strings are occupying. This value 
is a pointer and can be reassigned but this is not recommended.

@LIST EDGE IND = <$ITB>TB

@LIST ITEM = Trailing Blanks. This determines if blanks at the end 
of a record are transmitted when sending with the <MI>Vary<D> buffer 
type. If it is 0, then trailing blanks are not sent (like a real 3780). 
If it is a 1, then trailing blanks are sent (this is the default value).

@LIST EDGE IND = <$ITH>TH

@LIST ITEM = Time-Hour. The current hour. Read Only.

@LIST EDGE IND = <$ITI>TI

@LIST ITEM = Timeout. This is the time (in ticks, 18.2 ticks per second) 
between re-enquiries when sending. This value is typically set for 
3 seconds (55 ticks).

@LIST EDGE IND = <$ITM>TM

@LIST ITEM = Time-Minute. The current Minute. Read Only.

@LIST EDGE IND = <$ITS>TS

@LIST ITEM = Time-Second. The current Second. Read Only.

@LIST EDGE IND = <$ITW>TW

@LIST EDGE IND = <$IUA>UA

@LIST ITEM = Underline Attribute. This attribute defaults to underline 
in monochrome mode and red in color mode. The <169>\23<170> escape 
sequence is used to enable it. See Sections <$R[S*,Vidatts]8.1> and 
<$R[S*,Attvars]8.3> for more on attribute variables.

@LIST EDGE IND = <$IVA>VA

@LIST ITEM = Version-Major. The major number of the DOS version number.

@LIST EDGE IND = <$IVB>VB

@LIST ITEM = Version-Bisync. The version of <$R[V*,Packname]D3-3780> 
multiplied by a 1000.

@LIST EDGE IND = <$IVE>VE

@LIST EDGE IND = <$IVI>VI

@LIST ITEM = Version-Minor. The minor number of the DOS version number.

@LIST EDGE IND = <$IVL>VL

@LIST EDGE IND = <$IVM>VM

@LIST ITEM = Video Mode.

@Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), COLWIDTHS(E1,E5), WIDTH(4.0000), 
HGUTTER(.0560), VGUTTER(.0560), BOX(Z_DOUBLE), HGRID(Z_SINGLE), VGRID(Z_SINGLE), 
KEEP(OFF), ALIGN(RT), L2(R1C0..R1C2)

@Z_TBL_BODY = TABLE TEXT, TABLE TEXT

Value<$!B11>, Meaning<$!B11>

2, Color Card on Monochrome Monitor

3, Color Card

7, Monochrome Card

@Z_TBL_END = 

@LIST ITEM = See Section <$R[S*,Vidmodes]8.2> for more on video modes.

@LIST EDGE IND = <$IVS>VS

@LIST EDGE IND = <$IWA>WA

@LIST ITEM = Window Attribute. This is the default attribute used 
for writes in the scrolling window. It is low intensity white for 
color monitors and normal for monochrome. See Sections <$R[S*,Vidatts]8.1> 
and <$R[S*,Attvars]8.3> for more on attribute variables.

@LIST EDGE IND = <$IWB>WB

@LIST ITEM = Window Bottom. The line number of the bottom line of 
the scrolling window.

@LIST EDGE IND = <$IWR>WR

@LIST ITEM = Window Right. The column number of the rightmost column 
of the scrolling window.

@LIST EDGE IND = <$IWL>WL

@LIST ITEM = Window Left. The column number of the leftmost column 
of the scrolling window.

@LIST EDGE IND = <$IWT>WT

@LIST ITEM = Window Top. The line number of the top line of the scrolling 
window.

The following sections will describe how these variables can be used 
and the operations which can be performed on them.

@SECTION HEAD = Constants

<$M[Constants]>Numeric constants are the normal numbers 0-9, numbers 
contained in <169><<>><170>, hex numbers <<hFF>> and characters in single 
quotes 'A'.

Examples:

@LIST EDGE IND = <<hff>>

@LIST ITEM = hexadecimal FF or decimal 255

@LIST EDGE IND = 'A'

@LIST ITEM = The ASCII a character, hex 41 or decimal 65

@LIST EDGE IND = 89

@LIST ITEM = Just like it looks, decimal 89

@LIST EDGE IND = <<<->-89>>

@LIST ITEM = Decimal -89. The <169><<>><170> symbols are required for 
hexadecimal or negative numbers.

@LIST EDGE IND = <<45>>

@LIST ITEM = Decimal 45, The <169><<>><170> symbols are not required 
but don't hurt anything either.

@OUTDENT ITEM = Note: There is one place where <<45>> would be treated 
differently than 45. This is in the destination field of a branching 
instruction. See Section <$R[S*,Labels]5.4> on labels for more on 
this.

A string constant is a series of characters enclosed in double quotes.

Example:

"This is a dummy string"

@OUTDENT ITEM = Note: Strings are terminated by <$R[V*,Packname]D3-3780> 
with a hex 0. If this string were copied into a buffer then a hex 
0 would be copied to the location past the <169>g<170> to indicate 
that the string was finished.

String constants can contain certain escape sequences to allow the 
entering of special data. The escape sequences begin with a backslash 
and are followed by other characters to describe the desired operation.

These escape sequences are:

@Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), COLWIDTHS(E1,E4), HGUTTER(.0560), 
VGUTTER(.0560), BOX(Z_DOUBLE), HGRID(Z_SINGLE), VGRID(Z_SINGLE), KEEP(ON), 
L2(R1C0..R1C2)

@Z_TBL_BODY = TABLE TEXT, TABLE TEXT

Sequence<$!B11>, Description<$!B11>

\###, Where <169>###<170> is any decimal number from 0-255. This number 
is entered directly into the string.

\+###, Functionally identical to \### above

\-###, Similar to \### except number is negative

\x##, Similar to \### except number is in hexadecimal

\a, Same as \7 (a bell in a video write)

\b, Same as \8 (a backspace)

\t, Same as \9 (a tab)

\n, Same as \10 (a linefeed)

\v, Same as \11 (Scrolls the screen in a video write)

\f, Same as \12 (Form Feed,, Clears the screen in a video write)

\r, Same as \13 (a carriage return)

@Z_TBL_END = 

See Section <$R[S*,Videscs]8.4> for more on the video functions of 
these escape sequences.

@SECTION HEAD = Special Symbols

<$M[Symbols]><$R[V*,Packname]D3-3780> uses several special symbols 
to perform operations on and distinguish variables. Every reference 
to a variable must begin with one of these symbols in order to keep 
it from being interpreted as a filename. The symbols are listed below. 


@SYMBOL NAME = Variable Indicator:

@SYMBOL ITEM = % (percent sign) 

Used to designate that this is an internal variable (not a filename). 
Whenever a variable is accessed in a normal fashion the <169>%<170> 
sign is used to distinguish the variable name from the equivalent 
filename. 

@SYMBOL NAME = Index Indicators:

@SYMBOL ITEM = [] (brackets)

Used to index into buffer or pointer variables. This use of the bracket 
mimics several programming languages. Arrays are indexed from 0 rather 
than 1. The value can be used on the DB and P0-P9 variables and any 
other pointer variables. Once a pointer is set to point to a location 
then it can be indexed as if it were an array starting at that location. 
The value inside the brackets can be anything which evaluates to a 
scalar. 

For Example:

@LIST = Given db = 0 1 5 3 4 7 6 2 . . 

@LIST = i0 = 0 

@LIST = i1 = 5 

@LIST = p0 points to db[3]

@LIST = %db[5]=7 The character at location 5 in the db buffer which 
is 7. 

@LIST = %db[%i1]=7 Since the i1 integer is 5 then the same as above. 


@LIST = %db[%db[2]]=7 Since 5 is at db[2] then this is the same as 
%db[5] or 7. 

@LIST = %db[%db[%p0[2]]]=5 Since p0[0] is db[3] then p0[2] is db[5]=7 
so %db[%p0[2]]=%db[7]=2 and so result=%db[2]=5. 

The last two examples shows that the index can be another value with 
an index. There is no limit in <$R[V*,Packname]D3-3780> to the number 
of times indexes can have other indexes within them. 

@SYMBOL NAME = <169>address of<170> Indicator:

@SYMBOL ITEM = & (ampersand) 

The <169>address of<170> operator. Used to indicate the address of 
a value rather than the value itself; this is normally used in conjunction 
with the an indexed pointer.

For example:

@EXAMPLES =  mov %p0,&db[1000]

This assigns the address of the character DB[1000] to the pointer 
variable P0. P0 could then be indexed like an array starting at DB[1000].

@SYMBOL NAME = <169>value pointed to<170> Indicator:

@SYMBOL ITEM = @@ (at sign)

The value pointed to by a pointer variable.

For example:

@EXAMPLES = mov %p0,&db[1000] 

@EXAMPLES = mov %i0,@p0

I0 would be set equal to the value at DB[1000]. This value is equivalent 
to indexing at zero (@P0 is the same as %P0[0]). This is a useful 
shorthand notation since the first value is frequently needed. 

In script mode, this symbol can also be used to precede a command 
name to stop the command from being echoed to the screen.

@SYMBOL NAME = <169>number<170> indicator:

@SYMBOL ITEM = # (pound sign)

Used to convert a string (containing numbers) into the number itself. 


@EXAMPLES = cpy %p0,"789"

@EXAMPLES = mov %i0,#p0

The CPY command copies the string <169>789<170> to the location pointed 
to by P0. Then the value 789 decimal is assigned to I0 since #P0 evaluates 
to decimal 789. The #P0 could be used anywhere a numeric constant 
is needed, even as an index. 

@SYMBOL NAME = <169>make string<170> Symbol:

@SYMBOL ITEM = $ (dollar sign)

Used to turn an integer into a string.For Example:

@EXAMPLES = mov %i0,67 

@EXAMPLES = cpy %p0,$i0

This would cause the string <169>67<170> to be copied to the location 
pointed to by P0. The <169>$<170> operator is supported on all integer 
variables. 

An internal string with a limited lifetime is created by this command. 
Specifically, newer uses of the <169>$<170> sign operator may destroy 
the older values. The values are guaranteed to be valid within 10 
uses of the <169>$<170> operator. After that the oldest value may 
be destroyed by the newest value. 

@SYMBOL NAME = <169>length<170> Indicator:

@SYMBOL ITEM = ! (exclamation point)

This will return the length of a variable or (more importantly) the 
length of the buffer which a pointer points to. This is useful for 
diagnostics when memory overflow problems occur. 

In script mode, this symbol can also be used to suppress all output 
from a command including the echo of the command itself.

@SYMBOL NAME = Type Override Symbol:

@SYMBOL ITEM = ^ (carat)

To cause a string to be interpreted as a filename or a label. This 
is used when a string contains a filename of label. For example:

@EXAMPLES = mov %p5,":out"

@EXAMPLES = go,^%p5

If the symbol begins with a <169>:<170> then it will be interpreted 
as a label, otherwise it will be interpreted as a filename (In DOS, 
filenames cannot begin with a colon).

The GO statement needs to see a label or line number. If the carat 
were not there then it would look for a label called %P5 

@SYMBOL NAME = Operator Override:

@SYMBOL ITEM = ] (closed bracket) 

Used to start filenames which begin with a special symbol or number. 
If a filename begins with one of the operators it can be forced to 
be viewed as a filename by putting a <169>]<170> in front of it. 

For example:

@EXAMPLES = open 0,]89file. txt

The second parameter would not be recognized as a filename unless 
the bracket preceded it. 

@SECTION HEAD = Labels

<$M[Labels]>Labels are used as the destination in script branching 
instructions. They begin in the first column of a line and must always 
begin with a <169>:<170>. There is currently no limit to how long 
you can make a label or how many labels are in a given file. Regardless 
of how many characters you use <$R[V*,Packname]D3-3780> checks for 
a perfect match. See Section <$R[S*,Branches]6.1> on branch instruction 
for more information on labels.

@SECTION HEAD = <MI>Scalar<D> and <MI>Pointer<D> as used in this document.

<$M[Scpoi]>There are two basic types of variables used in the <$R[V*,Packname]D3-3780> 
script language. These are scalars and pointers.

Scalars are:

@Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), HGUTTER(.0560), VGUTTER(.0560), 
BOX(Z_DOUBLE), HGRID(Z_SINGLE), VGRID(Z_SINGLE), KEEP(OFF), L2(R1C0..R1C2)

@Z_TBL_BODY = TABLE TEXT, TABLE TEXT

Description<$!B11>, Examples<$!B11>

Decimal and Hexadecimal Constants, 89   <<hFF>>

Character Constants, 'A'   'B'   'C'

Integer Variables, %i0   %i9   %bl

Members of arrays, %db[5]   %p0[3]   %nn[8]

Pointers with the @ sign, @p0   @p6   @sc

Pointers with the # sign, #p0   #db

@Z_TBL_END = 

Pointers are:

@Z_TBL_BEG = COLUMNS(2), DIMENSION(IN), HGUTTER(.0560), VGUTTER(.0560), 
BOX(Z_DOUBLE), HGRID(Z_SINGLE), VGRID(Z_SINGLE), KEEP(OFF), L2(R1C0..R1C2)

@Z_TBL_BODY = TABLE TEXT, TABLE TEXT

Description<$!B11>, Examples<$!B11>

String Constants, "a string"   "Golly Wolly"

Pointer Variables, %p0   %db   %sc   %p9

Integers with the $ sign, $i0   $bl   $i9

Indexed Arrays with the & sign, &dp[5]   &p0[1000]   &sc[%i0]

@Z_TBL_END = 

The word <169>string<170> is used to refer to pointers which point 
to ASCII data which uses a 0 character to signify the end of the data. 
The word <169>buffer<170> is used for pointers to any type of data 
that have some memory available at the location they point to. Labels 
and filenames are stored internally as strings but they are treated 
differently by most functions. 

@SECTION HEAD = Pointer Variable Fundamentals

<$M[Poifunds]>One of the more complicated parts of writing <$R[V*,Packname]D3-3780> 
script files is handling pointer variables and, in general, memory 
allocation. 

A pointer variable is a variable which can contain an address in the 
computer's memory. In <$R[V*,Packname]D3-3780>, most pointer variables 
are initially set to an invalid value (some status pointers are set 
to point to specific things by default). This invalid value is referred 
to as <169>NULL<170>. If you attempt to write a null pointer, <169>(null)<170> 
will be displayed. If you try to copy data to the location pointed 
to by a null pointer, an error will result. 

Values are assigned to pointers in several of <$R[V*,Packname]D3-3780>'s 
commands. Some commands tell <$R[V*,Packname]D3-3780> to reserve some 
memory for the variable and change the value of the pointer to <169>point<170> 
to the reserved memory (ALLOC, ALLST, GETXT). Other commands allow 
the pointer to be assigned a value that points within memory that 
has already been allocated (STC, STST, MOV). 

The REALL adjusts the amount of memory which a pointer points to and 
the FREE function gives the memory back that was allocated (and sets 
the pointer to NULL). 

In <$R[V*,Packname]D3-3780>, when a pointer is assigned a value a 
length is also assigned (internally) which indicates how much memory 
is reserved at the location the pointer points to. This length is 
frequently used when data is transferred to or from the location the 
pointer points to (LOAD, GBUF, RDLN, etc. ). 

@SECTION HEAD = Common Pointer Errors

<$M[Poierrs]>There are several possible errors which are easy to make 
by incorrectly using pointers. These errors may be difficult to detect 
since the error message frequently lags the actual error.

@MINOR HEAD = Writing to a location that does not have memory allocated 
to it

Example:

@EXAMPLES = free %p0 

@EXAMPLES = cpy %p0,"A dummy string". 

The P0 variable cannot have any memory allocated to it since the free 
command gave it all back. This will result in a NULL pointer assignment 
error [77]. The same error will occur if the pointer is never assigned 
a value (P0 is initially NULL). 

A more subtle form of this error is when two pointers have been pointing 
to the same area and one is used to free the memory. The other pointer 
will no longer be pointing to allocated memory but its value will 
not be NULL.

Example:

@EXAMPLES = allst %p0,"Allocate memory to the %p0 variable"

@EXAMPLES = mov %p1,%p0 

@EXAMPLES = free %p0 

@EXAMPLES = cpy %p1,"No message will be displayed"

The problem with this code is that the FREE gave all the memory back 
to the system but the second pointer P1 continues to use the memory. 
This error will not result in an immediate error but may cause trouble 
later on. It is a good practice to set invalid pointers to NULL. This 
is accomplished by using the NU variable.

Example:

@EXAMPLES = allst %p0,"Allocate memory to the %p0 variable"

@EXAMPLES = mov %p1,%p0 

@EXAMPLES = free %p0 

@EXAMPLES = mov %p1,%nu 

@EXAMPLES = allst %p1,"This is an no longer an error"

@MINOR HEAD = Writing to a read only variable via a pointer variable

Another possible error is to write to a read only variable by first 
assigning a pointer to the read only variable. An error message will 
be displayed if you try to assign to a read only variable directly 
but no error will be generated if a pointer variable is used to do 
it.

Example:

@EXAMPLES = mov %p0,%ed 

@EXAMPLES = cpy %p0,"garbage. dir"

This would destroy the emulation directory (which can stop the cleanup 
section of the configuration file from executing properly). 

@MINOR HEAD = Failing to free unused memory 

When memory has served its purpose it should be freed using the FREE 
command or by allocating it for another purpose (the alloc and allst 
automatically free a non-NULL pointer if it is passed to them).

Example:

@EXAMPLES = alloc %p0,400 

@EXAMPLES = srite %p0,"/copy "+%p1+" "+%p2 

@EXAMPLES = intrp %p0 

@EXAMPLES = mov %p0,%nu

The first command created a temporary buffer. The second command assigned 
a value to the buffer and the third used the value in the buffer. 
The fourth command destroyed the only pointer to the allocated memory 
without first giving the memory back to the system. This is a waste 
of 400 bytes of memory which is unusable until you exit <$R[V*,Packname]D3-3780>.

Correct Examples:

@EXAMPLES = alloc %p0,400 

@EXAMPLES = srite %p0,"/copy "+%p1+" "+%p2 

@EXAMPLES = intrp %p0 

@EXAMPLES = free %p0

or

@EXAMPLES = alloc %p0,400 

@EXAMPLES = srite %p0,"/copy "+%p1+" "+%p2 

@EXAMPLES = intrp %p0 

@EXAMPLES = allst %p0,"Some string which will be useful later"

Both of these examples give memory back when they are through with 
it. The first example does this by using a free command (this command 
also assigns NULL to the pointer). The second uses the pointer as 
the argument to the allst command. This command will automatically 
free the memory pointed to by a pointer if the pointer value is not 
NULL. The alloc command will also free non-NULL pointers. 

@MINOR HEAD = Freeing a pointer which was never alloced

This error occurs when a non-NULL pointer whose value was not assigned 
with an alloc, allst or reall is used as an argument to a free, allst 
or alloc command.

Example:

@EXAMPLES = allst %p0,"Never eat raw vegetables."

@EXAMPLES = mov %p1,&p0[6] 

@EXAMPLES = rite %p1 

@EXAMPLES = allst %p1,"This is a subtle error."

The last statement causes the value of P1 to be freed (since P1 is 
not NULL but it does not point to an allocated memory block). 

A corrected version is:

@EXAMPLES = allst %p0,"Never eat raw vegetables."

@EXAMPLES = mov %p1,&p0[6] 

@EXAMPLES = rite %p1 

@EXAMPLES = mov %p1,%nu 

@EXAMPLES = allst %p1,"This is no longer an error."

The assignment of NULL to P1 stops the allst command from assuming 
that P1 points to an allocated memory block. 

I may add some more run time checking to correct or point generate 
errors for some of these conditions (especially the last one). 

@SECTION HEAD = Suppressing Video Output using '@' and '!'

<$M[Suppat]>Several techniques and commands are offered to suppress 
the different kinds of video writes. The two symbols '@' and '!' can 
be used immediately before a command to perform a very short suppression 
of video. The '@' symbol is used to stop the command itself from being 
echoed to the screen. The '!' stops the command and any of its writes 
from being echoed (except for the rite command).

Examples:

@EXAMPLES = !dl "1 (205) 881-8183"

@EXAMPLES = * All status messages "dl" will be suppressed.

A variety of other commands exist to suppress video for a set of lines 
but these two are useful when you merely want to suppress the output 
in a few specific instances. 

@SECTION HEAD = Booting <$R[V*,Packname]D3-3780> in script mode

<$M[Batboot]>There are two ways of having a script file execute automatically 
on boot up (rather than going interactive). 

By specifying the -F parameter on the DOS command line. Examples:

@EXAMPLES = C>><$R[V*,Packname]D3-3780> -fscrfile.scr

@EXAMPLES = C>><$R[V*,Packname]D3-3780> -f

In the first example the file <169>SCRFILE.SCR<170> would execute 
and in the second example the file <169><$R[V*,Packname]D3-3780>.SCR<170> 
(the default name) would execute. The program would return to DOS 
when the script file is through executing.

The other way is by specifying the F parameter in the configuration 
file. If the following line is included in the <169><$R[V*,Packname]D3-3780>.CFG<170> 
file the script file <169><$R[V*,Packname]D3-3780>.SCR<170> will execute:

@EXAMPLES = mov %dp,'F'

The DP (Dash Parameter) variable is expressly designed for this purpose. 
This assignment is only significant in the configuration file. The 
script file which is executed can be set in the configuration file 
also:

@EXAMPLES = mov %dp,'F' 

@EXAMPLES = cpy %sf,"scrfile.scr"

The script file <169>SCRFILE.scr<170> in the active directory would 
be executed in this case. The script file name can include a path 
and can be up to 65 characters long. The following would execute the 
script file in the emulation directory:

@EXAMPLES = mov %dp,'F'

@EXAMPLES = srite %sf,%ed+"\scrfile.scr"

In this example, the srite will assign the concatenation of the ED 
(emulation directory) plus the script file name to the script file 
variable. Assigning a value to the SF variable is only relevant in 
the configuration file.

The default names (<169><$R[V*,Packname]D3-3780>.SCR<170> and <169><$R[V*,Packname]D3-3780>.CFG<170>) 
can be changed to other values. See Chapter <$R[C#,Confile]9> for 
a discussion of how to change these names. 

